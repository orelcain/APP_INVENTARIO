<!DOCTYPE html>
<html>
<head>
  <title>Generador de Iconos PWA</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: white;
      padding: 20px;
    }
    .icons-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .icon-item {
      background: #2d3748;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
    }
    canvas {
      background: #1a1a2e;
      border-radius: 20%;
    }
    button {
      background: #5b8bb4;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #6ea8d4;
    }
    h1 { color: #5b8bb4; }
    .info { color: #a0aec0; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>ðŸ”§ Generador de Iconos PWA</h1>
  <p class="info">Haz clic en "Generar Todos" para crear los iconos PNG. Luego descarga cada uno.</p>
  
  <button onclick="generateAll()">ðŸ“¦ Generar Todos los Iconos</button>
  <button onclick="downloadAll()">ðŸ’¾ Descargar Todos</button>
  
  <div class="icons-grid" id="iconsGrid"></div>

  <script>
    const sizes = [72, 96, 128, 144, 152, 192, 384, 512];
    const canvases = {};

    function drawIcon(canvas, size) {
      const ctx = canvas.getContext('2d');
      canvas.width = size;
      canvas.height = size;
      
      const scale = size / 512;
      
      // Background gradient
      const bgGrad = ctx.createLinearGradient(0, 0, size, size);
      bgGrad.addColorStop(0, '#1a1a2e');
      bgGrad.addColorStop(1, '#16213e');
      
      // Icon gradient
      const iconGrad = ctx.createLinearGradient(0, 0, size, size);
      iconGrad.addColorStop(0, '#5b8bb4');
      iconGrad.addColorStop(1, '#6ea8d4');
      
      // Draw rounded background
      const radius = size * 0.2;
      ctx.beginPath();
      ctx.roundRect(0, 0, size, size, radius);
      ctx.fillStyle = bgGrad;
      ctx.fill();
      
      // Center
      const cx = size / 2;
      const cy = size / 2;
      
      // Draw gear
      ctx.save();
      ctx.translate(cx, cy - 20 * scale);
      
      // Gear teeth
      ctx.fillStyle = iconGrad;
      ctx.globalAlpha = 0.9;
      const teeth = 8;
      const outerR = 100 * scale;
      const innerR = 70 * scale;
      const toothH = 25 * scale;
      
      ctx.beginPath();
      for (let i = 0; i < teeth; i++) {
        const angle = (i / teeth) * Math.PI * 2;
        const nextAngle = ((i + 0.5) / teeth) * Math.PI * 2;
        const nextNextAngle = ((i + 1) / teeth) * Math.PI * 2;
        
        ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
        ctx.lineTo(Math.cos(angle) * (outerR + toothH), Math.sin(angle) * (outerR + toothH));
        ctx.lineTo(Math.cos(nextAngle) * (outerR + toothH), Math.sin(nextAngle) * (outerR + toothH));
        ctx.lineTo(Math.cos(nextAngle) * outerR, Math.sin(nextAngle) * outerR);
      }
      ctx.closePath();
      ctx.fill();
      
      // Inner circle (hole)
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#1a1a2e';
      ctx.beginPath();
      ctx.arc(0, 0, 45 * scale, 0, Math.PI * 2);
      ctx.fill();
      
      // Center dot
      ctx.fillStyle = iconGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 18 * scale, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
      
      // Draw box icon
      ctx.save();
      ctx.translate(cx, cy + 50 * scale);
      
      const boxW = 100 * scale;
      const boxH = 65 * scale;
      
      ctx.strokeStyle = '#5b8bb4';
      ctx.lineWidth = 5 * scale;
      ctx.beginPath();
      ctx.roundRect(-boxW/2, -boxH/2, boxW, boxH, 6 * scale);
      ctx.stroke();
      
      // Box line
      ctx.lineWidth = 3 * scale;
      ctx.beginPath();
      ctx.moveTo(-boxW/2, -boxH/4);
      ctx.lineTo(boxW/2, -boxH/4);
      ctx.stroke();
      
      // Box handle
      ctx.fillStyle = '#5b8bb4';
      ctx.beginPath();
      ctx.roundRect(-20 * scale, -boxH/2 - 8 * scale, 40 * scale, 12 * scale, 4 * scale);
      ctx.fill();
      
      ctx.restore();
    }

    function generateAll() {
      const grid = document.getElementById('iconsGrid');
      grid.innerHTML = '';
      
      sizes.forEach(size => {
        const item = document.createElement('div');
        item.className = 'icon-item';
        
        const canvas = document.createElement('canvas');
        canvas.id = `icon-${size}`;
        canvases[size] = canvas;
        
        drawIcon(canvas, size);
        
        const label = document.createElement('p');
        label.textContent = `${size}x${size}`;
        
        const btn = document.createElement('button');
        btn.textContent = 'ðŸ’¾ Descargar';
        btn.onclick = () => downloadIcon(size);
        
        item.appendChild(canvas);
        item.appendChild(label);
        item.appendChild(btn);
        grid.appendChild(item);
      });
    }

    function downloadIcon(size) {
      const canvas = canvases[size];
      const link = document.createElement('a');
      link.download = `icon-${size}x${size}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function downloadAll() {
      sizes.forEach((size, i) => {
        setTimeout(() => downloadIcon(size), i * 300);
      });
    }

    // Auto-generate on load
    generateAll();
  </script>
</body>
</html>
