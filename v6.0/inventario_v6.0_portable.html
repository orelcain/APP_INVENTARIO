<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inventario Visual PRO v6.0 - Portable Edition</title>
  <!-- 
    ═══════════════════════════════════════════════════════════════════════════════
    INVENTARIO VISUAL PRO v5.4.0 - REFACTORIZADO Y OPTIMIZADO
    ═══════════════════════════════════════════════════════════════════════════════
    
    🆕 VERSIÓN 5.3.3 - MEJORAS IMPLEMENTADAS (26/10/2025):
    
    ✅ ZOOM CON SCROLL EN LIGHTBOX:
      - Click en imagen de tarjeta → Abre lightbox
      - Scroll del mouse en lightbox → Zoom (100% a 500%)
      - Arrastrar con mouse → Mover imagen ampliada
      - Doble click → Reset a 100%
      - Funciona con navegación entre múltiples imágenes
    
    ✅ SISTEMA DE BACKUP AUTOMÁTICO DE MARCADORES:
      - Backup automático antes de cada guardado
      - Doble almacenamiento: localStorage (10 versiones) + FileSystem (20 versiones)
      - Protege marcadores en mapas (ubicaciones con mapId/areaId/markerX/markerY)
      - Botón "💾 Restaurar" en tab Mapas
      - UI visual con lista de backups disponibles
      - Muestra: fecha, hora, tiempo transcurrido, cantidad de marcadores
      - Restauración con confirmación y guardado automático
      - Ubicación: localStorage + INVENTARIO_STORAGE/backups_marcadores/
    
    ✅ MEJORAS EN UX:
      - Coincide con la hora real del sistema
    
    ✅ ESQUEMA VISUAL MEJORADO:
      - Indica claramente dónde pegar JSONs manualmente
      - Instrucciones paso a paso para actualización manual
      - Estructura de carpetas más clara y comprensible
    
    ✅ GESTIÓN VISUAL DE BACKUPS:
      - Ver historial de backups en modal interactivo
      - Restaurar cualquier backup con un click
      - Crear backups manuales cuando sea necesario
      - Información detallada: fecha, tamaño, cantidad, versión
    
    ✅ EXPORTACIÓN A PDF PROFESIONAL:
      - PDF con portada y estadísticas ejecutivas
      - Índice navegable organizado por áreas
      - Contenido detallado con jerarquías visuales
      - Indicadores de stock con colores (OK/Bajo/Sin Stock)
      - Formato listo para imprimir o compartir
    
    ✅ EXPORTACIÓN A EXCEL MEJORADA:
      - 10 hojas con análisis completo (antes 5)
      - Datos listos para crear gráficos
      - Hojas nuevas: Graf-Estado Stock, Graf-Top Áreas, Graf-Top Equipos, etc.
      - Columnas optimizadas y formato profesional
    
    ✅ RESPALDO COMPLETO (ZIP):
      - Incluye TODO: datos + mapas + áreas + imágenes
      - Compresión DEFLATE nivel 6
      - Compatible entre versiones (5.3.0 ↔ 5.3.2)
      - Perfecto para migración y respaldo completo
      - Restauración de imágenes en FileSystem
    
    ✅ PROTECCIÓN DE DATOS MULTI-NIVEL:
      - Nivel 1: Backups automáticos (últimos 5)
      - Nivel 2: LocalStorage (navegador)
      - Nivel 3: FileSystem (disco físico)
      - Nivel 4: Respaldo completo ZIP (exportación)
      - Nivel 5: PDF y Excel (documentación)
    
    📋 VERSIONES ANTERIORES:
    - v5.3.0: Sistema base con mapas y áreas
    - v5.3.1: Correcciones de encoding
    - v5.3.2: Sistema integral de backups y respaldos ← ACTUAL
    
    ═══════════════════════════════════════════════════════════════════════════════
  -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* 🎨 PALETA v6.0 - EQUILIBRADA (80% Grises, 20% Acentos) */
      --primary: #5b8bb4;           /* Azul corporativo desaturado */
      --primary-light: #7ba5c8;     /* Azul claro */
      --primary-dark: #4a7090;      /* Azul oscuro */
      --secondary: #6a7581;         /* Gris medio neutro */
      --success: #5b9b7a;           /* Verde esmeralda desaturado */
      --success-dark: #4a7d62;      /* Verde oscuro */
      --warning: #b8925a;           /* Ámbar desaturado */
      --warning-dark: #9a7848;      /* Ámbar oscuro */
      --danger: #b86b6b;            /* Rojo coral desaturado */
      --danger-dark: #985555;       /* Rojo oscuro */
      --info: #5b8bb4;              /* Azul info (igual a primary) */
      --info-dark: #4a7090;         /* Azul oscuro */
      
      /* 🌑 Fondos oscuros pero no extremos */
      --gray-50: #1a1d23;           /* Fondo app (ligeramente más claro) */
      --gray-100: #1e2229;          /* Base principal */
      --gray-200: #252a33;          /* Tarjetas (+10% luminosidad) */
      --gray-300: #2d333d;          /* Hover states */
      --gray-400: #3a4049;          /* Elevado */
      --gray-500: #4a5059;          /* Separadores */
      --gray-600: #6a7078;          /* Texto terciario */
      --gray-700: #8a9098;          /* Texto secundario */
      --gray-800: #b8bec8;          /* Texto normal */
      --gray-900: #e6e9ef;          /* Texto primario */
      
      /* 🎭 Sombras equilibradas (ni planas ni dramáticas) */
      --shadow-sm: 
        0 2px 4px rgba(0, 0, 0, 0.25),
        0 1px 2px rgba(0, 0, 0, 0.15);
      --shadow-md: 
        0 4px 8px rgba(0, 0, 0, 0.3),
        0 2px 4px rgba(0, 0, 0, 0.2);
      --shadow-lg: 
        0 8px 16px rgba(0, 0, 0, 0.35),
        0 4px 8px rgba(0, 0, 0, 0.25);
      --shadow-xl: 
        0 12px 24px rgba(0, 0, 0, 0.4),
        0 6px 12px rgba(0, 0, 0, 0.3);
      
      /* Atajos para compatibilidad */
      --card-shadow: var(--shadow-sm);
      --card-shadow-hover: var(--shadow-md);
      --neomorph-shadow: var(--shadow-md);
      --neomorph-shadow-sm: var(--shadow-sm);
      --neomorph-shadow-hover: var(--shadow-lg);
      --neomorph-shadow-inset: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      
      /* 📐 Geometría consistente - Border Radius estandarizado */
      --radius-sm: 6px;            /* Badges pequeños */
      --radius-md: 8px;            /* 🎯 DEFAULT - Botones, inputs, cards */
      --radius-lg: 12px;           /* Modales grandes */
      --radius-xl: 16px;           /* Imágenes */
      
      /* Bordes y líneas sutiles */
      --border-color: #2d333d;
      --border-color-light: #3a4049;
      --border-accent: #4a5059;
      
      /* 🌑 Fondos con profundidad sutil */
      --bg-primary: #1e2229;        /* Base principal */
      --bg-secondary: #252a33;      /* Tarjetas */
      --bg-tertiary: #2d333d;       /* Hover states */
      --bg-elevated: #3a4049;       /* Elementos elevados */
      --bg-app: #1a1d23;            /* Fondo general app */
      
      /* 🔤 Texto con jerarquía clara (4 niveles) */
      --text-primary: #e6e9ef;      /* Títulos (blanco casi puro) */
      --text-secondary: #b8bec8;    /* Texto normal (gris claro) */
      --text-muted: #8a909a;        /* Metadata (gris medio) */
      --text-disabled: #5a606a;     /* Deshabilitados (gris oscuro) */
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--bg-app);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background 0.3s ease, color 0.3s ease;
      margin: 0;
      padding: 0;
      
      /* Optimizaciones específicas para Microsoft Edge (Chromium) */
      text-rendering: optimizeLegibility;
      scroll-behavior: smooth;
      overscroll-behavior: contain; /* Evita scroll bounce en Edge móvil */
    }

    /* OPTIMIZACIONES MICROSOFT EDGE (Chromium) */
    
    /* Scroll Snap para paginación suave (Edge PC/Móvil) */
    .cards-grid {
      scroll-snap-type: y proximity;
      scroll-padding-top: 20px;
    }

    .repuesto-card {
      scroll-snap-align: start;
      scroll-snap-stop: normal;
      
      /* Backdrop Filter para efectos glassmorphism (Edge Chromium) */
      -webkit-backdrop-filter: blur(10px) saturate(180%);
      backdrop-filter: blur(10px) saturate(180%);
    }

    /* Container Queries (Edge 105+) - Tarjetas responsive sin media queries */
    @supports (container-type: inline-size) {
      .container {
        container-type: inline-size;
        container-name: main-container;
      }

      @container main-container (min-width: 1200px) {
        .cards-grid {
          grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }
      }

      @container main-container (max-width: 768px) {
        .cards-grid {
          grid-template-columns: 1fr;
        }
      }
    }

    /* Accent Color para inputs y botones (Edge Chromium) */
    :root {
      accent-color: var(--primary);
    }

    input[type="checkbox"],
    input[type="radio"],
    select,
    button {
      accent-color: var(--primary);
    }

    /* Smooth scrolling para listas largas (Edge Performance) */
    #cardsGrid,
    #listView,
    #conteoGrid {
      will-change: scroll-position;
      /* -webkit-overflow-scrolling obsoleto en navegadores modernos */
    }

    /* CSS Containment para mejor rendimiento (Edge Chromium) */
    .repuesto-card {
      contain: layout style paint;
    }

    /* Aspect Ratio nativo (Edge 88+) */
    .card-image {
      aspect-ratio: 16 / 9;
      object-fit: cover;
    }

    /* Logical Properties para mejor RTL/LTR (Edge Chromium) */
    .card-content {
      padding-inline: 12px;
      padding-block: 10px;
      margin-block-end: 6px;
    }

    /* Color Scheme para dark mode nativo (Edge) */
    :root {
      color-scheme: dark light;
    }

    /* Cascade Layers para mejor especificidad (Edge 99+) */
    @layer base, components, utilities;

    @layer base {
      * {
        box-sizing: border-box;
      }
    }

    /* Subgrid para layouts complejos (Edge 117+) */
    @supports (grid-template-rows: subgrid) {
      .list-view {
        display: grid;
        grid-template-rows: auto subgrid;
      }
    }

    /* Has() Selector para interactividad sin JS (Edge 105+) */
    .repuesto-card:has(input:focus) {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
    }

    /* MODOS DE VISUALIZACIÓN FORZADOS */
    
    /* Modo Móvil Forzado - Aplica estilos móviles independiente del tamaño de pantalla */
    body.force-mobile .cards-grid {
      grid-template-columns: 1fr !important;
      gap: 16px !important;
      padding: 16px !important;
    }

    body.force-mobile .repuesto-card {
      max-width: 600px !important;
      margin: 0 auto !important;
    }

    body.force-mobile .card-image {
      height: 250px !important;
    }

    body.force-mobile .card-btn {
      min-height: 48px !important;
      font-size: 1rem !important;
      padding: 12px 16px !important;
    }

    body.force-mobile .btn {
      min-height: 48px !important;
      font-size: 1rem !important;
      padding: 12px 20px !important;
    }

    body.force-mobile .container {
      padding: 16px !important;
    }

    body.force-mobile #pagination {
      flex-direction: column !important;
      gap: 12px !important;
    }

    body.force-mobile #pagination > div:first-child {
      width: 100% !important;
      justify-content: center !important;
    }

    /* Modo PC Forzado - Aplica estilos desktop independiente del tamaño de pantalla */
    body.force-desktop .cards-grid {
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)) !important;
      gap: 16px !important;
      padding: 20px !important;
    }

    body.force-desktop .repuesto-card {
      max-width: none !important;
    }

    body.force-desktop .card-content {
      padding: 12px !important;
    }

    body.force-desktop .card-content h3 {
      font-size: 0.95rem !important;
    }

    body.force-desktop .card-content h4 {
      font-size: 0.85rem !important;
    }

    body.force-desktop .info-row {
      font-size: 0.75rem !important;
    }

    body.force-desktop .card-btn {
      padding: 6px 10px !important;
      font-size: 0.75rem !important;
      min-height: 32px !important;
    }

    body.force-desktop .card-footer {
      padding: 0 12px 12px !important;
      gap: 4px !important;
    }

    body.force-desktop .card-image {
      height: 160px !important;
    }

    body.force-desktop .container {
      max-width: 1800px !important;
      padding: 20px 40px !important;
    }

    .header {
      background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
      border-bottom: 1px solid #334155;
    }

    .nav-tabs {
      background: #1e293b;
      border-bottom: 1px solid #334155;
    }

    .nav-tab {
      background: #0f172a;
      color: #94a3b8;
    }

    .nav-tab.active {
      background: #1e293b;
      color: #3b82f6;
      border-bottom-color: #3b82f6;
    }

    .repuesto-card {
      background: #1e293b;
      border: 1px solid #334155;
    }

    .modal-content,
    .stats-card,
    #pagination {
      background: #1e293b;
      border: 1px solid #334155;
    }

    .form-control {
      background: #0f172a;
      border-color: #334155;
      color: #f8fafc;
    }

    .form-control:focus {
      border-color: #3b82f6;
    }

    .btn {
      color: var(--text-primary);
      border: none;
      border-radius: var(--radius-md);
      padding: 8px 16px;
      box-shadow: var(--shadow-sm);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .btn:hover {
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .btn:active {
      box-shadow: var(--shadow-sm);
      transform: translateY(0);
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-success {
      background: var(--success);
      color: white;
    }

    .btn-success:hover {
      background: var(--success-dark);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: var(--danger-dark);
    }

    .search-input {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    .view-btn {
      background: #0f172a;
      color: #94a3b8;
      border-color: #334155;
    }

    .view-btn.active {
      background: #3b82f6;
      color: white;
    }

    .list-row {
      background: #0f172a;
      border-bottom-color: #334155;
    }

    .list-header {
      background: #1e293b;
      color: #f8fafc;
      border-bottom-color: #334155;
    }

    .conteo-item {
      background: #0f172a;
      border: 1px solid #334155;
    }

    .conteo-input {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    .tree-item {
      color: #f8fafc;
    }

    .tree-item:hover {
      background: #334155;
    }

    .tool-btn {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    .tool-btn.active {
      background: #3b82f6;
      color: white;
    }

    .autocomplete-list {
      background: #1e293b;
      border-color: #334155;
    }

    .autocomplete-item {
      color: #f8fafc;
    }

    .autocomplete-item:hover {
      background: #334155;
    }

    .lightbox {
      background: rgba(15, 23, 42, 0.95);
    }

    .lightbox-close {
      background: #334155;
      color: #f8fafc;
    }

    .stats-card {
      background: #1e293b;
      border-color: #334155;
    }

    canvas {
      background: #0f172a !important;
    }

    /* MODO OSCURO - ELEMENTOS ADICIONALES */
    .btn-secondary {
      background: #334155;
      color: #f8fafc;
      border: 1px solid #475569;
    }

    .btn-secondary:hover {
      background: #475569;
    }

    .btn-warning {
      background: #f59e0b;
      color: #0f172a;
    }

    .btn-warning:hover {
      background: #d97706;
    }

    select.form-control {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    select.form-control option {
      background: #1e293b;
      color: #f8fafc;
    }

    /* Estilos específicos para select de categoría */
    #categoria {
      font-size: 1rem;
      font-weight: 400;
      color: #e2e8f0;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    #categoria option {
      font-size: 0.95rem;
      line-height: 2;
      padding: 12px 14px;
      background: #1e293b;
      color: #e2e8f0;
    }

    /* Nombres de categoría en azul oscuro opaco y negrita */
    #categoria option:not(:first-child)::before {
      color: #4A6278;
      font-weight: 700;
    }

    #categoria option:first-child {
      color: #94a3b8;
      font-weight: normal;
      font-size: 0.9rem;
    }

    label {
      color: #e2e8f0;
    }

    small {
      color: #94a3b8 !important;
    }

    h2, 
    h3, 
    h4 {
      color: #f8fafc;
    }

    .info-label {
      color: #94a3b8;
    }

    .info-value {
      color: #f8fafc;
    }

    .card-badge {
      border: 2px solid #334155;
    }

    .toggle-label {
      color: #f8fafc;
    }

    #pageInfo {
      background: #1e293b;
      color: #f8fafc;
      border-color: #334155;
      padding: 6px 12px;
      font-size: 0.8rem;
    }

    .tree-node {
      border-left-color: #334155;
    }

    .stat-value {
      color: #f8fafc !important;
    }

    .stat-label {
      color: #cbd5e1 !important;
    }

    .preview-card {
      background: #1e293b;
      border-color: #334155;
    }

    .export-menu {
      background: #1e293b;
      border-color: #334155;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .export-option {
      color: #f8fafc;
    }

    .export-option:hover {
      background: #334155;
    }

    /* MODO OSCURO - MEJORAS COMPLETAS ADICIONALES */
    
    /* Botones de tarjeta */
    .card-btn {
      background: #0f172a;
      border-color: #475569;
      color: #cbd5e1;
    }

    .card-btn:hover {
      background: #334155;
      border-color: #64748b;
    }

    .btn-edit {
      border-color: #3b82f6;
      color: #60a5fa;
    }

    .btn-edit:hover {
      background: #3b82f6;
      color: white;
    }

    .btn-delete {
      border-color: #ef4444;
      color: #f87171;
    }

    .btn-delete:hover {
      background: #ef4444;
      color: white;
    }

    /* Badges de stock */
    .badge-ok {
      background: rgba(16, 185, 129, 0.2);
      color: #34d399;
      border-color: #10b981;
    }

    .badge-bajo {
      background: rgba(245, 158, 11, 0.2);
      color: #fbbf24;
      border-color: #f59e0b;
    }

    .badge-cero {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
      border-color: #ef4444;
    }

    /* Formularios */
    .form-group label {
      color: #e2e8f0;
      font-weight: 600;
    }

    textarea.form-control {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    textarea.form-control:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    input[type="number"].form-control,
    input[type="text"].form-control {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-color: var(--border-color);
      border-radius: var(--radius-md);
    }

    input::-webkit-input-placeholder {
      color: #64748b;
    }

    input::placeholder {
      color: rgba(100, 116, 139, 0.2);
    }

    /* Modal header y títulos */
    .modal-title {
      color: #60a5fa;
    }

    .modal-close {
      background: #ef4444;
    }

    .modal-close:hover {
      background: #dc2626;
    }

    /* TOGGLE SWITCH PROFESIONAL MATE (iOS-like) */
    .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
      background: #3a4556;
      border-radius: 26px;
      cursor: pointer;
      transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid #4a5568;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }

    .toggle-slider {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      background: #9ca3af;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }

    .toggle-switch input:checked + .toggle-slider {
      transform: translateX(24px);
      background: #e5e7eb;
    }

    .toggle-switch:has(input:checked) {
      background: var(--primary);
      border-color: var(--primary-light);
    }

    .toggle-switch:hover {
      background: #4a5568;
    }

    .toggle-switch:has(input:checked):hover {
      background: var(--primary-light);
    }

    /* Paginación */
    .btn-secondary {
      background: #334155;
      color: #cbd5e1;
      border-color: #475569;
    }

    .btn-secondary:hover {
      background: #475569;
      color: #f8fafc;
    }

    .btn-secondary:disabled {
      background: #1e293b;
      color: #64748b;
      border-color: #334155;
      opacity: 0.5;
    }

    /* Vista de lista */
    .list-view {
      background: #1e293b;
      border: 1px solid #334155;
    }

    .list-row:hover {
      background: #334155;
    }

    /* Árbol jerárquico */
    .tree-container {
      background: #1e293b;
      border-color: #334155;
    }

    .tree-toggle {
      color: #cbd5e1;
    }

    .tree-toggle:hover {
      color: #f8fafc;
    }

    /* Conteo */
    .conteo-container {
      background: #1e293b;
    }

    /* ESTILOS RESPONSIVE PARA CONTEO */
    .conteo-card-responsive {
      background: #0f172a;
      border: 2px solid #334155;
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
    }

    .conteo-card-responsive:hover {
      border-color: #475569;
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .conteo-card-responsive.conteo-alerta {
      border-color: #ef4444;
      border-width: 3px;
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
    }

    .conteo-img-wrapper {
      width: 100%;
      height: 180px;
      overflow: hidden;
      background: #1e293b;
    }

    .conteo-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .conteo-info {
      padding: 16px;
      flex: 1;
    }

    .conteo-header {
      margin-bottom: 12px;
    }

    .conteo-codigo {
      color: #60a5fa;
      font-size: 1.1rem;
      display: block;
      margin-bottom: 6px;
      font-weight: 700;
    }

    .conteo-nombre {
      font-size: 0.95rem;
      color: #cbd5e1;
      display: block;
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .conteo-area {
      font-size: 0.8rem;
      color: #94a3b8;
      background: #1e293b;
      padding: 4px 10px;
      border-radius: 6px;
      display: inline-block;
    }

    .conteo-stats {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 12px;
      padding: 12px;
      background: #1e293b;
      border-radius: 8px;
    }

    .conteo-stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .conteo-stat-label {
      color: #94a3b8;
      font-weight: 500;
    }

    .conteo-stat-value {
      color: #f8fafc;
      font-weight: 700;
      font-size: 1.1rem;
    }

    .conteo-diferencia {
      font-weight: 800;
      font-size: 1.1rem;
      padding: 4px 12px;
      border-radius: 6px;
    }

    .conteo-diferencia.positiva {
      color: #10b981;
      background: rgba(16, 185, 129, 0.1);
    }

    .conteo-diferencia.negativa {
      color: #ef4444;
      background: rgba(239, 68, 68, 0.1);
    }

    .conteo-igual {
      color: #10b981;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .conteo-revisar {
      color: #ef4444;
      font-weight: 700;
      font-size: 0.8rem;
      text-align: center;
      padding: 6px;
      background: rgba(239, 68, 68, 0.1);
      border-radius: 6px;
      margin-top: 4px;
    }

    .conteo-control {
      padding: 16px;
      background: #1e293b;
      border-top: 1px solid #334155;
    }

    .conteo-label {
      display: block;
      color: #cbd5e1;
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 10px;
      text-align: center;
    }

    .conteo-input-group {
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 8px;
      align-items: center;
    }

    .conteo-btn-minus,
    .conteo-btn-plus {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      border: none;
      color: white;
      font-size: 2rem;
      font-weight: 700;
      height: 56px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }

    .conteo-btn-minus {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .conteo-btn-minus:hover {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      transform: scale(1.05);
    }

    .conteo-btn-plus:hover {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transform: scale(1.05);
    }

    .conteo-btn-minus:active,
    .conteo-btn-plus:active {
      transform: scale(0.95);
    }

    .btn-symbol {
      display: block;
      line-height: 1;
      margin-top: -4px;
    }

    .conteo-input-number {
      background: #0f172a;
      border: 3px solid #475569;
      color: #f8fafc;
      font-size: 1.8rem;
      font-weight: 800;
      text-align: center;
      padding: 12px;
      border-radius: 12px;
      width: 100%;
      transition: all 0.2s ease;
    }

    .conteo-input-number:focus {
      border-color: #3b82f6;
      outline: none;
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
      background: #1e293b;
    }

    /* Grid responsive para conteo */
    #conteoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(min(100%, 300px), 1fr));
      gap: 20px;
      padding: 20px;
    }

    /* Responsive para pantallas grandes */
    @media (min-width: 768px) {
      #conteoGrid {
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      }
    }

    @media (min-width: 1200px) {
      #conteoGrid {
        grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
      }
    }

    /* Responsive Grid de Tarjetas Principales - Aprovecha ancho de pantalla */
    @media (min-width: 768px) {
      .cards-grid {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 18px;
      }
    }

    @media (min-width: 1200px) {
      .cards-grid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 18px;
      }
    }

    @media (min-width: 1600px) {
      .cards-grid {
        grid-template-columns: repeat(auto-fill, minmax(270px, 1fr));
        gap: 20px;
      }
    }

    @media (min-width: 1920px) {
      .cards-grid {
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 20px;
      }
    }

    /* Optimización de tarjetas para pantallas grandes - Aprovechar espacio */
    @media (min-width: 1200px) {
      .card-content {
        padding: 14px;
      }

      .card-content h3 {
        font-size: 1rem;
      }

      .card-content h4 {
        font-size: 0.9rem;
        margin-bottom: 10px;
      }

      .card-info {
        gap: 6px;
        margin-bottom: 10px;
      }

      .info-row {
        font-size: 0.8rem;
      }

      .card-footer {
        padding: 0 14px 14px;
        gap: 6px;
      }

      .card-btn {
        padding: 7px 10px;
        font-size: 0.8rem;
        min-height: 36px;
      }
    }

    @media (min-width: 1600px) {
      .card-image {
        height: 180px;
      }
    }

    /* Optimización táctil móvil */
    @media (max-width: 600px) {
      .conteo-btn-minus,
      .conteo-btn-plus {
        height: 60px;
        font-size: 2.2rem;
      }

      .conteo-input-number {
        font-size: 2rem;
        padding: 16px;
      }

      .conteo-img-wrapper {
        height: 200px;
      }
    }

    /* Lightbox */
    .lightbox-content img {
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }

    .lightbox-nav {
      background: rgba(30, 41, 59, 0.9);
      color: #f8fafc;
    }

    .lightbox-nav:hover {
      background: rgba(51, 65, 85, 0.9);
    }

    /* Mapa */
    .map-container {
      background: #0f172a;
      border-color: #334155;
    }

    .map-controls {
      background: #1e293b;
      border-color: #334155;
    }

    /* Stats cards */
    .stats-grid {
      gap: 20px;
    }

    .stats-card {
      background: #1e293b;
      border: 1px solid #334155;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .stats-card:hover {
      border-color: #475569;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    /* Búsqueda */
    .search-container {
      background: #1e293b;
    }

    .search-input {
      background: #0f172a;
      color: #f8fafc;
      border-color: #334155;
    }

    .search-input::placeholder {
      color: rgba(100, 116, 139, 0.2);
    }

    .search-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    /* Botones de vista */
    .view-btn {
      background: #0f172a;
      color: #cbd5e1;
      border-color: #334155;
    }

    .view-btn:hover {
      background: #334155;
      border-color: #475569;
      color: #f8fafc;
    }

    .view-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }

    /* Precio info */
    .precio-info {
      background: rgba(59, 130, 246, 0.1);
      border-left-color: #3b82f6;
    }

    .precio-info .info-value {
      color: #60a5fa;
    }

    /* Tablas y dividers */
    hr {
      border-color: #334155;
    }

    /* Tooltips y hints */
    [title]:hover::after {
      background: #1e293b;
      color: #f8fafc;
      border-color: #334155;
    }

    /* Scrollbars en modo oscuro */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: #0f172a;
    }

    ::-webkit-scrollbar-thumb {
      background: #334155;
      border-radius: 6px;
      border: 2px solid #0f172a;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #475569;
    }

    /* Mejoras de contraste para textos pequeños */
    .card-badge,
    .info-row {
      color: #f8fafc;
    }

    .info-row .info-label {
      color: #94a3b8;
    }

    .info-row .info-value {
      color: #f8fafc;
      font-weight: 600;
    }

    /* HEADER MEJORADO - Modo Oscuro Optimizado */
    .header {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      color: white;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(59, 130, 246, 0.2);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.3));
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
      border: 1px solid rgba(59, 130, 246, 0.3);
    }

    .logo-text h1 {
      font-size: 1.3rem;
      font-weight: 700;
      margin: 0;
      line-height: 1.2;
    }

    .logo-text p {
      font-size: 0.7rem;
      opacity: 0.9;
      margin: 0;
      line-height: 1.2;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      touch-action: manipulation;
      min-height: 48px;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      transform: translate(-50%, -50%);
      transition: width 0.4s, height 0.4s;
    }

    .btn:hover::before {
      width: 200px;
      height: 200px;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      box-shadow: none;
    }

    .btn:disabled::before {
      display: none;
    }

    .btn:disabled:hover {
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-primary:hover {
      background: var(--primary-dark);
      box-shadow: var(--shadow-lg);
    }

    .btn-success {
      background: var(--success);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-success:hover {
      background: var(--success-dark);
      box-shadow: var(--shadow-lg);
    }

    .btn-warning {
      background: var(--warning);
      color: #1e293b;
      box-shadow: var(--shadow-md);
      font-weight: 700;
    }

    .btn-warning:hover {
      background: var(--warning-dark);
      box-shadow: var(--shadow-lg);
    }

    .btn-info {
      background: #06b6d4;
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-info:hover {
      background: #0891b2;
      box-shadow: var(--shadow-lg);
    }

    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
      border: 2px solid var(--border-color);
    }

    .btn-secondary:hover {
      background: var(--bg-primary);
      border-color: var(--primary);
      box-shadow: var(--shadow-md);
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 0.85rem;
      min-height: 36px;
    }

    .btn-danger {
      background: var(--danger);
      color: white;
      box-shadow: var(--shadow-md);
    }

    .btn-danger:hover {
      background: var(--danger-dark);
      box-shadow: var(--shadow-lg);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border-color);
    }

    .btn-secondary:hover {
      background: var(--bg-secondary);
      box-shadow: var(--shadow-md);
    }

    .toggle-precio {
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s;
      font-weight: 600;
      min-height: 48px;
    }

    .toggle-precio.active {
      background: rgba(255,255,255,0.3);
      border-color: rgba(255,255,255,0.5);
    }

    /* NAVEGACIÓN PROFESIONAL - DESTACADA */
    .nav-tabs {
      background: var(--bg-secondary);
      display: flex;
      border-bottom: 3px solid var(--border-color);
      overflow-x: auto;
      /* -webkit-overflow-scrolling obsoleto en navegadores modernos */
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      /* No necesita position: sticky porque está dentro de sticky-header-container */
    }

    .nav-tab {
      flex: 1;
      min-width: 120px;
      padding: 10px 14px;
      text-align: center;
      background: var(--bg-primary);
      border: none;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.9rem;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--text-muted);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      border-bottom: 4px solid transparent;
      border-right: 1px solid var(--border-color);
      touch-action: manipulation;
      position: relative;
    }

    .nav-tab:last-child {
      border-right: none;
    }

    .nav-tab::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 4px;
      background: var(--primary);
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav-tab:hover {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      transform: translateY(-2px);
    }

    .nav-tab:hover::before {
      width: 100%;
    }

    .nav-tab.active {
      background: var(--bg-elevated);
      color: var(--primary-light);
      border-bottom-color: var(--primary);
      box-shadow: inset 0 -4px 0 0 var(--primary);
    }

    .nav-tab.active::before {
      width: 100%;
    }

    /* CONTENEDOR PRINCIPAL - 100% ADAPTATIVO */
    .container {
      max-width: 100%;
      width: 100%;
      margin: 0;
      padding: 0; /* 🔧 Cambiado de 16px a 0px para eliminar el espacio naranja */
    }

    .tab-content {
      display: none;
      height: calc(100vh - 10px); /* 🔧 Reducido de 60px a 50px para ocupar más altura */
      overflow: auto; /* ✅ Restaurado: auto para que otras pestañas funcionen */
      padding: 10px; /* ✅ Restaurado: padding para otras pestañas */
    }

    .tab-content.active {
      display: block; /* ✅ Restaurado: block para compatibilidad general */
      animation: fadeIn 0.3s;
    }
    
    /* 🎯 REGLA ESPECÍFICA PARA TAB MAPA */
    #mapa.tab-content {
      padding: 0; /* Sin padding solo para MAPA */
      overflow: hidden; /* Sin scroll solo para MAPA */
      position: fixed; /* 🔧 Posición fija para ignorar contenedores */
      top: 45px; /* 🔧 Justo debajo de las pestañas */
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: calc(100vh - 45px);
      z-index: 1;
    }
    
    #mapa.tab-content.active {
      display: flex; /* Flex solo para MAPA cuando está activo */
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* TOOLBAR - Neumorfismo */
    .toolbar {
      background: var(--bg-secondary);
      padding: 16px;
      border-radius: var(--radius-md);
      margin-bottom: 20px;
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border-color);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .search-box {
      flex: 1;
      min-width: 250px;
      position: relative;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--gray-400);
      font-size: 1.2rem;
    }

    .search-input {
      width: 100%;
      padding: 12px 12px 12px 40px;
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      font-size: 1rem;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      background: var(--bg-tertiary);
      box-shadow: var(--shadow-sm);
      color: var(--text-primary);
    }

    .search-input:focus {
      outline: none;
      background: var(--bg-tertiary);
      border-color: var(--primary);
      box-shadow: var(--shadow-sm), 0 0 0 3px rgba(91, 139, 180, 0.2);
    }

    .view-btns {
      display: flex;
      gap: 8px;
    }

    .view-btn {
      padding: 10px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-primary);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-sm);
    }

    .view-btn:hover {
      color: var(--primary);
      background: var(--bg-secondary);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    .view-btn.active {
      background: var(--primary);
      color: white;
      box-shadow: var(--shadow-md);
    }

    /* 🎨 BOTÓN DE CONEXIÓN - Estilo Neomorphism/Soft UI */
    #connectionBtn {
      position: relative;
      border: none !important;
      cursor: default !important;
      padding: 10px 14px !important;
      border-radius: var(--radius-md) !important;
      font-weight: 700;
      font-size: 1rem;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    #connectionBtn:hover {
      transform: translateY(-1px);
      box-shadow: 
        0 10px 15px -3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    #connectionBtn #connectionIcon {
      font-weight: 700;
      font-size: 1.1rem;
      display: inline-block;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    /* FILTROS */
    .filters-selects {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .filter-select {
      padding: 12px 16px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      min-height: 48px;
      appearance: none;
      box-shadow: var(--shadow-sm);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238a909a' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 40px;
    }

    .filter-select:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-color-light);
    }

    .filter-select:focus {
      outline: none;
      background: var(--bg-tertiary);
      border-color: var(--primary);
      box-shadow: var(--shadow-sm), 0 0 0 3px rgba(91, 139, 180, 0.2);
    }

    .filter-chip {
      padding: 8px 16px;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-primary);
      transition: all 0.3s;
      touch-action: manipulation;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
    }

    .filter-chip:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: var(--bg-primary);
    }

    .filter-chip.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* GRID DE TARJETAS */
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 18px;
      margin-bottom: 20px;
    }

    .repuesto-card {
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      transition: all 0.2s ease;
      cursor: pointer;
      border: 1px solid var(--border-color);
      position: relative;
    }

    .repuesto-card:hover {
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
      border-color: rgba(91, 139, 180, 0.3);
    }

    .card-image {
      height: 200px;
      background: var(--bg-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      border-bottom: 1px solid var(--border-color);
    }

    .card-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .card-image .no-image {
      font-size: 4rem;
      color: var(--gray-400);
    }

    .card-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 10px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 0.75rem;
      background: rgba(0, 0, 0, 0.7);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      letter-spacing: 0.5px;
    }

    .badge-ok {
      background: rgba(91, 155, 122, 0.95);
      color: #fff;
      border-color: rgba(91, 155, 122, 0.3);
    }

    .badge-bajo {
      background: rgba(184, 146, 90, 0.95);
      color: #fff;
      border-color: rgba(184, 146, 90, 0.3);
    }

    .badge-cero {
      background: rgba(184, 107, 107, 0.95);
      color: #fff;
      border-color: rgba(184, 107, 107, 0.3);
    }

    .card-content {
      padding: 10px 12px;
    }

    .card-content h3 {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-primary);
      background: transparent;
      padding: 0;
      border-left: 3px solid var(--primary);
      padding-left: 8px;
      margin-bottom: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      line-height: 1.3;
    }

    .card-content h4 {
      font-size: 0.95rem;
      color: var(--text-primary);
      margin-bottom: 12px;
      font-weight: 500;
    }

    .card-info {
      display: grid;
      gap: 3px;
      margin-bottom: 6px;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
      line-height: 1.3;
      margin-bottom: 2px;
      padding: 3px 4px;
      background: transparent;
      border-bottom: 1px solid rgba(91, 139, 180, 0.1);
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: var(--text-muted);
      font-weight: 500;
      font-size: 0.65rem;
    }

    .info-value {
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.7rem;
    }

    .card-footer {
      display: flex;
      gap: 6px;
      padding: 0 12px 10px;
    }

    .card-btn {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-weight: 500;
      font-size: 0.7rem;
      transition: all 0.2s ease;
      color: var(--text-secondary);
      min-height: 32px;
    }

    .card-btn:hover {
      background: var(--bg-secondary);
      border-color: var(--border-color-light);
      transform: none;
    }

    .btn-edit {
      border-color: var(--primary);
      color: var(--primary);
    }

    .btn-edit:hover {
      background: var(--primary);
      color: white;
    }

    .btn-delete {
      border-color: var(--danger);
      color: var(--danger);
    }

    .btn-delete:hover {
      background: var(--danger);
      color: white;
    }

    /* Datos Técnicos - Estilo Corporativo */
    .datos-tecnicos-box {
      background: rgba(91, 139, 180, 0.08);
      border-left: 3px solid var(--primary);
      padding: 8px 10px;
      border-radius: var(--radius-sm);
      margin: 8px 0;
    }

    .datos-tecnicos-title {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .datos-tecnicos-content {
      font-size: 0.75rem;
      color: var(--text-secondary);
      line-height: 1.5;
      font-family: 'Courier New', monospace;
      white-space: pre-line;
      word-break: break-word;
    }

    /* Contador de Stock - Estilo Corporativo */
    .stock-counter-box {
      background: var(--bg-tertiary);
      padding: 6px 8px;
      border-radius: var(--radius-sm);
      margin-top: 6px;
      border-left: 3px solid currentColor;
    }

    /* Botones de Ubicación/Mapa - Estilo Corporativo */
    .btn-add-location,
    .btn-view-map {
      flex: 1;
      padding: 6px 10px;
      font-size: 0.75rem;
      font-weight: 500;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .btn-add-location {
      background: rgba(91, 155, 122, 0.85);
      border: 1px solid rgba(91, 155, 122, 0.3);
      font-weight: 500;
      font-size: 0.7rem;
    }

    .btn-add-location:hover {
      background: rgba(91, 155, 122, 1);
      box-shadow: var(--shadow-sm);
    }

    .btn-view-map {
      background: rgba(91, 139, 180, 0.85);
      border: 1px solid rgba(91, 139, 180, 0.3);
      font-weight: 500;
      font-size: 0.7rem;
    }

    .btn-view-map:hover {
      background: rgba(91, 139, 180, 1);
      box-shadow: var(--shadow-sm);
    }

    /* VISTA LISTA - Compactada con Estilo Corporativo */
    .list-view {
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      border: 1px solid var(--border-color);
    }

    .list-header {
      display: grid;
      grid-template-columns: 50px 0.9fr 1.5fr 160px 220px;
      gap: 6px;
      padding: 6px 10px;
      background: #4A5568;
      font-weight: 700;
      font-size: 0.75rem;
      color: var(--text-primary);
      border-bottom: 2px solid var(--primary);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .list-header-cell {
      display: flex;
      align-items: center;
      gap: 3px;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
      padding: 2px 4px;
      border-radius: 3px;
      transition: all 0.2s;
      position: relative;
    }
    
    .list-header-cell:hover {
      background: rgba(91, 124, 153, 0.3);
      color: #5B7C99;
    }
    
    .list-header-cell.active {
      background: rgba(91, 124, 153, 0.4);
      color: #5B7C99;
    }

    /* Resize handle para columnas */
    .resize-handle {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 5px;
      cursor: col-resize;
      -webkit-user-select: none;
      user-select: none;
      background: transparent;
      z-index: 20;
    }

    .resize-handle:hover {
      background: var(--primary);
      box-shadow: 0 0 4px var(--primary);
    }

    .resize-handle.resizing {
      background: var(--primary);
      box-shadow: 0 0 8px var(--primary);
    }

    .list-header.resizing {
      -webkit-user-select: none;
      user-select: none;
    }

    .list-header.resizing .list-header-cell {
      pointer-events: none;
    }

    .list-header.resizing .resize-handle {
      pointer-events: auto;
    }
    
    .sort-icon {
      font-size: 0.65rem;
      opacity: 0.6;
      transition: all 0.2s;
    }
    
    .list-header-cell.active .sort-icon {
      opacity: 1;
      transform: scale(1.1);
    }

    .list-row {
      display: grid;
      grid-template-columns: 50px 0.9fr 1.5fr 160px 220px;
      gap: 6px;
      padding: 6px 0px 6px 10px;
      border-bottom: 1px solid var(--border-color);
      align-items: center;
      transition: all 0.2s;
      font-size: 0.8rem;
      min-height: 36px;
    }
    
    .list-row > div:last-child,
    .list-row .list-actions {
      justify-self: end !important;
      padding-right: 10px !important;
    }
    
    .list-row > div {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      min-height: 100%;
    }
    
    .list-row .list-actions {
      display: flex !important;
      flex-direction: row !important;
      align-items: center !important;
      align-self: stretch !important;
      justify-content: flex-end !important;
      gap: 4px !important;
      padding: 0 !important;
      width: 100% !important;
      margin: 0 !important;
    }
    
    .stock-visual {
      display: flex;
      flex-direction: column;
      gap: 1px;
      width: 100%;
      align-items: stretch !important;
    }
    
    .stock-numbers {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.7rem;
    }
    
    .stock-bar-container {
      width: 100%;
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .stock-bar {
      height: 100%;
      border-radius: 2px;
      transition: width 0.3s ease, background 0.3s ease;
      box-shadow: 0 0 4px rgba(0,0,0,0.15);
    }

    .list-row:hover {
      background: var(--bg-primary);
    }

    .list-row:last-child {
      border-bottom: none;
    }

    .list-actions {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3px;
      width: 100%;
      align-items: center !important;
    }

    .list-actions button {
      padding: 5px 4px;
      font-size: 0.7rem;
      min-height: 28px;
      width: 100%;
      white-space: nowrap;
    }

    /* PAGINACIÓN */
    #pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin: 0 auto 16px auto;
      max-width: 100%;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-color);
      flex-wrap: wrap;
    }

    #pagination .btn {
      padding: 6px 12px;
      min-width: auto;
      min-height: 32px;
      font-size: 0.8rem;
    }

    #pageNumbers {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    #pageNumbers .btn {
      min-width: 42px;
      padding: 8px 12px;
      transition: all 0.3s ease;
    }

    #itemsPerPageSelect {
      transition: all 0.3s ease;
      font-weight: 500;
    }

    #itemsPerPageSelect:hover {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    #itemsPerPageSelect:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15);
    }

    #pageNumbers .btn:not(:disabled):hover {
      opacity: 1 !important;
      transform: scale(1.05);
    }

    #pageNumbers .btn:disabled {
      opacity: 1 !important;
      transform: scale(1.1);
      cursor: default;
      font-weight: 700;
    }

    /* MODAL */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.9);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      overflow-y: auto;
      padding: 10px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 20px;
      max-width: calc(100vw - 20px);
      width: 800px;
      max-height: 95vh;
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
      position: relative;
      border: 1px solid var(--border-color);
      animation: slideUp 0.25s ease;
      display: flex;
      flex-direction: column;
      margin: auto;
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Optimización de scroll suave */
    .modal-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .modal-content::-webkit-scrollbar-track {
      background: var(--bg-primary);
      border-radius: 10px;
    }
    
    .modal-content::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 10px;
    }
    
    .modal-content::-webkit-scrollbar-thumb:hover {
      background: #4d92e6;
    }

    @keyframes slideUp {
      from {
        transform: translateY(30px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      border: none;
      background: rgba(184, 107, 107, 0.9);
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 20px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .modal-close:hover {
      background: var(--danger);
      box-shadow: var(--shadow-sm);
    }

    .modal-title {
      font-size: 1.4rem;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 20px;
      padding-right: 50px;
      border-bottom: 2px solid var(--primary);
      padding-bottom: 12px;
    }

    .form-group {
      margin-bottom: 0;
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      display: block;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 4px;
      font-size: 0.85rem;
    }

    .form-control {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.9rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      font-family: inherit;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(91, 139, 180, 0.1);
      background: var(--bg-secondary);
    }

    .form-control::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    
    /* Layout optimizado para 3 columnas en pantallas grandes */
    .form-row-triple {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    
    /* Layout optimizado para 4 columnas en campos pequeños */
    .form-row-quad {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    
    /* Contenedor del formulario compactado */
    .modal-form {
      display: grid;
      gap: 12px;
      flex: 1;
      min-height: 0;
    }
    
    /* Sección de multimedia con altura flexible */
    .multimedia-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .multimedia-preview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      max-height: 300px;
      overflow-y: auto;
      padding: 10px;
      background: var(--bg-primary);
      border-radius: 6px;
      border: 1px solid var(--border-color);
    }
    
    .preview-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }
    
    .preview-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .preview-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      background: var(--danger);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .preview-delete:hover {
      background: #d63031;
    }
    
    .preview-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 0.7rem;
      padding: 4px;
      text-align: center;
    }
    
    .multimedia-preview::-webkit-scrollbar {
      width: 6px;
    }
    
    .multimedia-preview::-webkit-scrollbar-thumb {
      background: var(--gray-400);
      border-radius: 3px;
    }

    .autocomplete-container {
      position: relative;
    }

    .autocomplete-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border: 2px solid var(--primary);
      border-top: none;
      border-radius: 0 0 8px 8px;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 8px 16px rgba(0,0,0,0.4);
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: none;
    }

    .autocomplete-list.active {
      display: block;
    }

    .autocomplete-item {
      padding: 12px;
      cursor: pointer;
      transition: background 0.2s;
      border-bottom: 1px solid var(--gray-200);
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: var(--bg-secondary);
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    /* LIGHTBOX */
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 3000;
      align-items: center;
      justify-content: center;
    }

    .lightbox.active {
      display: flex;
    }

    .lightbox-content {
      max-width: 90%;
      max-height: 90%;
      position: relative;
    }

    .lightbox-content img,
    .lightbox-content video {
      max-width: 100%;
      max-height: 90vh;
      border-radius: 8px;
    }

    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: var(--danger);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 30px;
      cursor: pointer;
      z-index: 3001;
      transition: all 0.3s;
    }

    .lightbox-close:hover {
      background: #b91c1c;
      transform: rotate(90deg);
    }

    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      padding: 20px;
      font-size: 30px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.3s;
      z-index: 3001;
    }

    .lightbox-nav:hover {
      background: rgba(255,255,255,0.4);
    }

    .lightbox-prev {
      left: 20px;
    }

    .lightbox-next {
      right: 20px;
    }

    /* JERARQUÍA CASCADA - Estilo árbol visual */
    .hierarchy-tree {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .hierarchy-level {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      background: var(--bg-primary);
      border-radius: 10px;
      border-left: 4px solid var(--border-color);
      transition: all 0.3s ease;
      position: relative;
      animation: slideInRight 0.3s ease-out forwards;
      opacity: 0;
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .hierarchy-level:nth-child(1) {
      border-left-color: var(--warning);
      animation-delay: 0.1s;
    }

    .hierarchy-level:nth-child(2) {
      border-left-color: var(--primary);
      margin-left: 24px;
      animation-delay: 0.2s;
    }

    .hierarchy-level:nth-child(3) {
      border-left-color: var(--info);
      margin-left: 48px;
      animation-delay: 0.3s;
    }

    .hierarchy-level:nth-child(4) {
      border-left-color: var(--success);
      margin-left: 72px;
      animation-delay: 0.4s;
    }

    .hierarchy-level:hover {
      background: var(--bg-tertiary);
      transform: translateX(4px);
      box-shadow: var(--shadow-md);
    }

    .hierarchy-icon {
      font-size: 1.8rem;
      flex-shrink: 0;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    }

    .hierarchy-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .hierarchy-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }

    .hierarchy-value {
      font-size: 1.05rem;
      color: var(--text-primary);
      font-weight: 600;
    }

    .hierarchy-connector {
      position: absolute;
      left: -12px;
      top: -8px;
      bottom: -8px;
      width: 2px;
      background: linear-gradient(180deg, transparent 0%, var(--border-color) 20%, var(--border-color) 80%, transparent 100%);
    }

    .hierarchy-level:nth-child(1) .hierarchy-connector {
      display: none;
    }

    /* Botón icono de jerarquía en tarjetas */
    .btn-hierarchy {
      background: var(--primary);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: var(--radius-sm);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
      flex-shrink: 0;
    }

    .btn-hierarchy:hover {
      background: var(--primary-dark);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    .btn-hierarchy:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }

    /* Modal Estadísticas - Responsive */
    @media (max-width: 768px) {
      #modalEstadisticas > div {
        width: 95% !important;
        height: 95vh !important;
        margin: 2.5vh auto !important;
      }
      
      #modalEstadisticas h2 {
        font-size: 1.3rem !important;
      }
      
      #estadisticasContent > div:nth-child(2) {
        grid-template-columns: 1fr !important;
      }
      
      #estadisticasContent > div:nth-child(3) > div {
        grid-template-columns: 1fr !important;
      }
    }

    #modalEstadisticas::-webkit-scrollbar,
    #estadisticasContent::-webkit-scrollbar {
      width: 8px;
    }

    #modalEstadisticas::-webkit-scrollbar-track,
    #estadisticasContent::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }

    #modalEstadisticas::-webkit-scrollbar-thumb,
    #estadisticasContent::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }

    #modalEstadisticas::-webkit-scrollbar-thumb:hover,
    #estadisticasContent::-webkit-scrollbar-thumb:hover {
      background: var(--secondary);
    }

    /* Modal Cascada - Estilos */
    #modalCascada::-webkit-scrollbar,
    #cascadaContent::-webkit-scrollbar {
      width: 8px;
    }

    #modalCascada::-webkit-scrollbar-track,
    #cascadaContent::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }

    #modalCascada::-webkit-scrollbar-thumb,
    #cascadaContent::-webkit-scrollbar-thumb {
      background: #6366f1;
      border-radius: 4px;
    }

    #modalCascada::-webkit-scrollbar-thumb:hover,
    #cascadaContent::-webkit-scrollbar-thumb:hover {
      background: #8b5cf6;
    }

    @media (max-width: 768px) {
      #modalCascada > div {
        width: 95% !important;
        height: 95vh !important;
        margin: 2.5vh auto !important;
      }
      
      #modalCascada h3 {
        font-size: 1rem !important;
      }
    }

    .lightbox-counter {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: 700;
      z-index: 3001;
    }

    /* TOAST NOTIFICATIONS */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(59, 130, 246, 0.3);
      border: 1px solid var(--border-color);
      animation: slideInLeft 0.3s ease;
      z-index: 4000;
      font-weight: 600;
      border-left: 4px solid var(--primary);
      max-width: 400px;
      min-width: 250px;
      word-wrap: break-word;
      transition: all 0.3s ease;
    }

    .toast {
      background: #1e293b;
      color: #f8fafc;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      border: 1px solid #334155;
    }

    @keyframes slideInLeft {
      from {
        transform: translateX(-400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateX(0);
      }
      to {
        opacity: 0;
        transform: translateX(-100px);
      }
    }

    .toast.fade-out {
      animation: fadeOut 0.3s ease forwards;
    }

    /* STATS */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stats-card {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 24px;
      box-shadow: var(--card-shadow);
      text-align: center;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border-left: 4px solid var(--primary);
      position: relative;
      overflow: hidden;
    }

    .stats-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        transparent 0%, 
        rgba(59, 130, 246, 0.05) 100%);
      opacity: 0;
      transition: opacity 0.4s;
    }

    .stats-card:hover::before {
      opacity: 1;
    }

    .stats-card:hover {
      transform: translateY(-6px) scale(1.02);
      box-shadow: var(--card-shadow-hover), 0 0 25px rgba(59, 130, 246, 0.3);
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 8px;
      text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
      position: relative;
      z-index: 1;
    }

    .stat-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
      z-index: 1;
    }

    /* JERARQUÍA */
    .tree-container {
      background: var(--bg-secondary);
      padding: 24px;
      border-radius: 12px;
      box-shadow: var(--card-shadow);
      border: 1px solid var(--border-color);
    }

    .tree-header {
      padding: 16px;
      background: linear-gradient(135deg, var(--primary) 0%, #3b82f6 100%);
      color: white;
      border-radius: 12px;
      margin-bottom: 20px;
      font-weight: 700;
      font-size: 1.1rem;
    }

    .tree-node {
      margin: 8px 0;
      transition: all 0.3s;
    }

    .tree-item {
      padding: 10px 12px;
      background: #3b4558;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 400;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      margin-bottom: 4px;
    }

    .tree-item:hover {
      background: #445062;
      transform: none;
    }

    .tree-toggle {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      border-radius: 4px;
      font-weight: 700;
      transition: transform 0.3s;
    }

    .tree-toggle.expanded {
      transform: rotate(90deg);
      background: var(--primary);
      color: white;
    }

    .tree-children {
      margin-left: 24px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .tree-children.expanded {
      max-height: 5000px;
    }

    .tree-area .tree-item {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(96, 165, 250, 0.15) 100%);
      color: #60a5fa;
      font-size: 1.05rem;
      border-left: 4px solid var(--primary);
    }

    .tree-equipo .tree-item {
      background: var(--bg-primary);
      color: var(--text-secondary);
      border-left: 3px solid var(--border-color);
    }

    .tree-repuesto .tree-item {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      font-weight: 500;
    }

    /* MAPA */
    .map-container {
      background: var(--bg-secondary);
      padding: 24px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      box-shadow: var(--card-shadow);
    }

    .map-controls {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tool-btn {
      padding: 10px 16px;
      border: 2px solid var(--border-color);
      background: var(--bg-primary);
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
      min-height: 48px;
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    #mapCanvas {
      width: 100%;
      height: 100%;
      border: 3px solid var(--border-color);
      border-radius: 16px;
      background: var(--bg-primary);
      cursor: crosshair;
    }

    /* CONTEO */
    .conteo-controls {
      background: var(--bg-secondary);
      padding: 24px;
      border-radius: 12px;
      box-shadow: var(--card-shadow);
      border: 1px solid var(--border-color);
      margin-bottom: 20px;
    }

    .conteo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 16px;
    }

    .conteo-progress {
      width: 100%;
      height: 8px;
      background: var(--gray-200);
      border-radius: 4px;
      overflow: hidden;
      margin: 16px 0;
    }

    .conteo-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--success) 0%, #34d399 100%);
      transition: width 0.3s;
      border-radius: 4px;
    }

    .conteo-item {
      padding: 16px;
      background: var(--bg-primary);
      border-radius: 8px;
      margin-bottom: 12px;
      border: 2px solid var(--border-color);
      transition: all 0.3s;
    }

    .conteo-item:hover {
      border-color: var(--primary);
      background: var(--bg-secondary);
      box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
    }

    .conteo-input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--gray-300);
      border-radius: 8px;
      font-size: 1.2rem;
      text-align: center;
      font-weight: 700;
      margin-top: 12px;
    }

    /* RESPONSIVE */
    /* Optimización para pantallas grandes */
    @media (min-width: 1400px) {
      .container {
        padding: 30px 40px;
      }
    }

    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        align-items: stretch;
        gap: 16px;
      }

      .header-actions {
        justify-content: center;
        flex-wrap: wrap;
      }

      .logo h1 {
        font-size: 1.5rem;
      }

      .logo p {
        font-size: 0.8rem;
      }

      .cards-grid {
        grid-template-columns: 1fr;
        gap: 16px;
        padding: 16px;
      }

      .repuesto-card {
        max-width: 100%;
      }

      .card-image {
        height: 220px;
      }

      .stock-badge-new {
        min-width: 120px !important;
        padding: 6px 10px !important;
        font-size: 0.7rem !important;
      }

      .form-row {
        grid-template-columns: 1fr;
      }

      .list-header,
      .list-row {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .list-header {
        grid-template-columns: 1fr;
        font-size: 0.8rem;
        padding: 12px;
      }
      
      .list-header-cell {
        padding: 8px;
        justify-content: center;
      }
      
      .list-header-cell:not(:first-child) {
        display: none;
      }

      .list-row {
        grid-template-columns: 1fr;
        padding: 16px 12px;
        gap: 12px;
      }
      
      .list-row > div {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      
      .list-row > div::before {
        content: attr(data-label);
        font-weight: 700;
        color: var(--text-secondary);
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .list-actions {
        display: grid !important;
        grid-template-columns: repeat(3, 1fr) !important;
        gap: 8px !important;
        width: 100% !important;
      }
      
      .list-actions::before {
        display: none;
      }
      
      .list-actions button {
        font-size: 0.75rem !important;
        padding: 10px 8px !important;
      }
      
      .stock-visual {
        padding: 8px;
        background: var(--bg-primary);
        border-radius: 6px;
      }

      .toolbar {
        flex-direction: column;
        gap: 12px;
      }

      .search-box {
        width: 100%;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }

      #pagination {
        flex-wrap: wrap;
        padding: 12px;
        gap: 8px;
        justify-content: center;
      }

      #pagination > div {
        flex-basis: 100%;
        justify-content: center;
        margin-bottom: 8px;
      }

      #itemsPerPageSelect {
        font-size: 0.85rem;
        padding: 6px 10px;
      }

      #pagination .btn {
        min-width: 70px;
        font-size: 0.8rem;
        padding: 8px 12px;
      }

      #pageNumbers .btn {
        min-width: 36px;
        padding: 8px;
        font-size: 0.85rem;
      }

      .nav-tab {
        font-size: 0.85rem;
        padding: 16px 12px;
      }

      .btn {
        min-height: 44px; /* iOS touch target mínimo */
        font-size: 0.9rem;
      }

      .fs-button {
        bottom: 20px;
        right: 20px;
        min-width: 150px;
        padding: 12px 20px;
        font-size: 0.85rem;
      }

      /* Lightbox en móvil */
      .lightbox-close {
        width: 44px;
        height: 44px;
        font-size: 24px;
        top: 10px;
        right: 10px;
      }

      .lightbox-nav {
        width: 50px;
        height: 50px;
        font-size: 28px;
      }

      .lightbox-counter {
        font-size: 0.9rem;
        padding: 8px 16px;
      }

      /* Modal en móvil */
      .modal-content {
        width: 95%;
        max-height: 90vh;
        padding: 20px;
      }
      
      /* Formulario en móvil: 1 columna */
      .form-row,
      .form-row-triple,
      .form-row-quad {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .multimedia-preview {
        max-height: 150px;
      }
    }

    /* ================================================================== */
    /* OPTIMIZACIÓN ESPECÍFICA PARA IPHONE 16 PRO (393x852px) Y SIMILARES */
    /* Pantallas pequeñas: max-width 430px (iPhone 16 Pro, 15 Pro, 14 Pro, etc.) */
    /* ================================================================== */
    @media (max-width: 430px) {
      /* Reducir padding global */
      .container {
        padding: 10px 6px !important;
      }

      /* Optimizar header */
      .logo h1 {
        font-size: 1.25rem !important;
        margin-bottom: 2px !important;
      }

      .logo p {
        font-size: 0.7rem !important;
      }

      /* Botones del header más compactos */
      .header-actions {
        gap: 6px !important;
      }

      .header-actions button,
      .header-actions .btn {
        padding: 8px 10px !important;
        font-size: 0.75rem !important;
        min-width: auto !important;
        min-height: 38px !important;
      }

      /* Cards ultra optimizadas */
      .cards-grid {
        grid-template-columns: 1fr !important;
        gap: 10px !important;
        padding: 6px !important;
      }

      .repuesto-card {
        border-radius: 10px !important;
        box-shadow: var(--shadow-md) !important;
      }

      .card-content {
        padding: 8px !important;
      }

      .card-content h3 {
        font-size: 0.9rem !important;
        line-height: 1.25 !important;
        margin-bottom: 4px !important;
      }

      .card-content h4 {
        font-size: 0.75rem !important;
        margin: 3px 0 !important;
      }

      .card-info {
        font-size: 0.7rem !important;
        gap: 4px !important;
        margin-top: 4px !important;
      }

      .card-image {
        height: 180px !important;
      }

      /* Badges más compactos */
      .stock-badge-new {
        min-width: 90px !important;
        padding: 4px 6px !important;
        font-size: 0.6rem !important;
      }

      /* Botones de acción más pequeños */
      .card-actions {
        gap: 4px !important;
        padding: 6px !important;
      }

      .card-actions button {
        padding: 7px 8px !important;
        font-size: 0.7rem !important;
        min-height: 36px !important;
      }

      /* Filtros compactos */
      .filtros-grupo {
        grid-template-columns: 1fr !important;
        gap: 6px !important;
        padding: 8px !important;
      }

      .filtros-grupo select,
      .filtros-grupo input {
        padding: 7px !important;
        font-size: 0.8rem !important;
      }

      /* Modal optimizado para pantalla pequeña */
      #modalRepuesto > div {
        width: 98% !important;
        max-width: 98% !important;
        margin: 1% auto !important;
        padding: 12px !important;
        border-radius: 12px !important;
      }

      #modalRepuesto h2 {
        font-size: 1.1rem !important;
        margin-bottom: 12px !important;
      }

      #modalRepuesto .form-group {
        margin-bottom: 10px !important;
      }

      #modalRepuesto .form-group label {
        font-size: 0.8rem !important;
        margin-bottom: 4px !important;
      }

      #modalRepuesto input,
      #modalRepuesto select,
      #modalRepuesto textarea {
        padding: 8px !important;
        font-size: 0.85rem !important;
      }

      #modalRepuesto textarea {
        min-height: 60px !important;
      }

      /* Botones del modal */
      #modalRepuesto button {
        padding: 9px 14px !important;
        font-size: 0.8rem !important;
        min-height: 38px !important;
      }

      /* Lightbox optimizado */
      .lightbox-image {
        max-width: 95vw !important;
        max-height: 65vh !important;
      }

      .lightbox-prev,
      .lightbox-next {
        width: 38px !important;
        height: 38px !important;
        font-size: 1.1rem !important;
      }

      .lightbox-close {
        width: 34px !important;
        height: 34px !important;
        font-size: 1.4rem !important;
        top: 8px !important;
        right: 8px !important;
      }

      .lightbox-counter {
        bottom: 15px !important;
        padding: 6px 12px !important;
        font-size: 0.8rem !important;
      }

      /* Toast más compacto */
      .toast {
        bottom: 8px !important;
        left: 8px !important;
        right: 8px !important;
        padding: 10px 12px !important;
        font-size: 0.8rem !important;
      }

      /* Preview de imágenes más pequeño */
      .multimedia-preview {
        max-height: 120px !important;
      }

      .multimedia-preview img {
        max-width: 70px !important;
        max-height: 70px !important;
      }

      /* Botones de foto móvil optimizados */
      #mobile-photo-buttons {
        margin-bottom: 10px !important;
      }

      #mobile-photo-buttons button {
        padding: 9px !important;
        font-size: 0.8rem !important;
        gap: 4px !important;
      }

      /* Toolbar compacto */
      .toolbar {
        padding: 8px !important;
        gap: 8px !important;
      }

      .search-box input {
        padding: 8px !important;
        font-size: 0.85rem !important;
      }

      /* Paginación más compacta */
      #pagination {
        padding: 8px !important;
        gap: 6px !important;
      }

      #pagination .btn {
        min-width: 60px !important;
        font-size: 0.75rem !important;
        padding: 6px 10px !important;
        min-height: 36px !important;
      }

      #pageNumbers .btn {
        min-width: 32px !important;
        padding: 6px !important;
        font-size: 0.8rem !important;
      }

      /* Tabs más compactas */
      .nav-tab {
        font-size: 0.8rem !important;
        padding: 12px 8px !important;
      }

      /* Stats grid en 1 columna */
      .stats-grid {
        grid-template-columns: 1fr !important;
        gap: 8px !important;
      }

      /* Botón flotante más pequeño */
      .fs-button {
        bottom: 15px !important;
        right: 15px !important;
        min-width: 130px !important;
        padding: 10px 16px !important;
        font-size: 0.8rem !important;
      }
    }

    /* Tabletas y pantallas medianas (769px - 1024px) */
    @media (min-width: 769px) and (max-width: 1024px) {
      .form-row-triple {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .form-row-quad {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    /* Pantallas grandes (> 1400px) - Aprovechar espacio */
    @media (min-width: 1400px) {
      .multimedia-preview {
        max-height: 200px;
      }
    }
    
    /* Pantallas ultra anchas (> 1920px) */
    @media (min-width: 1920px) {
    }

    /* iPhone y pantallas pequeñas (< 480px) */
    @media (max-width: 480px) {
      .modal-content {
        min-width: calc(100vw - 20px);
        width: calc(100vw - 20px);
      }
      
      .header {
        padding: 12px;
      }

      .logo h1 {
        font-size: 1.3rem;
      }

      .cards-grid {
        padding: 12px;
        gap: 12px;
      }

      .card-footer {
        flex-wrap: wrap;
        gap: 8px;
      }

      .card-btn {
        flex: 1 1 100%;
        min-width: 100%;
      }

      #pagination .btn {
        min-width: 60px;
        padding: 6px 10px;
        font-size: 0.75rem;
      }

      #pageNumbers .btn {
        min-width: 32px;
        padding: 6px;
      }

      .nav-tab {
        font-size: 0.75rem;
        padding: 14px 8px;
        letter-spacing: 0;
      }
      
      .modal-title {
        font-size: 1.3rem;
      }
      
      .form-control {
        padding: 10px 12px;
        font-size: 0.95rem;
      }

      /* 📱 OCULTAR ELEMENTOS INNECESARIOS EN MÓVIL */
      .pc-only-config,
      #icloud-config-section,
      .view-btns {
        display: none !important;
      }

      /* Optimizar toolbar móvil */
      .toolbar {
        flex-direction: column;
        gap: 10px;
      }

      .search-box {
        width: 100%;
      }

      /* Lista móvil optimizada */
      .list-view {
        padding: 12px;
      }

      /* Ocultar paginación en móvil (vista completa sin paginar) */
      #pagination {
        display: none !important;
      }
    }

    /* UTILIDADES */
    .hidden {
      display: none !important;
    }

    .text-center {
      text-align: center;
    }

    .mt-2 {
      margin-top: 20px;
    }

    .mb-2 {
      margin-bottom: 20px;
    }

    .precio-info {
      transition: opacity 0.3s;
    }

    .precio-info.hidden {
      display: none;
    }

    /* CONTENEDOR FIJO SUPERIOR */
    .sticky-header-container {
      position: sticky;
      top: 0;
      z-index: 1000;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-md);
    }

    /* INDICADOR DE CONEXIÓN SUTIL - PEQUEÑO */
    .connection-indicator {
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-color);
      padding: 4px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .connection-icon {
      font-size: 0.9rem;
    }

    .connection-text {
      font-weight: 500;
    }

    .connection-indicator.connected {
      border-bottom-color: rgba(16, 185, 129, 0.3);
    }

    .connection-indicator.connected .connection-icon {
      filter: hue-rotate(100deg);
    }

    .connection-indicator.connected .connection-text {
      color: #10b981;
    }

    .connection-indicator.disconnected {
      border-bottom-color: rgba(239, 68, 68, 0.3);
    }

    .connection-indicator.disconnected .connection-icon {
      animation: pulse 2s infinite;
    }

    .connection-indicator.disconnected .connection-text {
      color: #ef4444;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    /* ANIMACIONES Y EFECTOS ADICIONALES - MODO OSCURO */
    
    /* Efecto de pulsación para badges */
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.05);
      }
    }

    .badge-cero {
      animation: pulse 2s infinite;
    }

    /* Efecto de gradiente animado para elementos premium */
    @keyframes gradientFlow {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    .header {
      background: linear-gradient(135deg, 
        #1e293b 0%, 
        #0f172a 25%, 
        #1e293b 50%, 
        #0f172a 75%, 
        #1e293b 100%);
      background-size: 200% 200%;
      animation: gradientFlow 15s ease infinite;
    }

    /* Resplandor suave en hover para interactivos */
    .nav-tab:hover,
    .btn:hover,
    .repuesto-card:hover {
      filter: brightness(1.1);
    }

    /* Transición suave para todos los elementos */
    * {
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Efecto de reveal para cards */
    @keyframes cardReveal {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .repuesto-card {
      animation: cardReveal 0.4s ease forwards;
    }

    .repuesto-card:nth-child(1) { animation-delay: 0.05s; }
    .repuesto-card:nth-child(2) { animation-delay: 0.1s; }
    .repuesto-card:nth-child(3) { animation-delay: 0.15s; }
    .repuesto-card:nth-child(4) { animation-delay: 0.2s; }
    .repuesto-card:nth-child(5) { animation-delay: 0.25s; }
    .repuesto-card:nth-child(6) { animation-delay: 0.3s; }

    /* Efecto de brillo en imágenes al hover */
    .card-image img {
      transition: all 0.4s ease;
    }

    .card-image:hover img {
      transform: scale(1.05);
      filter: brightness(1.1) contrast(1.05);
    }

    /* Scrollbar con gradiente */
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #334155, #475569);
      border-radius: 6px;
      border: 2px solid #0f172a;
      box-shadow: inset 0 0 6px rgba(59, 130, 246, 0.3);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #475569, #64748b);
      box-shadow: inset 0 0 10px rgba(59, 130, 246, 0.5);
    }

    /* Loading spinner mejorado */
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(59, 130, 246, 0.2);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      filter: drop-shadow(0 0 6px var(--primary));
    }

    /* Spinner pequeño para botones */
    .spinner-small {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      vertical-align: middle;
      margin-right: 6px;
    }

    /* Efecto neón en títulos */
    h1, h2 {
      text-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
    }

    /* Badge mejorado con efecto glow */
    .card-badge {
      box-shadow: 0 0 15px currentColor;
      border: 2px solid currentColor;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
    }

    /* Info cards con hover mejorado */
    .info-row:hover {
      background: rgba(59, 130, 246, 0.05);
      border-radius: 8px;
      padding: 8px;
      margin: -8px;
      transition: all 0.3s;
    }

    /* Botones con ripple effect */
    @keyframes ripple {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }

    .btn.ripple::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      animation: ripple 0.6s;
    }

    /* Mejora visual para select y textarea */
    select.form-control,
    textarea.form-control {
      background-image: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
    }

    /* Efecto de enfoque en navegación activa */
    .nav-tab.active {
      animation: tabActivate 0.3s ease;
    }

    @keyframes tabActivate {
      0% {
        transform: scale(0.95);
      }
      50% {
        transform: scale(1.02);
      }
      100% {
        transform: scale(1);
      }
    }

    /* Efecto de partículas en el fondo (sutil) */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(99, 102, 241, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 40% 20%, rgba(59, 130, 246, 0.02) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    /* Mejora de contraste para accesibilidad */
    .btn:focus-visible,
    .form-control:focus-visible,
    .nav-tab:focus-visible {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
    }

    /* Estilos para el modal de conteo individual */
    .modal-backdrop-custom {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease;
    }

    .modal-dialog-custom {
      animation: slideUpModal 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .modal-content-custom {
      background: #1e293b;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      overflow: hidden;
      border: 1px solid #334155;
    }

    .modal-header-custom {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 20px 25px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header-custom h3 {
      margin: 0;
      font-size: 1.3em;
      font-weight: 600;
    }

    .modal-header-custom .close-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 28px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      line-height: 1;
    }

    .modal-header-custom .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(90deg);
    }

    .modal-body-custom {
      padding: 25px;
    }

    .modal-footer-custom {
      padding: 20px 25px;
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes slideUpModal {
      from {
        transform: translateY(50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    /* Estilos responsive para el modal de conteo */
    @media (max-width: 600px) {
      .modal-dialog-custom {
        margin: 10px;
        max-width: calc(100% - 20px) !important;
      }

      .modal-body-custom {
        padding: 20px 15px;
      }

      .modal-footer-custom {
        padding: 15px;
      }
    }

    /* ======================================== */
    /* OKR VISUAL MANAGER */
    /* ======================================== */
    .okr-wrapper {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 6px 0 32px;
    }

    .okr-hero {
      display: flex;
      gap: 24px;
      align-items: stretch;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 18px;
      padding: 28px;
      box-shadow: var(--shadow-md);
      flex-wrap: wrap;
    }

    .okr-hero-text {
      flex: 1 1 320px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .okr-hero-text h2 {
      font-size: 1.9rem;
      line-height: 1.3;
      color: var(--primary-light);
    }

    .okr-hero-text p {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .okr-hero-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .okr-upload-btn {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
      color: #fff;
      border-radius: 12px;
      padding: 12px 22px;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: var(--shadow-md);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .okr-upload-btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    .okr-upload-btn input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .okr-secondary-btn {
      background: rgba(91, 124, 153, 0.12);
      color: var(--primary-light);
      border: 1px solid rgba(91, 124, 153, 0.35);
      border-radius: 10px;
      padding: 12px 18px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .okr-secondary-btn:hover {
      background: rgba(91, 124, 153, 0.2);
      color: var(--text-primary);
    }

    .okr-hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .okr-dropzone {
      flex: 0 1 280px;
      border: 2px dashed rgba(122, 154, 184, 0.5);
      border-radius: 16px;
      background: rgba(45, 55, 72, 0.55);
      color: var(--text-secondary);
      display: grid;
      place-items: center;
      padding: 24px;
      text-align: center;
      gap: 8px;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
    }

    .okr-dropzone:hover {
      border-color: var(--primary-light);
      background: rgba(74, 98, 120, 0.6);
      transform: translateY(-2px);
    }

    .okr-dropzone.is-dragover {
      border-color: var(--success);
      background: rgba(107, 142, 127, 0.25);
      color: var(--text-primary);
    }

    .okr-dropzone-icon {
      font-size: 2.4rem;
      line-height: 1;
    }

    .okr-summary {
      display: none;
    }

    .okr-summary.is-visible {
      display: block;
    }

    .okr-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .okr-summary-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 20px;
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .okr-summary-label {
      color: var(--text-muted);
      font-size: 0.85rem;
      letter-spacing: 0.02em;
    }

    .okr-summary-value {
      font-size: 1.9rem;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.01em;
    }

    .okr-summary-sub {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .okr-filters {
      display: none;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 18px;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      box-shadow: var(--shadow-sm);
    }

    .okr-filters.is-active {
      display: grid;
    }

    .okr-filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .okr-filter-group label {
      font-size: 0.78rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .okr-filter-group select,
    .okr-filter-group input[type="search"] {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px 12px;
      color: var(--text-primary);
      font-size: 0.9rem;
    }

    .okr-filter-group select:focus,
    .okr-filter-group input[type="search"]:focus {
      outline: none;
      border-color: var(--primary-light);
      box-shadow: 0 0 0 2px rgba(91, 124, 153, 0.2);
    }

    .okr-filter-actions {
      align-items: flex-end;
      justify-content: flex-end;
    }

    .okr-layout {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
    }

    .okr-objectives-column {
      flex: 1 1 55%;
      min-width: 280px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .okr-objectives-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .okr-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 18px;
      padding: 20px;
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      gap: 16px;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .okr-card::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(91, 124, 153, 0.22), transparent 55%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .okr-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-md);
    }

    .okr-card:hover::after {
      opacity: 1;
    }

    .okr-card-header {
      display: flex;
      gap: 16px;
      align-items: center;
    }

    .okr-card-title h3 {
      font-size: 1.15rem;
      color: var(--text-primary);
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .okr-card-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.8rem;
    }

    .okr-progress-ring {
      width: 68px;
      height: 68px;
      border-radius: 50%;
      background: conic-gradient(var(--progress-color, var(--primary-light)) calc(var(--progress, 0) * 1deg), rgba(255, 255, 255, 0.08) 0deg);
      display: grid;
      place-items: center;
      font-weight: 700;
      color: var(--text-primary);
      position: relative;
    }

    .okr-progress-ring::before {
      content: '';
      position: absolute;
      inset: 8px;
      background: var(--bg-secondary);
      border-radius: 50%;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.07);
    }

    .okr-progress-ring span {
      position: relative;
      font-size: 1rem;
      letter-spacing: 0.03em;
    }

    .okr-card-body {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .okr-card-notes {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .okr-metadata-line {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .okr-meta-item {
      background: rgba(91, 124, 153, 0.18);
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(91, 124, 153, 0.25);
    }

    .okr-kr-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .okr-kr-card {
      background: var(--bg-primary);
      border: 1px solid rgba(91, 124, 153, 0.25);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .okr-kr-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .okr-kr-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    .okr-kr-progress {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .okr-kr-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .okr-kr-footer {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .okr-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      background: rgba(91, 124, 153, 0.18);
      color: var(--text-secondary);
      border: 1px solid rgba(91, 124, 153, 0.25);
    }

    .okr-chip.muted {
      background: rgba(45, 55, 72, 0.6);
      color: var(--text-secondary);
      border-color: rgba(148, 163, 184, 0.18);
    }

    .okr-chip.tag {
      background: rgba(91, 124, 153, 0.12);
      color: var(--primary-light);
    }

    .okr-chip.mini {
      padding: 3px 8px;
      font-size: 0.7rem;
    }

    .okr-chip.status-on_track,
    .okr-chip.status.status-on_track {
      background: rgba(107, 142, 127, 0.2);
      border-color: rgba(107, 142, 127, 0.4);
      color: var(--success);
    }

    .okr-chip.status-at_risk,
    .okr-chip.status.status-at_risk {
      background: rgba(212, 151, 108, 0.18);
      border-color: rgba(212, 151, 108, 0.35);
      color: var(--warning);
    }

    .okr-chip.status-off_track,
    .okr-chip.status.status-off_track {
      background: rgba(199, 107, 107, 0.18);
      border-color: rgba(199, 107, 107, 0.35);
      color: var(--danger);
    }

    .okr-chip.status-completed,
    .okr-chip.status.status-completed {
      background: rgba(91, 124, 153, 0.2);
      border-color: rgba(91, 124, 153, 0.4);
      color: var(--primary-light);
    }

    .okr-chip.status-not_started,
    .okr-chip.status.status-not_started {
      background: rgba(113, 128, 150, 0.18);
      border-color: rgba(113, 128, 150, 0.3);
      color: var(--text-secondary);
    }

    .okr-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .okr-insights-column {
      flex: 1 1 300px;
      min-width: 260px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .okr-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      box-shadow: var(--shadow-sm);
      overflow: hidden;
    }

    .okr-panel-header {
      padding: 16px 20px;
      font-weight: 600;
      letter-spacing: 0.03em;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      background: rgba(74, 98, 120, 0.35);
    }

    .okr-panel-body {
      padding: 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .okr-kr-row,
    .okr-initiative-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 12px;
      border-radius: 12px;
      background: var(--bg-primary);
      border: 1px solid rgba(91, 124, 153, 0.25);
    }

    .okr-row-top {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .okr-row-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.88rem;
      line-height: 1.4;
    }

    .okr-row-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.76rem;
      color: var(--text-secondary);
    }

    .okr-empty,
    .okr-empty-panel {
      text-align: center;
      padding: 40px 24px;
      border-radius: 16px;
      border: 1px dashed rgba(91, 124, 153, 0.3);
      background: rgba(45, 55, 72, 0.6);
      color: var(--text-secondary);
      display: grid;
      gap: 12px;
    }

    .okr-empty h3 {
      font-size: 1.2rem;
      color: var(--primary-light);
    }

    .okr-empty ul {
      list-style: disc;
      margin: 0 auto;
      padding: 0 20px;
      text-align: left;
      font-size: 0.85rem;
      color: var(--text-secondary);
      display: grid;
      gap: 4px;
    }

    .okr-hidden {
      display: none !important;
    }

    @media (max-width: 1024px) {
      .okr-layout {
        flex-direction: column;
      }

      .okr-objectives-column,
      .okr-insights-column {
        flex: 1 1 100%;
      }
    }

    @media (max-width: 720px) {
      .okr-hero {
        padding: 22px;
      }

      .okr-hero-text h2 {
        font-size: 1.6rem;
      }

      .okr-summary-grid {
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }

      .okr-objectives-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ═══════════════════════════════════════════════════════════════════════════════
       🗺️ ESTILOS DEL SISTEMA DE MAPAS AVANZADO - INTEGRADOS DESDE APP_BASE (FASE 2)
       ═══════════════════════════════════════════════════════════════════════════════ */
    
    /* MAPA - SECCION INTEGRADA */
    .map-shell {
      display: grid;
      grid-template-columns: 450px minmax(0, 1fr); /* 🔧 Panel izquierdo: 450px (aumentado para botones completos) */
      gap: 12px;
      align-items: stretch;
      width: 100%;
      height: 100%;
      max-height: 100%;
      padding: 2px;
      box-sizing: border-box;
      margin: 0;
    }

    .map-panel {
      background: var(--bg-secondary);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-md);
      min-height: 500px;
      height: 100%; /* 🔧 NUEVO: Tomar altura completa del grid */
      overflow: hidden;
      margin: 0; /* 🔧 NUEVO: Sin márgenes para aprovechar espacio */
    }

    .map-panel-header {
      padding: 6px 10px;
      border-bottom: 1px solid var(--border-color-light);
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(139, 92, 246, 0.12));
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 5px;
      flex-shrink: 0;
    }

    .map-panel-header h2 {
      font-size: 0.9rem;
      margin: 0;
      color: var(--text-primary);
      font-weight: 700;
      line-height: 1.2;
    }

    .map-panel-header p {
      font-size: 0.6rem;
      color: var(--text-secondary);
      margin-top: 1px;
      line-height: 1.2;
    }

    .map-connection {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-end;
    }

    .map-status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-secondary);
    }

    .map-status-badge--off {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(239, 68, 68, 0.4);
      color: rgba(239, 68, 68, 0.9);
    }

    .map-status-badge--on {
      background: rgba(16, 185, 129, 0.12);
      border-color: rgba(16, 185, 129, 0.4);
      color: rgba(16, 185, 129, 0.9);
    }

    .map-panel-scroll {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 6px 8px;
      display: grid;
      gap: 6px;
      min-height: 0;
    }

    .map-section {
      background: var(--bg-primary);
      border-radius: 6px;
      padding: 5px 6px;
      box-shadow: var(--shadow-sm);
    }

    .map-section-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      -webkit-user-select: none;
      user-select: none;
      padding: 0;
      min-height: 28px;
    }

    .map-section-header:hover h3 {
      color: var(--primary-color);
    }

    .map-section-header h3 {
      margin: 0;
      font-size: 0.7rem;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: color 0.2s ease;
      line-height: 1.2;
    }

    .map-section-collapse-icon {
      font-size: 0.7rem;
      color: var(--text-secondary);
      transition: transform 0.2s ease;
    }

    .map-section--collapsed .map-section-collapse-icon {
      transform: rotate(-90deg);
    }

    .map-section--collapsed .map-card-list {
      display: none;
    }

    .map-card-list {
      display: grid;
      gap: 5px;
      padding: 0;
    }

    .map-card {
      border-radius: 5px;
      padding: 5px 6px;
      background: rgba(15, 23, 42, 0.7);
      cursor: pointer;
      display: grid;
      gap: 2px;
      transition: transform 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
    }

    .map-card:hover {
      transform: translateY(-2px);
      border-color: rgba(59, 130, 246, 0.6);
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.45);
    }

    .map-card--active {
      border-color: rgba(59, 130, 246, 0.8);
      box-shadow: 0 10px 24px rgba(59, 130, 246, 0.25);
    }

    .map-card-title {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 0.75rem; /* 🔧 Reducido de 0.8rem a 0.75rem */
      line-height: 1.2;
    }

    .map-card-meta {
      font-size: 0.6rem; /* 🔧 Reducido de 0.65rem a 0.6rem */
      color: var(--text-secondary);
      line-height: 1.2;
    }

    /* 🔧 NUEVO: Contenedor y botones de acciones en tarjetas */
    .map-card-content {
      display: grid;
      gap: 2px; /* 🔧 Reducido de 3px a 2px */
      cursor: pointer;
    }

    .map-card-actions {
      display: flex;
      gap: 3px; /* 🔧 Reducido de 4px a 3px */
      margin-top: 3px; /* 🔧 Reducido de 4px a 3px */
      padding-top: 3px; /* 🔧 Reducido de 4px a 3px */
      border-top: 1px solid rgba(148, 163, 184, 0.15);
      justify-content: flex-end;
    }

    .map-card-btn {
      background: rgba(59, 130, 246, 0.15);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 3px; /* 🔧 Reducido de 4px a 3px */
      padding: 2px 5px; /* 🔧 Reducido de 3px 7px a 2px 5px */
      font-size: 0.7rem; /* 🔧 Reducido de 0.75rem a 0.7rem */
      cursor: pointer;
      transition: all 0.2s ease;
      color: #94a3b8;
      line-height: 1.2;
    }

    .map-card-btn:hover {
      background: rgba(59, 130, 246, 0.3);
      border-color: rgba(59, 130, 246, 0.6);
      transform: translateY(-1px);
    }

    .map-card-btn--edit:hover {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.5);
    }

    .map-card-btn--delete:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.5);
    }

    .map-area-list {
      display: grid;
      gap: 6px;
      max-height: calc(100vh - 280px);
      overflow-y: auto;
      padding: 0;
    }

    .map-area-item {
      border-radius: 4px;
      padding: 10px 12px;
      background: #3b4558;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      transition: background 0.15s ease;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    .map-area-item:hover {
      background: #445062;
    }

    .map-area-item--active {
      background: #4a5568;
    }

    .map-area-content {
      display: flex;
      flex-direction: column;
      gap: 0;
      flex: 1;
      min-width: 0;
    }

    .map-area-title {
      font-weight: 400;
      color: #e2e8f0;
      font-size: 0.8125rem;
      line-height: 1.5;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-area-subtitle {
      font-size: 0.75rem;
      color: #94a3b8;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-area-actions {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
    }
    
    .map-area-action-btn {
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #4a5568;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: background 0.15s ease;
      font-size: 0.75rem;
      padding: 0;
    }
    
    .map-area-action-btn:hover {
      background: #556277;
    }
    
    .map-area-action-btn--edit {
      color: #fbbf24;
    }
    
    .map-area-action-btn--config {
      color: #cbd5e1;
    }
    
    .map-area-action-btn--delete {
      color: #cbd5e1;
    }

    .map-log-list {
      font-family: "JetBrains Mono", "Courier New", monospace;
      font-size: 0.7rem;
      display: grid;
      gap: 6px;
      max-height: 160px;
      overflow-y: auto;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px;
      padding: 12px;
    }

    .map-log-entry {
      color: rgba(148, 163, 184, 0.9);
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .map-log-entry time {
      color: rgba(59, 130, 246, 0.8);
    }

    .map-btn {
      border: none;
      border-radius: 5px; /* 🔧 Reducido de 6px a 5px */
      padding: 5px 8px; /* 🔧 Reducido de 6px 10px a 5px 8px */
      font-size: 0.65rem; /* 🔧 Reducido de 0.7rem a 0.65rem */
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 3px; /* 🔧 Reducido de 4px a 3px */
      color: #e2e8f0;
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.3);
      white-space: nowrap;
      min-height: 24px; /* 🔧 Reducido de 28px a 24px */
      line-height: 1.2;
    }

    .map-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      background: rgba(37, 50, 73, 0.9);
      border-color: rgba(148, 163, 184, 0.5);
    }

    .map-btn:active {
      transform: translateY(0);
    }

    .map-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .map-btn--primary {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
      border: 1px solid rgba(59, 130, 246, 0.5);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
    }

    .map-btn--primary:hover {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
    }

    .map-btn--accent {
      background: linear-gradient(135deg, #14b8a6, #0d9488);
      color: white;
      border: 1px solid rgba(20, 184, 166, 0.5);
      box-shadow: 0 2px 8px rgba(20, 184, 166, 0.25);
    }

    .map-btn--accent:hover {
      background: linear-gradient(135deg, #0d9488, #0f766e);
      box-shadow: 0 4px 16px rgba(20, 184, 166, 0.4);
    }

    .map-btn--ghost {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #cbd5e1;
    }

    .map-btn--ghost:hover {
      background: rgba(51, 65, 85, 0.8);
      color: #e2e8f0;
    }

    .map-icon-btn {
      background: rgba(30, 41, 59, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: #e2e8f0;
      padding: 6px 10px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 36px;
      min-height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .map-icon-btn:hover {
      background: rgba(59, 130, 246, 0.25);
      border-color: rgba(59, 130, 246, 0.5);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .map-icon-btn:active {
      transform: translateY(0);
    }

    /* 🔧 Tooltips informativos para botones */
    .map-btn-info {
      position: relative;
    }

    .info-icon {
      font-size: 0.65rem;
      opacity: 0; /* 🔧 OCULTO por defecto */
      transition: opacity 0.2s ease;
      margin-left: -4px; /* 🔧 Reducir espacio */
    }

    .map-btn-info:hover .info-icon {
      opacity: 0.7; /* 🔧 Aparecer al hover */
    }

    .map-btn-info::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 8px); /* 🔧 CAMBIO: Tooltip ABAJO del botón */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.98);
      color: #e2e8f0;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 0.75rem;
      font-weight: 500;
      line-height: 1.5;
      white-space: normal;
      max-width: 280px;
      width: max-content;
      text-align: left;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.3);
      z-index: 100000;
    }

    .map-btn-info:hover::after {
      opacity: 1;
      transform: translateX(-50%) translateY(4px); /* 🔧 Hacia abajo */
    }

    .map-btn-info::before {
      content: '';
      position: absolute;
      top: calc(100% + 2px); /* 🔧 Flecha ARRIBA del tooltip */
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-bottom-color: rgba(15, 23, 42, 0.98); /* 🔧 Flecha apuntando hacia arriba */
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 100001;
    }

    .map-btn-info:hover::before {
      opacity: 1;
      transform: translateX(-50%) translateY(4px); /* 🔧 Hacia abajo */
    }

    /* Aplicar tooltips también a botones de icono */
    .map-icon-btn.map-btn-info {
      position: relative;
    }

    .map-icon-btn.map-btn-info::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.98);
      color: #e2e8f0;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 0.75rem;
      font-weight: 500;
      line-height: 1.5;
      white-space: normal;
      max-width: 280px;
      width: max-content;
      text-align: left;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.3);
      z-index: 100000;
    }

    .map-icon-btn.map-btn-info:hover::after {
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }

    .map-icon-btn.map-btn-info::before {
      content: '';
      position: absolute;
      bottom: calc(100% + 2px);
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(15, 23, 42, 0.98);
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 100001;
    }

    .map-icon-btn.map-btn-info:hover::before {
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }

    .map-workspace {
      background: rgba(15, 23, 42, 0.8);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: var(--shadow-lg);
      overflow: visible;
      width: 100%;
      height: 100%;
      min-height: 0;
      margin: 0;
      box-sizing: border-box;
    }

    .map-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px;
      padding: 8px 10px;
      overflow: visible;
      position: relative;
      flex-shrink: 0;
      z-index: 10;
    }

    .map-toolbar-left,
    .map-toolbar-right {
      display: flex;
      align-items: center;
      gap: 6px;
      overflow: visible;
    }

    .map-toolbar-center {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .map-zoom-badge,
    .map-meta-badge {
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.85);
      color: rgba(226, 232, 240, 0.9);
    }

    .map-canvas-stage {
      position: relative;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.7);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.4);
      flex: 1;
      width: 100%;
      min-height: 0;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      z-index: 1;
    }

    .map-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    .map-hint {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.85);
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .map-hint.hidden {
      opacity: 0;
    }

    /* 🎨 NUEVO: Tooltip para áreas en hover */
    .map-tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(59, 130, 246, 0.5);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.85rem;
      color: rgba(226, 232, 240, 0.95);
      pointer-events: none;
      transition: opacity 0.15s ease;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      max-width: 280px;
    }

    /* 🔧 NUEVO: Permitir clicks cuando el tooltip está fijado */
    .map-tooltip.pinned {
      pointer-events: auto;
      border-color: rgba(251, 191, 36, 0.6); /* Borde amarillo para indicar fijación */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    }

    .map-tooltip.hidden {
      opacity: 0;
      display: none;
    }

    .map-tooltip-title {
      font-weight: 600;
      font-size: 0.95rem;
      margin-bottom: 6px;
      color: #60a5fa;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .map-tooltip-category {
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.7);
      margin-bottom: 8px;
      padding: 3px 8px;
      background: rgba(59, 130, 246, 0.15);
      border-radius: 4px;
      display: inline-block;
    }

    .map-tooltip-equipos {
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.8);
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(148, 163, 184, 0.2);
    }

    .map-tooltip-equipos strong {
      display: block;
      margin-bottom: 4px;
      color: rgba(226, 232, 240, 0.9);
    }

    /* 🗺️ NUEVO: Minimap para navegación rápida */
    .map-minimap-container {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 200px;
      height: 140px;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid rgba(59, 130, 246, 0.4);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      transition: opacity 0.2s ease;
      z-index: 100;
    }

    .map-minimap-container.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .map-minimap-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: pointer;
    }

    .map-minimap-viewport {
      position: absolute;
      border: 2px solid rgba(251, 191, 36, 0.8);
      background: rgba(251, 191, 36, 0.15);
      pointer-events: none;
      box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
    }

    .map-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px; /* 🔧 Reducido de 16px a 12px */
      padding: 12px 16px; /* 🔧 Agregado padding para que sea más compacto */
      background: rgba(15, 23, 42, 0.5); /* 🔧 Fondo sutil */
      border-radius: 10px; /* 🔧 Bordes redondeados */
    }

    .map-status-text {
      font-size: 0.75rem; /* 🔧 Reducido de 0.8rem a 0.75rem */
      color: var(--text-secondary);
    }

    .map-footer-actions {
      display: flex;
      gap: 10px;
    }

    .map-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.82);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 9999;
    }

    .map-modal.hidden {
      display: none;
    }

    .map-modal-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      width: min(520px, 96vw);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-xl);
    }

    .map-modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .map-modal-header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .map-modal-body {
      padding: 20px 24px;
      overflow-y: auto;
      display: grid;
      gap: 16px;
    }

    @media (max-width: 1180px) {
      .map-shell {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .map-panel {
        order: 2;
      }

      .map-workspace {
        order: 1;
      }
    }

    /* 🔧 Media Query para pantallas medianas - Toolbar con wrap */
    @media (max-width: 900px) {
      .map-toolbar {
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 12px;
      }

      .map-toolbar-left,
      .map-toolbar-right {
        gap: 4px;
      }

      .btn-toolbar {
        padding: 8px 12px;
        font-size: 13px;
      }
    }

    @media (max-width: 720px) {
      .map-toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .map-toolbar-left,
      .map-toolbar-right {
        justify-content: center;
      }

      .map-panel-header {
        flex-direction: column;
        align-items: stretch;
      }

      .map-connection {
        align-items: flex-start;
      }
    }
    
    /* FIN ESTILOS DEL SISTEMA DE MAPAS */
    
    /* ═══════════════════════════════════════════════════════════════════════════════
       🎨 ESTILOS APLICADOS A CONFIGURACIÓN - MISMO DISEÑO LIMPIO
       ═══════════════════════════════════════════════════════════════════════════════ */
    
    .config-card {
      background: #3b4558 !important;
      padding: 16px !important;
      border-radius: 4px !important;
      border: none !important;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    }
    
    .config-card h3 {
      font-weight: 400 !important;
      font-size: 0.95rem !important;
      color: #e2e8f0 !important;
      margin-bottom: 12px !important;
    }
    
    /* 🆕 Estilos para Árbol Jerárquico */
    .tree-actions {
      display: none; /* No ocupar espacio cuando está oculto */
    }
    
    .tree-node-header:hover .tree-actions {
      display: flex !important;
      gap: 4px;
    }
    
    .tree-node-expandable:hover > .tree-node-header .tree-actions {
      display: flex !important;
      gap: 4px;
    }
    
    /* Hover para mostrar botones en nodos del árbol (INDIVIDUAL) */
    .tree-node-hover:hover > .tree-actions {
      display: flex !important;
      gap: 4px;
    }
    
    /* Evitar activación en cadena - solo el hover directo */
    .tree-node-hover .tree-actions {
      display: none;
    }
    
    .tree-toggle {
      font-size: 0.9rem;
      font-weight: 700;
    }
    
    .jerarquia-tree button {
      transition: all 0.2s ease;
    }
    
    .jerarquia-tree button:hover {
      transform: scale(1.05);
      filter: brightness(1.1);
    }
    
    /* 🆕 Estilos para Modales Personalizados Centrados */
    .custom-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .custom-modal {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 24px;
      min-width: 400px;
      max-width: 500px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from { 
        opacity: 0;
        transform: translateY(-20px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .custom-modal-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
    }
    
    .custom-modal-input {
      width: 100%;
      padding: 10px 12px;
      font-size: 0.95rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin-bottom: 20px;
      font-family: inherit;
    }
    
    .custom-modal-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .custom-modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .custom-modal-btn {
      padding: 8px 20px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .custom-modal-btn-primary {
      background: var(--primary);
      color: white;
    }
    
    .custom-modal-btn-primary:hover {
      background: #5558dd;
      transform: translateY(-1px);
    }
    
    .custom-modal-btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    
    .custom-modal-btn-secondary:hover {
      background: var(--border-color);
    }
    
    .custom-modal-message {
      color: var(--text-primary);
      font-size: 0.95rem;
      line-height: 1.5;
      margin-bottom: 20px;
    }

/* ================================================================
   📦 MEJORAS VISUALES v6.0 - CSS REFACTORIZADO
   ================================================================ */

/* =================================================================
   REFACTORIZACIÃ“N DE ESTILOS INLINE
   Este archivo contiene todas las clases CSS creadas para reemplazar
   los estilos inline del HTML principal
   ================================================================= */

/* ============================================================
   BARRA DE PROGRESO DE BACKUP
   ============================================================ */
#backupProgressBar {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10000;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  padding: 8px 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  border-bottom: 2px solid var(--primary);
}

.backup-progress-container {
  display: flex;
  align-items: center;
  gap: 12px;
  max-width: 1400px;
  margin: 0 auto;
}

.backup-progress-loading {
  width: 16px;
  height: 16px;
  border-width: 2px;
}

.backup-progress-content {
  flex: 1;
}

.backup-progress-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.backup-progress-text {
  color: #fff;
  font-size: 0.85rem;
  font-weight: 600;
}

.backup-progress-percent {
  color: var(--primary);
  font-weight: 700;
  font-size: 0.85rem;
}

.backup-progress-bar-bg {
  background: rgba(0,0,0,0.3);
  height: 6px;
  border-radius: 3px;
  overflow: hidden;
}

.backup-progress-bar-fill {
  background: linear-gradient(90deg, var(--primary), #10b981);
  height: 100%;
  width: 0%;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px var(--primary);
}

/* ============================================================
   TOOLBAR - BOTONES Y CONTROLES
   ============================================================ */
.btn-add-main-custom {
  padding: 8px 16px;
  font-size: 0.85rem;
  margin-right: 8px;
}

.toggle-label-custom {
  margin-right: 16px;
}

.btn-quitar-filtros {
  display: none;
  margin-right: 16px;
  padding: 8px 16px;
  font-size: 0.85rem;
  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
  border: none;
  color: white;
}

.connection-btn-custom {
  margin-left: 4px;
  padding: 8px 12px;
  cursor: default;
}

.search-box-custom {
  max-width: 350px;
  margin-left: auto;
}

/* ============================================================
   PAGINACIÃ“N
   ============================================================ */
.pagination-controls {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.pagination-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

.pagination-select {
  padding: 8px 12px;
  border-radius: 8px;
  border: 2px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 180px;
}

.pagination-info {
  font-size: 0.85rem;
  color: var(--text-secondary);
  opacity: 0.8;
  font-style: italic;
}

.page-numbers-container {
  display: flex;
  gap: 8px;
  align-items: center;
}

/* ============================================================
   VISTAS - LISTA Y TARJETAS
   ============================================================ */
.list-view-hidden {
  display: none;
}

/* ============================================================
   JERARQUÃA - TREE HEADER
   ============================================================ */
.tree-header-custom {
  font-size: 0.85rem;
  line-height: 1.6;
}

.tree-header-title {
  color: var(--primary);
}

/* ============================================================
   JERARQUÃA - BUSCADOR
   ============================================================ */
.jerarquia-search-container {
  padding: 16px;
  background: var(--bg-secondary);
  border-bottom: 2px solid var(--primary-color);
}

.jerarquia-search-wrapper {
  position: relative;
}

.jerarquia-search-input {
  width: 100%;
  padding: 12px 40px 12px 12px;
  font-size: 1rem;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  background: var(--bg-primary);
  color: var(--text-primary);
}

.jerarquia-search-clear {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  font-size: 1.2rem;
  color: var(--gray-500);
  cursor: pointer;
  padding: 4px 8px;
}

.jerarquia-search-results {
  margin-top: 8px;
  max-height: 300px;
  overflow-y: auto;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  display: none;
}

/* ============================================================
   JERARQUÃA - CONTROLES Y FILTROS
   ============================================================ */
.jerarquia-controls {
  padding: 12px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.toggle-tree-btn {
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filtros-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  flex-wrap: wrap;
}

.filtros-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

.filtro-select {
  max-width: 200px;
}

.filtro-select-hidden {
  max-width: 180px;
  display: none;
}

.btn-limpiar-filtros {
  padding: 6px 12px;
  font-size: 0.85rem;
  display: none;
}

.jerarquia-counter {
  font-size: 0.85rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

/* ============================================================
   JERARQUÃA - BREADCRUMB
   ============================================================ */
.filtros-breadcrumb {
  padding: 8px 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-bottom: 1px solid var(--border-color);
  display: none;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  font-size: 0.85rem;
  color: white;
}

.breadcrumb-label {
  font-weight: 600;
}

.breadcrumb-path {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

/* ============================================================
   MAPAS - HEADERS
   ============================================================ */
.map-section-header-custom h3 {
  line-height: 28px;
}

.map-new-btn {
  white-space: nowrap;
}

.map-controls-wrapper {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
}

/* ============================================================
   MAPAS - BUSCADOR Y FILTROS
   ============================================================ */
.map-search-container {
  padding: 8px 10px;
  background: var(--bg-secondary);
  border-radius: 6px;
  margin-bottom: 6px;
}

.map-search-input {
  width: 100%;
  padding: 6px 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--text-primary);
  font-size: 0.75rem;
  outline: none;
}

.map-category-filters {
  padding: 6px 10px;
  background: var(--bg-secondary);
  border-radius: 6px;
  margin-bottom: 8px;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
  align-items: center;
}

.map-category-label {
  font-size: 0.7rem;
  color: var(--text-muted);
  font-weight: 600;
}

.map-category-filter-btn {
  padding: 3px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  font-size: 0.7rem;
  cursor: pointer;
  transition: all 0.2s;
}

.map-category-filter-btn[data-category="all"] {
  background: var(--primary);
  color: white;
}

.map-category-filter-btn.active {
  background: var(--primary);
  color: white;
}

/* ============================================================
   UTILIDADES GENERALES
   ============================================================ */
.flex-center {
  display: flex;
  align-items: center;
}

.flex-between {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.gap-sm {
  gap: 6px;
}

.gap-md {
  gap: 12px;
}

.text-small {
  font-size: 0.85rem;
}

.text-tiny {
  font-size: 0.75rem;
}

.mb-sm {
  margin-bottom: 4px;
}

.mr-sm {
  margin-right: 8px;
}

.mr-md {
  margin-right: 16px;
}

/* ============================================================
   SECCIÃ“N DE MAPAS - ICONOS Y ELEMENTOS ADICIONALES
   ============================================================ */
.info-icon-small {
  font-size: 0.65rem;
}

.map-selection-badge {
  display: none;
  background: #10b981;
  color: white;
}

.map-btn-batch-hidden {
  display: none;
}

/* ============================================================
   ESTADÃSTICAS - TAB STATS
   ============================================================ */
.stats-title {
  margin-bottom: 24px;
  color: var(--primary);
}

.stats-details {
  margin-top: 30px;
}

/* ============================================================
   VALORES - TAB VALORES
   ============================================================ */
.valores-title {
  margin-bottom: 24px;
  color: var(--primary);
  display: flex;
  align-items: center;
  gap: 12px;
}

.valores-resumen {
  background: var(--bg-secondary);
  color: var(--text-primary);
  padding: 24px;
  border-radius: 12px;
  margin-bottom: 24px;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--border-color);
}

.valores-tabs-container {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  border-bottom: 2px solid var(--border-color);
  padding-bottom: 8px;
  flex-wrap: wrap;
}

.tab-valores {
  flex: 1;
  min-width: 150px;
  padding: 12px 16px;
  border: none;
  border-radius: 8px 8px 0 0;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.9rem;
  text-align: center;
}

.tab-valores:not(.active) {
  background: var(--bg-primary);
  color: var(--text-secondary);
}

.tab-valores.active {
  background: var(--primary);
  color: white;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.15);
}

/* ============================================================
   CONFIGURACIÃ“N - TAB CONFIG
   ============================================================ */
.config-title {
  margin-bottom: 20px;
  color: var(--primary);
}

.config-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 6px;
}

.config-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  padding: 16px;
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  border-radius: 10px;
  transition: all 0.2s;
  color: white;
  font-weight: 600;
  font-size: 1rem;
}

.config-content-hidden {
  display: none;
  padding-top: 16px;
}

.config-buttons-grid {
  display: grid;
  gap: 10px;
}

.config-btn-full {
  width: 100%;
  padding: 12px;
}

.config-btn-secondary {
  background: var(--secondary);
  color: white;
}

.config-btn-danger {
  background: var(--danger);
  color: white;
}

/* ============================================================
   BACKUP - PANEL DE ESTADO Y ESTRUCTURA
   ============================================================ */
.backup-structure-info {
  margin-bottom: 16px;
  padding: 12px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
  font-family: monospace;
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.backup-structure-title {
  color: var(--primary);
}

.backup-structure-content {
  margin-left: 8px;
  margin-top: 6px;
  line-height: 1.6;
}

.backup-file-name {
  color: var(--success);
}

.backup-file-hint {
  color: var(--warning);
}

.backup-file-hint-special {
  color: var(--info);
}

.backup-manual-update {
  margin-top: 10px;
  padding: 10px;
  background: rgba(245, 158, 11, 0.1);
  border-left: 3px solid var(--warning);
  border-radius: 4px;
}

.backup-manual-title {
  color: var(--warning);
}

.backup-manual-text {
  line-height: 1.6;
}

.backup-status-panel {
  margin-bottom: 16px;
  padding: 14px;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(16, 185, 129, 0.1) 100%);
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

.backup-status-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}

.backup-status-icon {
  font-size: 1.3rem;
}

.backup-status-content {
  flex: 1;
}

.backup-status-title {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.9rem;
}

.backup-status-text {
  color: var(--text-secondary);
  font-size: 0.8rem;
  margin-top: 2px;
}

.backup-metrics-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 10px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border-color);
}

.backup-metric-card {
  background: rgba(0,0,0,0.15);
  padding: 8px;
  border-radius: 6px;
}

.backup-metric-label {
  color: var(--text-secondary);
  font-size: 0.7rem;
  margin-bottom: 3px;
}

.backup-metric-value {
  color: var(--text-primary);
  font-weight: 600;
  font-size: 0.85rem;
}

/* ============================================================
   CONFIGURACIÃ“N - SECCIONES DETALLADAS
   ============================================================ */
.config-section-content {
  display: none;
  padding-top: 16px;
}

.config-buttons-container {
  display: grid;
  gap: 10px;
}

.config-btn-mobile {
  width: 100%;
  background: var(--secondary);
  color: white;
  padding: 12px;
}

.config-btn-pdf {
  width: 100%;
  padding: 12px;
  background: var(--danger);
  color: white;
}

.backup-structure {
  margin-bottom: 16px;
  padding: 12px;
  background: rgba(0,0,0,0.15);
  border-radius: 6px;
  font-family: monospace;
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.backup-structure-path {
  margin-left: 8px;
  margin-top: 6px;
  line-height: 1.6;
}

.backup-manual-guide {
  margin-top: 10px;
  padding: 10px;
  background: rgba(245, 158, 11, 0.1);
  border-left: 3px solid var(--warning);
  border-radius: 4px;
}

.backup-guide-text {
  line-height: 1.6;
}

.backup-status-panel-container {
  margin-bottom: 16px;
  padding: 14px;
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(16, 185, 129, 0.1) 100%);
  border-radius: 8px;
  border: 1px solid var(--border-color);
}

.backup-pending-changes {
  display: none;
  margin-top: 10px;
  padding: 8px;
  background: rgba(245, 158, 11, 0.15);
  border-radius: 6px;
  border-left: 3px solid var(--warning);
}

.config-divider {
  border-top: 1px solid var(--border-color);
  padding-top: 10px;
  margin-top: 6px;
}

.config-divider-margin {
  margin-top: 10px;
}

.config-small-text {
  color: var(--text-secondary);
  font-size: 0.75rem;
  display: block;
  margin-bottom: 10px;
}

.config-small-text-line-height {
  line-height: 1.5;
}

.config-btn-warning {
  width: 100%;
  padding: 12px;
  background: var(--warning);
  color: white;
}

.config-btn-info {
  width: 100%;
  padding: 12px;
  background: var(--info);
  color: white;
  margin-top: 8px;
}

.config-btn-gradient {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.config-success-note {
  margin-top: 12px;
  padding: 12px;
  background: rgba(16, 185, 129, 0.1);
  border-radius: 6px;
  border-left: 4px solid var(--success);
}

.config-inline-code {
  background: rgba(0,0,0,0.2);
  padding: 2px 4px;
  border-radius: 3px;
}

/* ============================================================
   JERARQUÃA CONFIG - SECCIÃ“N ESPECIAL
   ============================================================ */
.jerarquia-config-container {
  margin-top: 32px;
  padding: 24px;
  background: var(--bg-secondary);
  border-radius: 12px;
  border: 2px solid var(--border-color);
  max-width: 600px;
}

.jerarquia-config-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0;
  cursor: pointer;
  padding: 12px;
  background: rgba(0,0,0,0.1);
  border-radius: 6px;
  -webkit-user-select: none;
  user-select: none;
}

.jerarquia-config-header-content {
  display: flex;
  align-items: center;
  gap: 8px;
}

.jerarquia-config-title {
  color: var(--primary);
  margin: 0;
  font-size: 1.3rem;
  font-weight: 600;
}

.jerarquia-save-btn {
  padding: 10px 24px;
  font-weight: 600;
  display: none;
}

.jerarquia-tree-container {
  background: var(--bg-primary);
  padding: 20px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  min-height: 400px;
}

/* ============================================================
   LISTAS CONFIG - SECCIÃ“N DE LISTAS DESPLEGABLES
   ============================================================ */
.listas-config-container {
  margin-top: 24px;
  padding: 24px;
  background: var(--bg-secondary);
  border-radius: 12px;
  border: 2px solid var(--border-color);
}

.listas-config-description {
  color: var(--text-secondary);
  font-size: 0.8rem;
  margin-bottom: 12px;
}

.listas-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 12px;
}

.lista-card {
  background: var(--bg-secondary);
  padding: 12px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
}

.lista-title {
  color: var(--primary);
  margin-bottom: 8px;
  font-size: 0.85rem;
  font-weight: 600;
}

.lista-badge {
  display: inline-block;
  background: rgba(91, 124, 153, 0.2);
  color: #5B7C99;
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  margin-right: 6px;
}

.lista-badge-n1 {
  background: rgba(74, 144, 226, 0.2);
  color: #4A90E2;
}

.lista-badge-n2 {
  background: rgba(91, 124, 153, 0.2);
  color: #5B7C99;
}

.lista-badge-n3 {
  background: rgba(113, 128, 150, 0.2);
  color: #718096;
}

.lista-badge-n4 {
  background: rgba(122, 154, 184, 0.2);
  color: #7A9AB8;
}

.lista-badge-n5 {
  background: rgba(139, 154, 170, 0.2);
  color: #8B9AAA;
}

.lista-badge-n6 {
  background: rgba(154, 171, 184, 0.2);
  color: #9AABB8;
}

.lista-badge-n7 {
  background: rgba(107, 142, 127, 0.2);
  color: #6B8E7F;
}

.lista-content {
  max-height: 150px;
  overflow-y: auto;
  margin-bottom: 8px;
  background: var(--bg-primary);
  padding: 6px;
  border-radius: 4px;
  font-size: 0.8rem;
}

.lista-input-group {
  display: flex;
  gap: 6px;
}

.lista-input {
  flex: 1;
  padding: 6px 8px;
  font-size: 0.8rem;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--text-primary);
}

.lista-add-btn {
  padding: 6px 10px;
  font-size: 0.75rem;
}

/* ============================================================
   HIDDEN ELEMENTS - Para elementos con display: none inicial
   ============================================================ */
.hidden {
  display: none;
}

/* ============================================================
   CONFIG - CategorÃ­as de Ãreas del Mapa
   ============================================================ */
.config-section {
  margin-top: 32px;
  padding: 24px;
  background: var(--bg-secondary);
  border-radius: 12px;
  border: 2px solid var(--border-color);
}

.config-section-header-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
}

.config-section-clickable {
  cursor: pointer;
  flex: 1;
  padding: 12px;
  background: rgba(0,0,0,0.1);
  border-radius: 6px;
  -webkit-user-select: none;
  user-select: none;
}

.config-section-title-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.config-section-title {
  color: var(--primary);
  margin: 0;
  font-size: 1.2rem;
  font-weight: 600;
}

.config-btn-add-category {
  background: var(--success);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.config-btn-add-category:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.config-btn-icon {
  font-size: 1.1rem;
}

.config-description {
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-bottom: 16px;
}

.config-section-content-hidden {
  display: none;
  padding-top: 16px;
}

.categorias-container {
  background: var(--bg-secondary);
  padding: 20px;
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

.categorias-grid {
  display: grid;
  gap: 12px;
}

.mensaje-no-categorias {
  display: none;
  text-align: center;
  padding: 40px;
  color: var(--text-secondary);
}

.mensaje-no-categorias-icon {
  font-size: 3rem;
  margin-bottom: 12px;
  opacity: 0.5;
}

.mensaje-no-categorias-text {
  font-size: 0.95rem;
  margin: 0;
}

.mensaje-no-categorias-small {
  font-size: 0.8rem;
  color: var(--text-muted);
}

.config-info-box {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.1));
  padding: 16px;
  border-radius: 8px;
  margin-top: 16px;
  border-left: 4px solid var(--primary);
}

.config-info-content {
  display: flex;
  align-items: start;
  gap: 12px;
}

.config-info-icon {
  font-size: 1.5rem;
}

.config-info-title {
  color: var(--text-primary);
  font-size: 0.9rem;
  margin: 0 0 6px 0;
  font-weight: 600;
}

.config-info-description {
  color: var(--text-secondary);
  font-size: 0.8rem;
  margin: 0;
  line-height: 1.5;
}

/* ============================================================
   MODAL REPUESTOS - Formulario
   ============================================================ */
.form-categoria-select {
  font-size: 1.05rem;
  font-weight: 700;
  color: #4A6278;
}

.form-ejemplos-small {
  color: #7A9AB8;
  font-size: 0.8rem;
  display: block;
  margin-top: 6px;
  font-style: italic;
  min-height: 20px;
}

.ubicaciones-section {
  background: linear-gradient(135deg, rgba(91, 124, 153, 0.1), rgba(107, 142, 127, 0.1));
  padding: 16px;
  border-radius: 12px;
  margin-bottom: 16px;
  border: 2px solid var(--border-color);
}

.ubicaciones-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.ubicaciones-title {
  margin: 0;
  color: var(--primary);
  font-size: 1rem;
}

.btn-agregar-ubicacion {
  padding: 6px 12px;
  font-size: 0.85rem;
}

.version-indicator {
  margin-left: 12px;
  padding: 4px 10px;
  background: rgba(34, 197, 94, 0.15);
  border: 1px solid rgba(34, 197, 94, 0.4);
  border-radius: 4px;
  font-size: 0.75rem;
  color: #22c55e;
  font-weight: 600;
}

.ubicaciones-hint {
  background: rgba(59, 130, 246, 0.1);
  padding: 10px;
  border-radius: 6px;
  margin-bottom: 12px;
  font-size: 0.8rem;
  color: var(--text-secondary);
  border-left: 3px solid var(--info);
}

.form-stock-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 12px;
}

.form-hint-small {
  color: var(--text-secondary);
  font-size: 0.75rem;
  display: block;
  margin-top: -8px;
  margin-bottom: 12px;
}

.form-label-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.form-label-optional {
  color: var(--text-secondary);
  font-weight: 400;
  font-size: 0.75rem;
}

.form-textarea-tech {
  resize: vertical;
  min-height: 80px;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
}

.form-textarea-hint {
  color: var(--text-secondary);
  font-size: 0.7rem;
  display: block;
  margin-top: 4px;
}

.form-multimedia-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

.form-label-space-between {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-weight: 500;
  font-size: 0.85rem;
  color: var(--text-primary);
}

.form-upload-mode {
  color: var(--info);
  font-weight: 600;
  font-size: 0.7rem;
}

.mobile-photo-buttons {
  display: none;
  gap: 6px;
  margin-bottom: 8px;
}

.mobile-photo-btn {
  flex: 1;
  padding: 8px;
  font-size: 0.8rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.form-input-hidden {
  display: none;
}

.form-input-file {
  padding: 8px 12px;
  font-size: 0.85rem;
}

.multimedia-preview-margin {
  margin-top: 6px;
}

.form-label-margin {
  margin-bottom: 6px;
}

.documents-list {
  margin-top: 6px;
  font-size: 0.8rem;
  color: var(--text-secondary);
}

/* Zona de carga de imágenes mejorada */
.image-upload-zone {
  border: 2px dashed var(--primary);
  border-radius: 6px;
  padding: 24px 16px;
  text-align: center;
  background: rgba(91, 139, 180, 0.04);
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 12px;
}

.image-upload-zone:hover {
  background: rgba(91, 139, 180, 0.08);
  border-color: rgba(91, 139, 180, 0.8);
}

.upload-icon {
  font-size: 2.5rem;
  margin-bottom: 8px;
  opacity: 0.6;
}

.upload-text {
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.upload-hint {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

/* Modal Optimizador de Imágenes */
.optimizer-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  padding: 20px;
}

.optimizer-modal.active {
  display: flex;
}

.optimizer-content {
  background: var(--bg-secondary);
  border-radius: 12px;
  max-width: 900px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
}

.optimizer-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  border-bottom: 1px solid var(--border-color);
}

.optimizer-header h3 {
  margin: 0;
  font-size: 1.2rem;
  color: var(--text-primary);
}

.optimizer-close {
  background: none;
  border: none;
  font-size: 2rem;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  line-height: 1;
}

.optimizer-close:hover {
  color: var(--danger);
}

.optimizer-body {
  padding: 20px;
}

.optimizer-preview {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  margin-bottom: 30px;
  align-items: center;
}

.preview-original,
.preview-optimized {
  text-align: center;
}

.preview-original h4,
.preview-optimized h4 {
  margin: 0 0 10px 0;
  font-size: 0.9rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.preview-original img,
.preview-optimized img {
  max-width: 100%;
  max-height: 250px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--bg-primary);
}

.preview-info {
  margin-top: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.preview-arrow {
  font-size: 2rem;
  color: var(--primary);
}

.savings-badge {
  margin-top: 10px;
  padding: 8px 12px;
  background: var(--success);
  color: white;
  border-radius: 6px;
  font-size: 0.85rem;
  display: inline-block;
}

.savings-badge strong {
  font-size: 1.1rem;
}

.optimizer-controls {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.control-group label {
  display: block;
  margin-bottom: 10px;
  font-weight: 500;
  color: var(--text-primary);
}

.size-options {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
}

.size-btn {
  padding: 12px;
  border: 2px solid var(--border-color);
  background: var(--bg-tertiary);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  text-align: center;
}

.size-btn span {
  display: block;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.size-btn small {
  display: block;
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.size-btn:hover {
  border-color: var(--primary);
  background: rgba(91, 139, 180, 0.1);
}

.size-btn.active {
  border-color: var(--primary);
  background: var(--primary);
  color: white;
}

.size-btn.active span,
.size-btn.active small {
  color: white;
}

#qualitySlider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--border-color);
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

#qualitySlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--primary);
  cursor: pointer;
}

#qualitySlider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--primary);
  cursor: pointer;
  border: none;
}

.control-group small {
  display: block;
  margin-top: 5px;
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.optimizer-footer {
  display: flex;
  gap: 12px;
  padding: 20px;
  border-top: 1px solid var(--border-color);
  justify-content: flex-end;
}

.optimizer-footer .btn {
  min-width: 150px;
}

.form-actions {
  display: flex;
  gap: 12px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 2px solid var(--border-color);
}

.btn-save-main {
  flex: 1;
  font-weight: 700;
}

.btn-loading-hidden {
  display: none;
}

.btn-cancel-modal {
  flex: 1;
}

/* ============================================================
   MODALES - Estilos comunes para modales
   ============================================================ */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  z-index: 10001;
  overflow: hidden;
  -webkit-backdrop-filter: blur(4px);
  backdrop-filter: blur(4px);
}

.modal-overlay-highest {
  z-index: 99999;
}

.modal-container {
  position: relative;
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  margin: 10vh auto;
  background: var(--bg-secondary);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.modal-header {
  padding: 20px 24px;
  background: linear-gradient(135deg, var(--primary), var(--info));
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-title {
  margin: 0;
  font-size: 1.4rem;
  display: flex;
  align-items: center;
  gap: 10px;
}

.modal-icon {
  font-size: 1.8rem;
}

.modal-close-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  font-size: 1.8rem;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.modal-close-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: rotate(90deg);
}

.modal-content {
  padding: 24px;
  max-height: calc(80vh - 80px);
  overflow-y: auto;
}

/* Variantes de modal */
.modal-container-large {
  max-width: 900px;
  height: 90vh;
  margin: 5vh auto;
  background: var(--bg-primary);
}

.modal-container-xlarge {
  max-width: 1200px;
  height: 90vh;
  margin: 5vh auto;
  border-radius: 8px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.modal-header-stats {
  padding: 24px;
  border-bottom: 2px solid var(--border-color);
  background: linear-gradient(135deg, var(--primary), var(--secondary));
  color: white;
  border-radius: 16px 16px 0 0;
  flex-shrink: 0;
}

.modal-header-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-title-large {
  margin: 0;
  font-size: 1.8rem;
  display: flex;
  align-items: center;
  gap: 12px;
}

.modal-icon-large {
  font-size: 2rem;
}

.modal-close-btn-large {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  font-size: 28px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s;
}

.modal-close-btn-large:hover {
  background: rgba(239, 68, 68, 0.9);
  transform: rotate(90deg);
}

.modal-content-flex {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.modal-footer {
  padding: 20px 24px;
  border-top: 2px solid var(--border-color);
  background: var(--bg-secondary);
  border-radius: 0 0 16px 16px;
  flex-shrink: 0;
}

.modal-footer-btn {
  width: 100%;
  padding: 14px;
  font-size: 1.1rem;
}

/* Modal Cascada - estilos especÃ­ficos */
.modal-header-cascada {
  padding: 16px 20px;
  border-bottom: 1px solid var(--border-color);
  background: var(--bg-secondary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.modal-title-cascada {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
  font-weight: 600;
}

.modal-close-btn-simple {
  background: none;
  border: none;
  color: var(--text-secondary);
  width: 32px;
  height: 32px;
  border-radius: 4px;
  font-size: 24px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.modal-close-btn-simple:hover {
  background: var(--bg-tertiary);
  color: var(--danger);
}

.cascada-toolbar {
  padding: 12px 20px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}

.cascada-stats {
  padding: 8px 12px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  margin-bottom: 10px;
  font-size: 0.85rem;
  color: var(--text-secondary);
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}

.cascada-search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-size: 0.9rem;
  outline: none;
  margin-bottom: 10px;
}

.cascada-buttons {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.cascada-btn {
  padding: 6px 12px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--text-primary);
  font-size: 0.85rem;
  cursor: pointer;
  transition: background 0.2s;
}

.cascada-btn:hover {
  background: var(--bg-primary);
}

.modal-content-cascada {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px;
}

.modal-footer-simple {
  padding: 12px 20px;
  border-top: 1px solid var(--border-color);
  background: var(--bg-secondary);
  flex-shrink: 0;
}

.modal-footer-btn-simple {
  width: 100%;
  padding: 10px;
  background: var(--primary);
  border: none;
  border-radius: 4px;
  color: white;
  font-size: 0.95rem;
  cursor: pointer;
  transition: opacity 0.2s;
}

.modal-footer-btn-simple:hover {
  opacity: 0.9;
}

/* Modal Detalles - modal simple para confirmaciones */
.modal-detalles-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 10000;
  justify-content: center;
  align-items: center;
}

.modal-detalles-container {
  background: var(--bg-secondary);
  border-radius: 12px;
  max-width: 600px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
}

.modal-detalles-content {
  padding: 20px;
}

.file-input-hidden {
  display: none;
}



/* =================================================================
   📦 REFACTORIZACIÓN DE ESTILOS INLINE v6.0
   Este archivo contiene todas las clases CSS creadas para reemplazar
   los estilos inline del HTML principal - Mejoras visuales aplicadas
   ================================================================= */

/* ============================================================
   BARRA DE PROGRESO DE BACKUP
   ============================================================ */
#backupProgressBar {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10000;
  background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
  padding: 8px 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  border-bottom: 2px solid var(--primary);
}

.backup-progress-container {
  display: flex;
  align-items: center;
  gap: 12px;
  max-width: 1400px;
  margin: 0 auto;
}

.backup-progress-loading {
  width: 16px;
  height: 16px;
  border-width: 2px;
}

.backup-progress-content {
  flex: 1;
}

.backup-progress-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.backup-progress-text {
  color: #fff;
  font-size: 0.85rem;
  font-weight: 600;
}

.backup-progress-percent {
  color: var(--primary);
  font-weight: 700;
  font-size: 0.85rem;
}

.backup-progress-bar-bg {
  background: rgba(0,0,0,0.3);
  height: 6px;
  border-radius: 3px;
  overflow: hidden;
}

.backup-progress-bar-fill {
  background: linear-gradient(90deg, var(--primary), #10b981);
  height: 100%;
  width: 0%;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px var(--primary);
}

/* ============================================================
   TOOLBAR - BOTONES Y CONTROLES
   ============================================================ */
.btn-add-main-custom {
  padding: 8px 16px;
  font-size: 0.85rem;
  margin-right: 8px;
}

.toggle-label-custom {
  margin-right: 16px;
}

.btn-quitar-filtros {
  display: none;
  margin-right: 16px;
  padding: 8px 16px;
  font-size: 0.85rem;
  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
  border: none;
  color: white;
}

.connection-btn-custom {
  margin-left: 4px;
  padding: 8px 12px;
  cursor: default;
}

.search-box-custom {
  max-width: 350px;
  margin-left: auto;
}

/* ============================================================
   PAGINACIÓN
   ============================================================ */
.pagination-controls {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.pagination-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

.pagination-select {
  padding: 8px 12px;
  border-radius: 8px;
  border: 2px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  cursor: pointer;
  font-size: 0.9rem;
  min-width: 180px;
}

.pagination-info {
  font-size: 0.85rem;
  color: var(--text-secondary);
  opacity: 0.8;
  font-style: italic;
}

.page-numbers-container {
  display: flex;
  gap: 8px;
  align-items: center;
}

/* ============================================================
   VISTAS - LISTA Y TARJETAS
   ============================================================ */
.list-view-hidden {
  display: none;
}

/* ============================================================
   JERARQUÍA - TREE HEADER
   ============================================================ */
.tree-header-custom {
  font-size: 0.85rem;
  line-height: 1.6;
}

.tree-header-title {
  color: var(--primary);
}

/* ============================================================
   JERARQUÍA - BUSCADOR
   ============================================================ */
.jerarquia-search-container {
  padding: 16px;
  background: var(--bg-secondary);
  border-bottom: 2px solid var(--primary-color);
}

.jerarquia-search-wrapper {
  position: relative;
}

.jerarquia-search-input {
  width: 100%;
  padding: 12px 40px 12px 12px;
  font-size: 1rem;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  background: var(--bg-primary);
  color: var(--text-primary);
}

.jerarquia-search-clear {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  font-size: 1.2rem;
  color: var(--gray-500);
  cursor: pointer;
  padding: 4px 8px;
}

.jerarquia-search-results {
  margin-top: 8px;
  max-height: 300px;
  overflow-y: auto;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  display: none;
}

/* ============================================================
   JERARQUÍA - CONTROLES Y FILTROS
   ============================================================ */
.jerarquia-controls {
  padding: 12px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.toggle-tree-btn {
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.filtros-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  flex-wrap: wrap;
}

.filtros-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

.filtro-select {
  max-width: 200px;
}

.filtro-select-hidden {
  max-width: 180px;
  display: none;
}

.btn-limpiar-filtros {
  padding: 6px 12px;
  font-size: 0.85rem;
  display: none;
}

.jerarquia-counter {
  font-size: 0.85rem;
  color: var(--text-secondary);
  white-space: nowrap;
}

/* ============================================================
   JERARQUÍA - BREADCRUMB
   ============================================================ */
.filtros-breadcrumb {
  padding: 8px 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-bottom: 1px solid var(--border-color);
  display: none;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  font-size: 0.85rem;
  color: white;
}

.breadcrumb-label {
  font-weight: 600;
}

.breadcrumb-path {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

/* ============================================================
   MAPAS - HEADERS
   ============================================================ */
.map-section-header-custom h3 {
  line-height: 28px;
}

.map-new-btn {
  white-space: nowrap;
}

.map-controls-wrapper {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
}

/* ============================================================
   MAPAS - BUSCADOR Y FILTROS
   ============================================================ */
.map-search-container {
  padding: 8px 10px;
  background: var(--bg-secondary);
  border-radius: 6px;
  margin-bottom: 6px;
}

.map-search-input {
  width: 100%;
  padding: 6px 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--text-primary);
  font-size: 0.75rem;
  outline: none;
}

.map-category-filters {
  padding: 6px 10px;
  background: var(--bg-secondary);
  border-radius: 6px;
  margin-bottom: 8px;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
  align-items: center;
}

.map-category-label {
  font-size: 0.7rem;
  color: var(--text-muted);
  font-weight: 600;
}

.map-category-filter-btn {
  padding: 3px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  font-size: 0.7rem;
  cursor: pointer;
  transition: all 0.2s;
}

.map-category-filter-btn[data-category="all"] {
  background: var(--primary);
  color: white;
}

.map-category-filter-btn.active {
  background: var(--primary);
  color: white;
}

/* ============================================================
   UTILIDADES GENERALES
   ============================================================ */
.flex-center {
  display: flex;
  align-items: center;
}

.flex-between {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.gap-sm {
  gap: 6px;
}

.gap-md {
  gap: 12px;
}

.text-small {
  font-size: 0.85rem;
}

.text-tiny {
  font-size: 0.75rem;
}

.mb-sm {
  margin-bottom: 4px;
}

.mr-sm {
  margin-right: 8px;
}

.mr-md {
  margin-right: 16px;
}

/* ============================================================
   SECCIÓN DE MAPAS - ICONOS Y ELEMENTOS ADICIONALES
   ============================================================ */
.info-icon-small {
  font-size: 0.65rem;
}

.map-selection-badge {
  display: none;
  background: #10b981;
  color: white;
}

.map-btn-batch-hidden {
  display: none;
}

/* ============================================================
   ESTADÍSTICAS - TAB STATS
   ============================================================ */
.stats-title {
  margin-bottom: 24px;
  color: var(--primary);
}

.stats-details {
  margin-top: 30px;
}

/* ============================================================
   VALORES - TAB VALORES
   ============================================================ */
.valores-title {
  margin-bottom: 24px;
  color: var(--primary);
  display: flex;
  align-items: center;
  gap: 12px;
}

.valores-resumen {
  background: var(--bg-secondary);
  color: var(--text-primary);
  padding: 24px;
  border-radius: 12px;
  margin-bottom: 24px;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--border-color);
}

.valores-tabs-container {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  border-bottom: 2px solid var(--border-color);
  padding-bottom: 8px;
  flex-wrap: wrap;
}

.tab-valores {
  flex: 1;
  min-width: 150px;
  padding: 12px 16px;
  border: none;
  border-radius: 8px 8px 0 0;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.9rem;
  text-align: center;
}

.tab-valores:not(.active) {
  background: var(--bg-primary);
  color: var(--text-secondary);
}

.tab-valores.active {
  background: var(--primary);
  color: white;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.15);
}

/* ============================================================
   CONFIGURACIÓN - TAB CONFIG
   ============================================================ */
.config-title {
  margin-bottom: 20px;
  color: var(--primary);
}

.config-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 6px;
}

.config-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  padding: 16px;
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
  border-radius: 10px;
  transition: all 0.2s;
  color: white;
  font-weight: 600;
  font-size: 1rem;
}

.config-content-hidden {
  display: none;
  padding-top: 16px;
}

.config-buttons-grid {
  display: grid;
  gap: 10px;
}

.config-btn-full {
  width: 100%;
  padding: 12px;
}

.config-btn-secondary {
  background: var(--secondary);
  color: white;
}

.config-btn-danger {
  background: var(--danger);
  color: white;
}

/* ===== RESTO DEL CSS OMITIDO POR BREVEDAD - SE APLICARÁ COMPLETO ===== */
    
  </style>
  
  <!-- SheetJS para exportación Excel profesional -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  
  <!-- jsPDF para exportación PDF con imágenes -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- JSZip para compresión de backups completos -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

<!-- 🔄 BARRA DE PROGRESO DE BACKUP AUTOMÁTICO -->
<div id="backupProgressBar">
  <div class="backup-progress-container">
    <div class="loading backup-progress-loading"></div>
    <div class="backup-progress-content">
      <div class="backup-progress-header">
        <span class="backup-progress-text">Creando backup automático...</span>
        <span id="backupProgressPercent" class="backup-progress-percent">0%</span>
      </div>
      <div class="backup-progress-bar-bg">
        <div id="backupProgressFill" class="backup-progress-bar-fill"></div>
      </div>
    </div>
  </div>
</div>

<!-- CONTENEDOR FIJO SUPERIOR -->
<div class="sticky-header-container">
  <!-- ❌ ELIMINADO: Título "Inventario Visual" e indicador de conexión movido -->

  <!-- NAVEGACIÓN - DENTRO DEL CONTENEDOR STICKY -->
  <div class="nav-tabs">
    <button class="nav-tab active" data-tab="inventario">
      Inventario
    </button>
    <button class="nav-tab" data-tab="jerarquia">
      Jerarquía
    </button>
    <button class="nav-tab" data-tab="mapa">
      Mapa
    </button>
    <button class="nav-tab" data-tab="stats">
      Stats
    </button>
    <button class="nav-tab" data-tab="valores">
      Valores
    </button>
    <button class="nav-tab" data-tab="configuracion">
      Configuración
    </button>
  </div>
</div>

<!-- CONTENEDOR PRINCIPAL -->
<div class="container">
  <!-- TAB INVENTARIO -->
  <div id="inventario" class="tab-content active">
    <div class="toolbar">
      <!-- ⬅️ BOTONES MOVIDOS A LA IZQUIERDA -->
      <button class="btn btn-success btn-add-main btn-add-main-custom" onclick="app.openModal('add')">
        <span class="btn-icon">+</span>
        <span class="btn-text">Agregar</span>
      </button>
      
      <label class="toggle-label toggle-label-custom">
        Precio
        <label class="toggle-switch">
          <input type="checkbox" id="togglePrecio" onchange="app.togglePrecio()" aria-label="Mostrar u ocultar columna de precio">
          <span class="toggle-slider"></span>
        </label>
      </label>
      
      <!-- Botón Quitar Filtros Jerárquicos -->
      <button class="btn btn-secondary btn-quitar-filtros" id="quitarFiltrosJerarquicosBtn" onclick="app.quitarFiltrosJerarquicos()" title="Quitar filtros aplicados desde jerarquía">
        ✖ Quitar Filtros
      </button>
      
      <div class="view-btns">
        <button class="view-btn active" data-view="cards">Tarjetas</button>
        <button class="view-btn" data-view="list">Lista</button>
        
        <!-- 🟢🔴 INDICADOR DE CONEXIÓN COMO BOTÓN -->
        <button class="view-btn connection-btn-custom" id="connectionBtn">
          <span id="connectionIcon">📁</span>
        </button>
      </div>
      
      <!-- 🔍 BUSCADOR MÁS COMPACTO -->
      <div class="search-box search-box-custom">
        <span class="search-icon">⌕</span>
        <input type="text" class="search-input" id="searchInput" placeholder="Buscar...">
      </div>
    </div>

    <div class="filters-selects">
      <select class="filter-select" id="filterArea" onchange="app.applyFilters()" aria-label="Filtrar por área">
        <option value="">Todas las Áreas</option>
      </select>
      
      <select class="filter-select" id="filterEquipo" onchange="app.applyFilters()" aria-label="Filtrar por equipo">
        <option value="">Todos los Equipos</option>
      </select>
      
      <select class="filter-select" id="filterTipo" onchange="app.applyFilters()" aria-label="Filtrar por tipo">
        <option value="">Todos los Tipos</option>
      </select>
      
      <select class="filter-select" id="filterStock" onchange="app.applyFilters()" aria-label="Filtrar por stock">
        <option value="">Ver Todos</option>
        <option value="agotado">Agotados (0 unid.)</option>
        <option value="critico">Críticos (bajo mínimo)</option>
        <option value="adecuado">Adecuados (entre mín-ópt)</option>
        <option value="optimo">Óptimos (sobre óptimo)</option>
      </select>
    </div>

    <!-- PAGINACIÓN -->
    <div id="pagination" class="pagination-controls hidden">
      <div class="pagination-controls">
        <label class="pagination-label">Items por página:</label>
        <select id="itemsPerPageSelect" onchange="app.changeItemsPerPage(this.value)" class="pagination-select" aria-label="Seleccionar items por página">
          <option value="auto">Auto (Responsive)</option>
          <option value="12">12 items</option>
          <option value="18">18 items</option>
          <option value="21">21 items</option>
          <option value="24">24 items</option>
          <option value="30">30 items</option>
          <option value="40">40 items</option>
          <option value="50">50 items</option>
        </select>
        <span id="itemsPerPageInfo" class="pagination-info"></span>
      </div>
      <button onclick="app.previousPage()" class="btn btn-secondary" id="btnPrevPage">Anterior</button>
      <div id="pageNumbers" class="page-numbers-container"></div>
      <button onclick="app.nextPage()" class="btn btn-secondary" id="btnNextPage">Siguiente</button>
    </div>

    <div id="inventarioContent">
      <div class="cards-grid" id="cardsGrid"></div>
      <div class="list-view list-view-hidden" id="listView"></div>
    </div>
  </div>

  <!-- TAB JERARQUÍA -->
  <div id="jerarquia" class="tab-content">
    <div class="tree-container">
      <div class="tree-header tree-header-custom">
        <strong class="tree-header-title">Estructura Jerárquica:</strong><br>
        🏭 <strong>Planta</strong> (Ej: Aquachile) → 
        <strong>Área</strong> (Ej: Producción) → 
        <strong>Sub-Área</strong> (Ej: Sistema Agua) → 
        <strong>Sistema</strong> (Ej: Bomba BP-01) → 
        <strong>Sub-Sistema</strong> (Ej: Hidráulico) → 
        <strong>Sección</strong> (Ej: Sellado) → 
        <strong>Detalle</strong> (Ej: Fijación) → 
        <strong>Repuesto</strong>
      </div>
      
      <!-- BUSCADOR RÁPIDO -->
      <div class="jerarquia-search-container">
        <div class="jerarquia-search-wrapper">
          <input 
            type="text" 
            id="searchJerarquia" 
            placeholder="Buscar niveles o repuestos..." 
            oninput="app.buscarEnJerarquia(this.value)"
            class="form-control jerarquia-search-input"
          />
          <button 
            onclick="document.getElementById('searchJerarquia').value = ''; app.buscarEnJerarquia('');" 
            class="jerarquia-search-clear"
            title="Limpiar búsqueda"
          >✖</button>
        </div>
        <div id="searchResultsJerarquia" class="jerarquia-search-results"></div>
      </div>
      
      <!-- Controles de jerarquía -->
      <div class="jerarquia-controls">
        
        <!-- Botón Expandir/Contraer Todo -->
        <button onclick="app.toggleAllTree()" class="btn btn-secondary toggle-tree-btn">
          <span id="toggleAllIcon">📂</span>
          <span id="toggleAllText">Expandir Todo</span>
        </button>
        
        <!-- Filtros Escalonados -->
        <div class="filtros-wrapper">
          <label class="filtros-label">
            Filtrar:
          </label>
          
          <!-- Nivel 1: Planta -->
          <select id="filtro_planta" onchange="app.filtrarEscalonado(1, this.value)" class="form-control filtro-select" aria-label="Filtrar por planta">
            <option value="">Todas las plantas</option>
          </select>
          
          <!-- Nivel 2: Área -->
          <select id="filtro_area" onchange="app.filtrarEscalonado(2, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por área">
            <option value="">📁 Todas las áreas</option>
          </select>
          
          <!-- Nivel 3: Sub-Área -->
          <select id="filtro_subarea" onchange="app.filtrarEscalonado(3, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por sub-área">
            <option value="">📁 Todas las sub-áreas</option>
          </select>
          
          <!-- Nivel 4: Sistema -->
          <select id="filtro_sistema" onchange="app.filtrarEscalonado(4, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por sistema">
            <option value="">📁 Todos los sistemas</option>
          </select>
          
          <!-- Nivel 5: Sub-Sistema -->
          <select id="filtro_subsistema" onchange="app.filtrarEscalonado(5, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por sub-sistema">
            <option value="">📁 Todos los sub-sistemas</option>
          </select>
          
          <!-- Nivel 6: Sección -->
          <select id="filtro_seccion" onchange="app.filtrarEscalonado(6, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por sección">
            <option value="">📁 Todas las secciones</option>
          </select>
          
          <!-- Nivel 7: Detalle -->
          <select id="filtro_detalle" onchange="app.filtrarEscalonado(7, this.value)" class="form-control filtro-select-hidden" aria-label="Filtrar por detalle">
            <option value="">📁 Todos los detalles</option>
          </select>
          
          <!-- Botón Limpiar Filtros -->
          <button onclick="app.limpiarFiltrosJerarquia()" class="btn btn-secondary btn-limpiar-filtros" id="btnLimpiarFiltros">
            ✖ Limpiar
          </button>
        </div>
        
        <!-- Contador de repuestos visibles -->
        <div id="jerarquiaCounter" class="jerarquia-counter">
          <span id="repuestosVisibles">0</span> repuestos
        </div>
      </div>
      
      <!-- Breadcrumb de Filtros Activos -->
      <div id="filtrosBreadcrumb" class="filtros-breadcrumb">
        <span class="breadcrumb-label">Filtro activo:</span>
        <span id="breadcrumbPath" class="breadcrumb-path"></span>
      </div>
      
      <div id="treeContainer"></div>
    </div>
  </div>

  <!-- 
  ═══════════════════════════════════════════════════════════════════════════════
  🗺️ MAPA ANTIGUO COMENTADO COMO BACKUP (FASE 1)
  ═══════════════════════════════════════════════════════════════════════════════
  Si el nuevo mapa falla, puedes descomentar esto y comentar el nuevo.
  
  <div id="mapa" class="tab-content">
    <div class="map-container">
      <h2 style="margin-bottom: 20px; color: var(--primary);">Mapa de Ubicaciones</h2>
      
      <div class="map-controls">
        <button class="tool-btn" onclick="document.getElementById('mapImageInput').click()">
          Cargar Imagen
        </button>
        <input type="file" id="mapImageInput" accept="image/*" style="display: none;" onchange="app.loadMapImage(event)">
        
        <button class="tool-btn active" data-tool="select" onclick="app.selectTool('select')">
          Seleccionar
        </button>
        <button class="tool-btn" data-tool="rect" onclick="app.selectTool('rect')">
          Rectángulo
        </button>
        <button class="tool-btn" data-tool="circle" onclick="app.selectTool('circle')">
          Círculo
        </button>
        <button class="tool-btn" data-tool="machine" onclick="app.selectTool('machine')">
          Máquina
        </button>
        <button class="tool-btn" data-tool="delete" onclick="app.selectTool('delete')">
          Eliminar
        </button>
        <button class="btn btn-success" onclick="app.saveMap()">
          Guardar Mapa
        </button>
      </div>
      
      <canvas id="mapCanvas"></canvas>
    </div>
  </div>
  ═══════════════════════════════════════════════════════════════════════════════
  -->
  
  <!-- 🗺️ NUEVO SISTEMA DE MAPAS AVANZADO DE APP_BASE (FASE 3 - HTML INTEGRADO) -->
  <!-- TAB MAPA -->
  <div id='mapa' class='tab-content'>
    <div class='map-shell'>
      <aside class='map-panel'>
        <div class='map-panel-header'>
          <div>
            <h2>Mapas de planta</h2>
            <p>Gestiona mapas, zonas y jerarquías</p>
          </div>
          <div class='map-connection'>
            <span id='mapConnectionBadge' class='map-status-badge map-status-badge--off'>Sin carpeta</span>
            <button id='mapConnectBtn' class='map-btn map-btn--primary'>Conectar carpeta</button>
          </div>
        </div>
        <div class='map-panel-scroll'>
          <section class='map-section'>
            <div class='map-section-header map-section-header-custom' onclick='app.toggleMapSection(this)'>
              <h3><span class='map-section-collapse-icon'>▼</span> Mapas disponibles</h3>
              <button id='mapNewBtn' class='map-btn map-btn--accent map-new-btn' onclick='event.stopPropagation(); app.crearNuevoMapa()'>Nuevo mapa</button>
            </div>
            <div id='mapList' class='map-card-list'></div>
          </section>
          <section class='map-section'>
            <div class='map-section-header map-section-header-custom' onclick='app.toggleMapSection(this)'>
              <h3><span class='map-section-collapse-icon'>▼</span> Áreas del mapa</h3>
              <div class='map-controls-wrapper'>
                <button id='mapDrawAreaBtn' class='map-btn map-btn--ghost' onclick='event.stopPropagation()'>Dibujar área</button>
                <button id='mapAddMarkerBtn' class='map-btn map-btn--success' onclick='event.stopPropagation()'>
                  Agregar Marcador
                </button>
                <button id='btnVerCascadaModal' class='map-btn map-btn--primary' onclick='mapController.openCascadaModal(); event.stopPropagation();' title='Ver cascada completa en pantalla grande'>
                  Ver Cascada
                </button>
              </div>
            </div>
            <!-- 🔍 NUEVO: Buscador de áreas -->
            <div class='map-search-container'>
              <input 
                type='text' 
                id='mapAreaSearch' 
                placeholder='Buscar área por nombre...'
                class='map-search-input'
              />
            </div>
            <!-- 📂 NUEVO: Filtros de categoría -->
            <div class='map-category-filters'>
              <span class='map-category-label'>TIPO:</span>
              <button class='map-category-filter-btn' data-category='all'>
                Todas
              </button>
              <button class='map-category-filter-btn' data-category='area'>
                Área
              </button>
              <button class='map-category-filter-btn' data-category='maquina'>
                Máquina
              </button>
              <button class='map-category-filter-btn' data-category='estructura'>
                Estructura
              </button>
              <button class='map-category-filter-btn' data-category='cinta'>
                📦 Cinta
              </button>
              <button class='map-category-filter-btn' data-category='componente'>
                🔩 Componente
              </button>
            </div>
            <div id='areaList' class='map-area-list'></div>
          </section>
          <!-- ❌ ELIMINADO: Historial - No se le dará uso funcional -->
        </div>
      </aside>
      <div class='map-workspace'>
        <div class='map-toolbar' id='mapToolbar'>
          <div class='map-toolbar-left'>
            <button class='map-icon-btn map-btn-info' data-action='zoom-in' data-tooltip='Zoom In: Acerca la vista del mapa. También puedes usar la rueda del mouse o Ctrl + para acercar.'>
              + <span class='info-icon info-icon-small'>ℹ️</span>
            </button>
            <button class='map-icon-btn map-btn-info' data-action='zoom-out' data-tooltip='Zoom Out: Aleja la vista del mapa. También puedes usar la rueda del mouse o Ctrl - para alejar.'>
              - <span class='info-icon info-icon-small'>ℹ️</span>
            </button>
            <button class='map-icon-btn map-btn-info' data-action='reset-view' data-tooltip='Reset View: Restablece el zoom al 100% y centra el mapa en su posición original.'>
              Reset <span class='info-icon info-icon-small'>ℹ️</span>
            </button>
          </div>
          <div class='map-toolbar-center'>
            <div id='mapZoomBadge' class='map-zoom-badge'>100%</div>
            <div id='mapMetaBadge' class='map-meta-badge'>Sin mapa</div>
            <div id='mapSelectionBadge' class='map-meta-badge map-selection-badge'>0 seleccionadas</div>
          </div>
          <div class='map-toolbar-right'>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-nombres-areas' data-tooltip='Nombres de Áreas: Muestra u oculta los nombres de las áreas en el mapa.'>
              Nombres
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-puntos-repuestos' data-tooltip='Puntos de Repuestos: Muestra u oculta los marcadores de repuestos en el mapa.'>
              Puntos
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-grid' data-tooltip='Rejilla: Activa/desactiva la cuadrícula de referencia en el mapa. Útil para alinear áreas con precisión.'>
              Rejilla <span class='info-icon'>i</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-minimap' data-tooltip='Minimap: Muestra un minimapa en la esquina para navegación rápida. Click en el minimap para saltar a esa ubicación.'>
              🗺️ Minimap <span class='info-icon'>ℹ️</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-rulers' data-tooltip='Reglas: Muestra reglas laterales con medidas en píxeles. Ayuda a medir distancias y posicionar elementos con exactitud.'>
              📏 Reglas <span class='info-icon'>ℹ️</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-multiselect' id='mapMultiSelectBtn' data-tooltip='Selección Múltiple: Activa modo para seleccionar múltiples áreas. Click en áreas para seleccionar, Ctrl+A para todas, Escape para limpiar, Delete para eliminar.'>
              🎯 Selección Múltiple <span class='info-icon'>ℹ️</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='toggle-reshape' id='mapReshapeBtn' data-tooltip='Modo Edición: Edita ubicaciones de áreas y repuestos. Arrastra puntos de áreas, click en bordes para agregar, selecciona punto + Delete para eliminar. Arrastra repuestos para reubicarlos.'>
              ✏️ Editar Ubicaciones <span class='info-icon'>ℹ️</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info map-btn-batch-hidden' data-action='batch-operations' id='mapBatchBtn' data-tooltip='Operaciones en Lote: Aplica cambios masivos a áreas seleccionadas (categoría, color, opacidad). Ctrl+B para abrir.'>
              ⚙️ Operaciones <span class='info-icon'>ℹ️</span>
            </button>
            <button class='map-btn map-btn--ghost map-btn-info' data-action='recenter' data-tooltip='Centrar: Restaura la vista del mapa a su posición y zoom inicial. Útil cuando te pierdes navegando.'>
              Centrar <span class='info-icon'>ℹ️</span>
            </button>
          </div>
        </div>
        <div class='map-canvas-stage'>
          <canvas id='mapCanvas' class='map-canvas'></canvas>
          <div id='mapHint' class='map-hint hidden'></div>
          <div id='mapTooltip' class='map-tooltip hidden'></div>
          <!-- 🗺️ NUEVO: Minimap para navegación rápida -->
          <div id='mapMinimapContainer' class='map-minimap-container'>
            <canvas id='mapMinimap' class='map-minimap-canvas'></canvas>
            <div id='mapMinimapViewport' class='map-minimap-viewport'></div>
          </div>
        </div>
        <!-- ❌ ELIMINADO: Footer con mensaje inútil y botón que no sirve -->
      </div>
    </div>

    <div id='mapModalOverlay' class='map-modal hidden'>
      <div class='map-modal-content'>
        <div class='map-modal-header'>
          <h3 id='mapModalTitle'>Nuevo mapa</h3>
          <button id='mapModalClose' class='map-icon-btn'>X</button>
        </div>
        <div id='mapModalBody' class='map-modal-body'></div>
      </div>
    </div>
  </div>

  <!-- TAB STATS -->
  <div id="stats" class="tab-content">
    <h2 class="stats-title">Estadísticas y Métricas de Decisión</h2>
    <div class="stats-grid" id="statsGrid"></div>
    <div id="statsDetails" class="stats-details"></div>
  </div>

  <!-- TAB VALORES -->
  <div id="valores" class="tab-content">
    <h2 class="valores-title">
      Desglose Detallado de Valores del Inventario
    </h2>
    
    <!-- Resumen General -->
    <div id="valoresResumen" class="valores-resumen"></div>
    
    <!-- Tabs de Valores -->
    <div class="valores-tabs-container">
      <button onclick="app.switchValoresTab('area')" id="tabArea" class="tab-valores active">
        Por Área
      </button>
      <button onclick="app.switchValoresTab('equipo')" id="tabEquipo" class="tab-valores">
        Por Equipo
      </button>
      <button onclick="app.switchValoresTab('tipo')" id="tabTipo" class="tab-valores">
        Por Tipo
      </button>
      <button onclick="app.switchValoresTab('top')" id="tabTop" class="tab-valores">
        Top 10
      </button>
    </div>
    
    <!-- Contenido de Tabs -->
    <div id="valoresTabContent"></div>
  </div>

  <!-- TAB CONFIGURACIÓN -->
  <div id="configuracion" class="tab-content">
    <h2 class="config-title">Configuración</h2>
    
    <div class="config-grid">
      <!-- ALMACENAMIENTO -->
      <div id="storage-config-container" class="config-card">
        <div id="storage-config-content"></div>
      </div>

      <!-- EXPORTACIÓN Y REPORTES -->
      <div class="config-card">
        <h3 onclick="toggleConfigSection('export-config')" class="config-section-header">
          <span id="export-config-icon">▶</span>
          <span>📊 Exportación y Reportes</span>
        </h3>
        
        <div id="export-config-content" class="config-section-content">
          <div class="config-buttons-container">
            <button onclick="configuracion.exportarHTMLConDatosEmbebidos()" class="btn config-btn-mobile">
              📱 Exportar HTML para Móvil
            </button>

            <button onclick="configuracion.exportarExcel()" class="btn btn-primary config-btn-full">
              📊 Exportar a Excel
            </button>
            
            <button onclick="configuracion.mostrarOpcionesPDF()" class="btn config-btn-pdf">
              📄 Exportar a PDF
            </button>
          </div>
        </div>
      </div>

      <!-- SISTEMA DE BACKUPS Y RESPALDOS -->
      <div class="config-card">
        <h3 onclick="toggleConfigSection('backup-config')" class="config-section-header">
          <span id="backup-config-icon">▶</span>
          <span>🔄 Sistema de Backups y Respaldos</span>
        </h3>
        
        <div id="backup-config-content" class="config-section-content">
          <!-- Estructura de carpetas -->
          <div class="backup-structure">
            <strong class="backup-structure-title">📂 Estructura de Backups:</strong><br>
            <div class="backup-structure-path">
              INVENTARIO_STORAGE/<br>
              ├── <strong class="backup-file-name">repuestos.json</strong> <span class="backup-file-hint">← Pegar aquí JSON de repuestos</span><br>
              ├── <strong class="backup-file-name">mapas.json</strong> <span class="backup-file-hint">← Pegar aquí JSON de mapas</span><br>
              ├── <strong class="backup-file-name">zonas.json</strong> <span class="backup-file-hint">← Pegar aquí JSON de áreas</span><br>
              ├── imagenes/ <span class="backup-file-hint backup-file-hint-special">← Copiar aquí carpeta de imágenes completa</span><br>
              └── backups/<br>
              &nbsp;&nbsp;&nbsp;&nbsp;└── automaticos/ <span class="backup-file-name">← Backups automáticos (5 últimos)</span>
            </div>
            <div class="backup-manual-guide">
              <strong class="backup-manual-title">💡 Para actualizar manualmente:</strong><br>
              <small class="backup-guide-text">
                1. Pega el JSON en el archivo correspondiente (repuestos.json, mapas.json, zonas.json)<br>
                2. Copia las imágenes a la carpeta imagenes/<br>
                3. Recarga la app (F5) para ver los cambios<br>
                4. La app creará un backup automático al guardar
              </small>
          </div>
        </div>
        
        <!-- 🔄 ESTADO DEL SISTEMA DE BACKUP AUTOMÁTICO -->
        <div id="backupStatusPanel" class="backup-status-panel-container">
          <div class="backup-status-header">
            <div id="backupStatusIcon" class="backup-status-icon">🟢</div>
            <div class="backup-status-content">
              <div class="backup-status-title">Sistema de Backup Automático</div>
              <div id="backupStatusText" class="backup-status-text">Inicializando...</div>
            </div>
          </div>
          
          <div class="backup-metrics-grid">
            <div class="backup-metric-card">
              <div class="backup-metric-label">Último backup</div>
              <div id="backupLastTime" class="backup-metric-value">---</div>
            </div>
            <div class="backup-metric-card">
              <div class="backup-metric-label">Inactividad</div>
              <div id="backupCountdown" class="backup-metric-value">---</div>
            </div>
            <div class="backup-metric-card">
              <div class="backup-metric-label">Próximo backup</div>
              <div id="backupNextTime" class="backup-metric-value">Al detectar inactividad</div>
            </div>
          </div>
          
          <div id="backupPendingChanges" class="backup-pending-changes">
            <small class="config-small-text">
              ⚠️ <strong>Hay cambios pendientes</strong> - Se creará backup cuando el sistema detecte 1 minuto de inactividad
            </small>
          </div>
        </div>
        
        <div class="config-buttons-container">
          <button onclick="configuracion.mostrarGestionBackups()" class="btn btn-primary config-btn-full">
            📜 Ver Historial de Backups Automáticos
          </button>
          
          <button onclick="configuracion.crearBackupManual()" class="btn btn-success config-btn-full">
            💾 Crear Backup Manual Ahora
          </button>
          
          <div class="config-divider">
            <small class="config-small-text">
              <strong>💡 Respaldo Completo ZIP:</strong> Incluye datos + mapas + imágenes. Ideal para migrar entre versiones o copiar toda la carpeta backups/ a otra instalación.
            </small>
            
            <button onclick="configuracion.exportarRespaldoCompleto()" class="btn config-btn-warning">
              📦 Crear Respaldo Completo ZIP
            </button>
            
            <button onclick="configuracion.cargarRespaldoCompleto()" class="btn config-btn-info">
              📥 Cargar Respaldo Completo ZIP
            </button>
          </div>
          
          <div class="config-divider config-divider-margin">
            <small class="config-small-text">
              <strong>🚀 Exportar App Portable Completa:</strong> Genera un ZIP con toda la aplicación y tus datos para llevarlo a otro PC.
            </small>
            
            <button onclick="configuracion.exportarAppCompleta()" class="btn config-btn-gradient">
              📦 Exportar App Portable Completa
            </button>
          </div>
        </div>
        
        <div class="config-success-note">
          <small class="config-small-text config-small-text-line-height">
            <strong>✅ Sistema de Backups Automáticos COMPLETOS:</strong><br>
            • Se crean automáticamente al guardar cambios<br>
            • <strong>Incluyen JSON + TODAS las imágenes</strong><br>
            • Se mantienen los últimos 5 backups completos<br>
            • El más antiguo se elimina automáticamente (JSON + imágenes)<br>
            • <strong>Restauración automática:</strong> Datos + Imágenes en un solo click<br>
            • <strong>Para migrar:</strong> Copia toda la carpeta <code class="config-inline-code">INVENTARIO_STORAGE/backups/automaticos/</code> a la nueva versión
          </small>
        </div>
        </div> <!-- Fin backup-config-content -->
      </div>
    </div>

    <!-- 🆕 GESTIÓN DE JERARQUÍA ORGANIZACIONAL -->
    <div class="jerarquia-config-container">
      <div onclick="toggleConfigSection('jerarquia-config')" class="jerarquia-config-header">
        <div class="jerarquia-config-header-content">
          <span id="jerarquia-config-icon">▶</span>
          <h3 class="jerarquia-config-title">
            🏢 Gestión de Jerarquía Organizacional
          </h3>
        </div>
        <button id="btnGuardarJerarquia" onclick="event.stopPropagation(); app.guardarCambiosJerarquia()" 
                class="btn btn-success jerarquia-save-btn">
          💾 Guardar Cambios
        </button>
      </div>
      
      <div id="jerarquia-config-content" class="config-section-content">
        <!-- Contenedor del árbol jerárquico -->
        <div id="jerarquiaTreeContainer" class="jerarquia-tree-container">
        <!-- Se llenará dinámicamente -->
      </div>
      </div> <!-- Fin jerarquia-config-content -->
    </div>

    <!-- GESTIÓN DE LISTAS DESPLEGABLES -->
    <div class="listas-config-container">
      <h3 onclick="toggleConfigSection('listas-config')" class="config-section-header">
        <span id="listas-config-icon">▶</span>
        <span>📋 Gestión de Listas de Autocompletado</span>
      </h3>
      
      <div id="listas-config-content" class="config-section-content">
        <p class="listas-config-description">
          Administra los valores de autocompletado.
        </p>

        <div class="listas-grid">
        
        <!-- TIPOS -->
        <div class="lista-card">
          <h4 class="lista-title">
            Tipos de Repuesto
          </h4>
          <div id="listaTipo" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoTipo" placeholder="Nuevo tipo..." class="lista-input">
            <button onclick="app.agregarItemLista('tipo')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- ÁREA GENERAL - NIVEL 2 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n2">N2</span>
            Áreas Generales
          </h4>
          <div id="listaAreaGeneral" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoAreaGeneral" placeholder="Nueva área..." class="lista-input">
            <button onclick="app.agregarItemLista('areaGeneral')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- SUB-ÁREA - NIVEL 3 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n3">N3</span>
            Sub-Áreas
          </h4>
          <div id="listaSubArea" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoSubArea" placeholder="Nueva sub-área..." class="lista-input">
            <button onclick="app.agregarItemLista('subArea')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- SISTEMA/EQUIPO - NIVEL 4 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n4">N4</span>
            Sistemas/Equipos
          </h4>
          <div id="listaSistemaEquipo" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoSistemaEquipo" placeholder="Nuevo sistema..." class="lista-input">
            <button onclick="app.agregarItemLista('sistemaEquipo')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- SUB-SISTEMA - NIVEL 5 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n5">N5</span>
            Sub-Sistemas
          </h4>
          <div id="listaSubSistema" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoSubSistema" placeholder="Nuevo sub-sistema..." class="lista-input">
            <button onclick="app.agregarItemLista('subSistema')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- SECCIÓN - NIVEL 6 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n6">N6</span>
            Secciones
          </h4>
          <div id="listaSeccion" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoSeccion" placeholder="Nueva sección..." class="lista-input">
            <button onclick="app.agregarItemLista('seccion')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

        <!-- SUB-SECCIÓN - NIVEL 7 -->
        <div class="lista-card">
          <h4 class="lista-title">
            <span class="lista-badge lista-badge-n7">N7</span>
            Sub-Secciones
          </h4>
          <div id="listaSubSeccion" class="lista-content">
            <!-- Se llenará dinámicamente -->
          </div>
          <div class="lista-input-group">
            <input type="text" id="nuevoSubSeccion" placeholder="Nueva sub-sección..." class="lista-input">
            <button onclick="app.agregarItemLista('subSeccion')" class="btn btn-success lista-add-btn">
              +
            </button>
          </div>
        </div>

      </div>
      </div> <!-- Fin listas-config-content -->
    </div>

    <!-- 🗺️ CATEGORÍAS DE ÁREAS DEL MAPA -->
    <div class="config-section">
      <div class="config-section-header-row">
        <div onclick="toggleConfigSection('herramientas-config')" class="config-section-clickable">
          <div class="config-section-title-row">
            <span id="herramientas-config-icon">▶</span>
            <h3 class="config-section-title">
              🗺️ Categorías de Áreas del Mapa
            </h3>
          </div>
        </div>
        <button onclick="event.stopPropagation(); app.agregarNuevaCategoria()" 
                class="config-btn-add-category">
          <span class="config-btn-icon">➕</span> Nueva Categoría
        </button>
      </div>
      
      <div id="herramientas-config-content" class="config-section-content-hidden">
        <p class="config-description">
          Gestiona las categorías que se pueden asignar a las áreas del mapa
        </p>

        <div class="categorias-container">
        <div id="listaCategoriasAreas" class="categorias-grid">
          <!-- Se llenará dinámicamente -->
        </div>
        
        <div id="mensajeNoCategoriasAreas" class="mensaje-no-categorias">
          <div class="mensaje-no-categorias-icon">📂</div>
          <p class="mensaje-no-categorias-text">No hay categorías configuradas</p>
          <small class="mensaje-no-categorias-small">Haz clic en "Nueva Categoría" para agregar una</small>
        </div>
      </div>

      <!-- Información sobre sincronización -->
      <div class="config-info-box">
        <div class="config-info-content">
          <span class="config-info-icon">💡</span>
          <div>
            <p class="config-info-title">
              Sincronización Automática
            </p>
            <p class="config-info-description">
              Las categorías se sincronizan automáticamente con los mapas. Al editar una categoría, todos los mapas se actualizarán instantáneamente.
              Las categorías eliminadas se removerán de las áreas que las usen.
            </p>
          </div>
        </div>
      </div>
      </div> <!-- Fin herramientas-config-content -->
    </div>
  </div>
</div>

<!-- MODAL FORMULARIO -->
<div class="modal" id="modal">
  <div class="modal-content">
    <button class="modal-close" onclick="app.closeModal()">×</button>
    <div class="modal-title" id="modalTitle">Agregar Repuesto</div>
    
    <form id="repuestoForm" onsubmit="app.saveRepuesto(event)" class="modal-form">
      <input type="hidden" id="repuestoId">
      
      <!-- Fila 1: Códigos (3 columnas en pantallas grandes) -->
      <div class="form-row-triple">
        <div class="form-group">
          <label>Código SAP: *</label>
          <input type="text" class="form-control" id="codSAP" list="codSAPDatalist" required placeholder="Ej: SAP12345">
          <datalist id="codSAPDatalist">
            <option value="Pendiente">Pendiente</option>
          </datalist>
        </div>
        
        <div class="form-group autocomplete-container">
          <label>Cód. Proveedor:</label>
          <input type="text" class="form-control" id="codProv" autocomplete="off" placeholder="Ej: PROV-001">
          <div class="autocomplete-list" id="autocomplete-codProv"></div>
        </div>
        
        <div class="form-group autocomplete-container">
          <label>Tipo:</label>
          <input type="text" class="form-control" id="tipo" autocomplete="off" placeholder="Ej: Filtro">
          <div class="autocomplete-list" id="autocomplete-tipo"></div>
        </div>
      </div>
      
      <!-- Fila 1.5: Categoría -->
      <div class="form-group">
        <label>Categoría: *</label>
        <select class="form-control form-categoria-select" id="categoria" required onchange="app.mostrarEjemplosCategoria(this.value)" aria-label="Seleccionar categoría del repuesto">
          <option value="">Seleccionar categoría...</option>
          <option value="Repuesto">REPUESTO</option>
          <option value="Insumo">INSUMO</option>
          <option value="Herramienta">HERRAMIENTA</option>
          <option value="EPP">EPP</option>
          <option value="Químico">QUÍMICO</option>
        </select>
        <small id="ejemplosCategoria" class="form-ejemplos-small">
          Selecciona una categoría para ver ejemplos
        </small>
      </div>
      
      <!-- Fila 2: Descripción (ancho completo) -->
      <div class="form-group">
        <label>Nombre/Descripción: *</label>
        <input type="text" class="form-control" id="nombre" required placeholder="Descripción detallada del repuesto">
      </div>
      
      <!-- UBICACIONES MÚLTIPLES -->
      <div class="ubicaciones-section">
        <div class="ubicaciones-header">
          <h4 class="ubicaciones-title">
            Ubicaciones del Repuesto
          </h4>
          <button type="button" onclick="app.agregarUbicacion()" class="btn btn-success btn-agregar-ubicacion">
            + Agregar Ubicación
          </button>
          
          <!-- 🧪 INDICADOR DE VERSIÓN (temporal para pruebas) -->
          <div id="versionIndicator" class="version-indicator">
            <!-- Se llenará dinámicamente -->
          </div>
        </div>
        
        <div class="ubicaciones-hint">
          💡 <strong>Múltiples ubicaciones:</strong> Puedes agregar varias ubicaciones si el repuesto se usa en diferentes máquinas o áreas.
        </div>
        
        <!-- Contenedor de ubicaciones -->
        <div id="ubicacionesContainer">
          <!-- Se llenarán dinámicamente las ubicaciones -->
        </div>
      </div>
      
      <!-- Fila 4: Stock y Precio (5 columnas) -->
      <div class="form-stock-grid">
        <div class="form-group">
          <label>Stock Actual: *</label>
          <input type="number" class="form-control" id="cantidad" min="0" required placeholder="0">
        </div>
        
        <div class="form-group">
          <label>Instalados:</label>
          <input type="number" class="form-control" id="cantidadInstalada" min="0" value="0" placeholder="0" title="Cantidad de repuestos actualmente instalados/en uso">
        </div>
        
        <div class="form-group">
          <label>Mínimo: *</label>
          <input type="number" class="form-control" id="minimo" min="0" value="5" required placeholder="5">
        </div>
        
        <div class="form-group">
          <label>Óptimo:</label>
          <input type="number" class="form-control" id="optimo" min="0" value="10" placeholder="10">
        </div>
        
        <div class="form-group precio-info">
          <label>Precio ($):</label>
          <input type="number" class="form-control" id="precio" min="0" step="0.01" value="0" placeholder="0.00">
        </div>
      </div>
      
      <small class="form-hint-small">
        💡 <strong>Instalados:</strong> Cantidad actualmente en uso en equipos/máquinas. <strong>Óptimo:</strong> Cantidad ideal recomendada en inventario.
      </small>
      
      <!-- Datos Técnicos Específicos -->
      <div class="form-group">
        <label class="form-label-row">
          <span>Datos Técnicos Específicos:</span>
          <small class="form-label-optional">(Opcional - Para motores, cintas, etc.)</small>
        </label>
        <textarea class="form-control form-textarea-tech" id="datosTecnicos" rows="3" placeholder="Ej: Motor 0.75 kW, 380V, 1400 RPM, IP55&#10;Marca: WEG, Modelo: W22&#10;Rodamientos: 6204 y 6205"></textarea>
        <small class="form-textarea-hint">
          Puedes incluir: potencia, voltaje, RPM, marca, modelo, dimensiones, especificaciones técnicas, etc.
        </small>
      </div>
      
      <!-- Sección Multimedia Compacta (2 columnas) -->
      <div class="form-multimedia-grid">
        <div class="form-group">
          <label class="form-label-space-between">
            <span>Imágenes</span>
            <small id="image-upload-mode" class="form-upload-mode" title="Optimización automática WebP">WebP Auto</small>
          </label>
          
          <!-- Botón de selección de imágenes mejorado -->
          <div class="image-upload-zone" onclick="document.getElementById('imagenFile').click()">
            <div class="upload-icon">📷</div>
            <div class="upload-text">Click para seleccionar imágenes</div>
            <div class="upload-hint">Formatos: JPG, PNG, WebP (máx. 10MB)</div>
          </div>
          
          <!-- Input de Imágenes (oculto) -->
          <input type="file" 
                 class="form-input-hidden" 
                 id="imagenFile"
                 accept="image/*" 
                 multiple 
                 onchange="app.handleImageWithOptimizer(event)"
                 aria-label="Seleccionar imágenes">
          
          <div id="imagePreview" class="multimedia-preview multimedia-preview-margin"></div>
        </div>
        
        <div class="form-group">
          <label class="form-label-margin">Documentos</label>
          <input type="file" class="form-control form-input-file" id="documentos" accept=".pdf,.doc,.docx,.xls,.xlsx,video/*" multiple onchange="app.handleMultimedia(event, 'document')" aria-label="Seleccionar documentos">
          <div id="documentsList" class="documents-list"></div>
        </div>
      </div>
      
      <!-- Modal Optimizador de Imágenes -->
      <div id="optimizerModal" class="optimizer-modal">
        <div class="optimizer-content">
          <div class="optimizer-header">
            <h3>Optimizador de Imágenes</h3>
            <button type="button" class="optimizer-close" onclick="app.closeOptimizer()">×</button>
          </div>
          
          <div class="optimizer-body">
            <div class="optimizer-preview">
              <div class="preview-original">
                <h4>Original</h4>
                <img id="optimizerOriginal" src="" alt="Original">
                <div class="preview-info">
                  <span id="originalSize">-</span>
                  <span id="originalDimensions">-</span>
                </div>
              </div>
              
              <div class="preview-arrow">→</div>
              
              <div class="preview-optimized">
                <h4>Optimizada</h4>
                <img id="optimizerOptimized" src="" alt="Optimizada">
                <div class="preview-info">
                  <span id="optimizedSize">-</span>
                  <span id="optimizedDimensions">-</span>
                </div>
                <div class="savings-badge" id="savingsBadge">
                  Ahorro: <strong>0%</strong>
                </div>
              </div>
            </div>
            
            <div class="optimizer-controls">
              <div class="control-group">
                <label>Tamaño de optimización:</label>
                <div class="size-options">
                  <button type="button" class="size-btn" data-size="800" onclick="app.setOptimizeSize(800)">
                    <span>Pequeño</span>
                    <small>800px</small>
                  </button>
                  <button type="button" class="size-btn active" data-size="1200" onclick="app.setOptimizeSize(1200)">
                    <span>Mediano</span>
                    <small>1200px</small>
                  </button>
                  <button type="button" class="size-btn" data-size="1600" onclick="app.setOptimizeSize(1600)">
                    <span>Grande</span>
                    <small>1600px</small>
                  </button>
                  <button type="button" class="size-btn" data-size="original" onclick="app.setOptimizeSize('original')">
                    <span>Original</span>
                    <small>Sin redimensionar</small>
                  </button>
                </div>
              </div>
              
              <div class="control-group">
                <label>Calidad WebP: <span id="qualityValue">85%</span></label>
                <input type="range" id="qualitySlider" min="60" max="95" value="85" 
                       oninput="app.updateQuality(this.value)">
                <small>60% (máxima compresión) - 95% (máxima calidad)</small>
              </div>
            </div>
          </div>
          
          <div class="optimizer-footer">
            <button type="button" class="btn btn-secondary" onclick="app.skipOptimization()">
              Usar Original
            </button>
            <button type="button" class="btn btn-success" onclick="app.applyOptimization()">
              Aplicar Optimización
            </button>
          </div>
        </div>
      </div>
      
      <!-- Botones de acción -->
      <div class="form-actions">
        <button type="submit" id="btnGuardarRepuesto" class="btn btn-success btn-save-main">
          <span class="btn-text">💾 Guardar</span>
          <span class="btn-loading btn-loading-hidden">
            <span class="spinner-small"></span> Guardando...
          </span>
        </button>
        <button type="button" class="btn btn-secondary btn-cancel-modal" onclick="app.closeModal()">❌ Cancelar</button>
      </div>
    </form>
  </div>
</div>

<!-- LIGHTBOX -->
<div class="lightbox" id="lightbox">
  <button class="lightbox-close" onclick="app.closeLightbox()">×</button>
  <button class="lightbox-nav lightbox-prev" onclick="app.lightboxPrev()">‹</button>
  <button class="lightbox-nav lightbox-next" onclick="app.lightboxNext()">›</button>
  <div class="lightbox-content" id="lightboxContent"></div>
  <div class="lightbox-counter" id="lightboxCounter"></div>
</div>

<!-- MODAL JERARQUÍA VISUAL CASCADA -->
<div id="modalJerarquia" class="modal-overlay" onclick="if(event.target.id === 'modalJerarquia') this.style.display='none'">
  <div class="modal-container" onclick="event.stopPropagation()">
    
    <!-- Header con gradiente -->
    <div class="modal-header">
      <h3 class="modal-title">
        <span class="modal-icon">📍</span>
        <span>Ubicación del Repuesto</span>
      </h3>
      <button onclick="document.getElementById('modalJerarquia').style.display='none'" 
              class="modal-close-btn">
        ×
      </button>
    </div>
    
    <!-- Contenido de la jerarquía cascada -->
    <div id="jerarquiaContent" class="modal-content">
      <!-- Se llenará dinámicamente con la estructura de árbol -->
    </div>
  </div>
</div>

<!-- MODAL ESTADÍSTICAS -->
<div id="modalEstadisticas" class="modal-overlay" onclick="if(event.target.id === 'modalEstadisticas') this.style.display='none'">
  <div class="modal-container modal-container-large" onclick="event.stopPropagation()">
    
    <!-- Header -->
    <div class="modal-header-stats">
      <div class="modal-header-row">
        <h2 class="modal-title-large">
          <span class="modal-icon-large">📊</span>
          <span>Estadísticas de Almacenamiento</span>
        </h2>
        <button onclick="document.getElementById('modalEstadisticas').style.display='none'" 
                class="modal-close-btn-large">
          ×
        </button>
      </div>
    </div>
    
    <!-- Content con scroll -->
    <div id="estadisticasContent" class="modal-content-flex">
      <!-- Contenido dinámico -->
    </div>
    
    <!-- Footer -->
    <div class="modal-footer">
      <button onclick="document.getElementById('modalEstadisticas').style.display='none'" class="btn btn-primary modal-footer-btn">
        ✅ Cerrar
      </button>
    </div>
  </div>
</div>

<!-- MODAL CASCADA JERÁRQUICA -->
<div id="modalCascada" class="modal-overlay modal-overlay-highest" onclick="if(event.target.id === 'modalCascada') this.style.display='none'">
  <div class="modal-container modal-container-xlarge" onclick="event.stopPropagation()">
    
    <!-- Header simplificado -->
    <div class="modal-header-cascada">
      <h3 class="modal-title-cascada">
        🔍 Cascada de Áreas
      </h3>
      <button onclick="document.getElementById('modalCascada').style.display='none'" 
              class="modal-close-btn-simple">
        ×
      </button>
    </div>
    
    <!-- Barra de búsqueda y botones -->
    <div class="cascada-toolbar">
      <!-- Info de elementos -->
      <div id="cascadaStats" class="cascada-stats">
        <span>📍 <strong id="statsAreas">0</strong> áreas</span>
        <span>📌 <strong id="statsMarcadores">0</strong> marcadores</span>
        <span>⚠️ <strong id="statsSinJerarquia">0</strong> sin nivel asignado</span>
      </div>
      
      <input 
        id="cascadaSearchInput" 
        type="text" 
        placeholder="🔍 Buscar área o marcador..."
        class="cascada-search-input"
        onkeyup="mapController.filterCascada(this.value)"
      />
      
      <div class="cascada-buttons">
        <button onclick="mapController.expandAllCascada()" class="cascada-btn">
          ▼ Expandir todo
        </button>
        <button onclick="mapController.collapseAllCascada()" class="cascada-btn">
          ▶ Colapsar todo
        </button>
        <button onclick="mapController.toggleMostrarSoloConJerarquia()" id="btnToggleVacias" class="cascada-btn">
          👁️ Ocultar vacías
        </button>
        <button onclick="mapController.exportCascada()" class="cascada-btn">
          💾 Exportar
        </button>
      </div>
    </div>
    
    <!-- Content con scroll -->
    <div id="cascadaContent" class="modal-content-cascada">
      <!-- Contenido dinámico generado por renderHierarchyTree -->
    </div>
    
    <!-- Footer simplificado -->
    <div class="modal-footer-simple">
      <button onclick="document.getElementById('modalCascada').style.display='none'" class="modal-footer-btn-simple">
        Cerrar
      </button>
    </div>
  </div>
</div>

<script>
const EMBEDDED_DATA = {
  version: '1.0-mobile',
  lastUpdate: new Date().toISOString(),
  platform: 'mobile-embedded',
  note: 'Datos sin multimedia - Solo texto y números para máxima compatibilidad',
  repuestos: []
};

class IndexedDBImageManager {
  constructor() {
    this.dbName = 'InventarioImagenes';
    this.dbVersion = 1;
    this.storeName = 'images';
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => {
        console.error('❌ Error al abrir IndexedDB:', request.error);
        reject(request.error);
      };
      
      request.onsuccess = () => {
        this.db = request.result;
        console.log('✅ IndexedDB inicializada correctamente');
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
          objectStore.createIndex('repuestoId', 'repuestoId', { unique: false });
          objectStore.createIndex('timestamp', 'timestamp', { unique: false });
          console.log('✅ Object store "images" creado');
        }
      };
    });
  }

  async saveImage(imageId, repuestoId, file) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        
        const imageData = {
          id: imageId,
          repuestoId: repuestoId,
          data: reader.result, // base64 string
          type: file.type,
          size: file.size,
          name: file.name,
          timestamp: Date.now()
        };
        
        const request = store.put(imageData);
        
        request.onsuccess = () => {
          console.log(`✅ Imagen guardada en IndexedDB: ${imageId}`);
          resolve(true);
        };
        
        request.onerror = () => {
          console.error(`❌ Error al guardar imagen ${imageId}:`, request.error);
          reject(request.error);
        };
      };
      
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(file); // Convierte a base64
    });
  }

  async getImage(imageId) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(imageId);
      
      request.onsuccess = () => {
        if (request.result) {
          const blob = this.base64ToBlob(request.result.data, request.result.type);
          const blobUrl = URL.createObjectURL(blob);
          resolve({
            url: blobUrl,
            blob: blob,
            metadata: {
              type: request.result.type,
              size: request.result.size,
              name: request.result.name,
              timestamp: request.result.timestamp
            }
          });
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  async getImagesByRepuesto(repuestoId) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const index = store.index('repuestoId');
      const request = index.getAll(repuestoId);
      
      request.onsuccess = () => {
        const images = request.result.map(img => ({
          id: img.id,
          url: this.base64ToBlob(img.data, img.type),
          metadata: {
            type: img.type,
            size: img.size,
            name: img.name,
            timestamp: img.timestamp
          }
        }));
        resolve(images);
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  async deleteImage(imageId) {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(imageId);
      
      request.onsuccess = () => {
        console.log(`🗑️ Imagen eliminada de IndexedDB: ${imageId}`);
        resolve(true);
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  async getStorageStats() {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      
      request.onsuccess = () => {
        const images = request.result;
        const totalSize = images.reduce((acc, img) => acc + img.size, 0);
        const totalCount = images.length;
        
        resolve({
          count: totalCount,
          size: totalSize,
          sizeFormatted: this.formatBytes(totalSize),
          images: images.map(img => ({
            id: img.id,
            repuestoId: img.repuestoId,
            size: img.size,
            timestamp: img.timestamp
          }))
        });
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  async clearAll() {
    if (!this.db) await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.clear();
      
      request.onsuccess = () => {
        console.log('🗑️ Todas las imágenes eliminadas de IndexedDB');
        resolve(true);
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  base64ToBlob(base64, mimeType) {
    const byteString = atob(base64.split(',')[1]);
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeType });
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }
}

class FileSystemManager {
  constructor() {
    this.directoryHandle = null;
    this.imagesFolder = null;
    this.isFileSystemMode = false;
    this.folderPath = '';
    this.dbName = 'InventarioFS';
    this.dbVersion = 1;
  }

  // 🗺️ AGREGADO PARA COMPATIBILIDAD CON MAPSTORAGE
  get storageHandle() {
    return this.directoryHandle;
  }

  get isConnected() {
    return this.isFileSystemMode && !!this.directoryHandle;
  }
  // FIN AGREGADO PARA MAPSTORAGE

  async saveDirectoryHandle(handle) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const db = request.result;
        const transaction = db.transaction(['directories'], 'readwrite');
        const store = transaction.objectStore('directories');
        store.put({ id: 'main', handle: handle, timestamp: Date.now() });
        transaction.oncomplete = () => resolve(true);
        transaction.onerror = () => reject(transaction.error);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('directories')) {
          db.createObjectStore('directories', { keyPath: 'id' });
        }
      };
    });
  }

  async loadDirectoryHandle() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const db = request.result;
        const transaction = db.transaction(['directories'], 'readonly');
        const store = transaction.objectStore('directories');
        const getRequest = store.get('main');
        
        getRequest.onsuccess = () => {
          resolve(getRequest.result?.handle || null);
        };
        getRequest.onerror = () => reject(getRequest.error);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('directories')) {
          db.createObjectStore('directories', { keyPath: 'id' });
        }
      };
    });
  }

  async restoreFromPreviousSession() {
    try {
      const savedHandle = await this.loadDirectoryHandle();
      if (!savedHandle) {
        console.log('No hay carpeta guardada previamente');
        return false;
      }

      const permission = await savedHandle.queryPermission({ mode: 'readwrite' });
      
      if (permission === 'granted') {
        this.directoryHandle = savedHandle;
        await this.ensureImageFolder();
        this.folderPath = this.directoryHandle.name;
        this.isFileSystemMode = true;
        this.updateStatusIndicator(true, this.folderPath);
        console.log('✅ Sesión FileSystem restaurada automáticamente:', this.folderPath);
        return true;
      } else if (permission === 'prompt') {
        const newPermission = await savedHandle.requestPermission({ mode: 'readwrite' });
        if (newPermission === 'granted') {
          this.directoryHandle = savedHandle;
          await this.ensureImageFolder();
          this.folderPath = this.directoryHandle.name;
          this.isFileSystemMode = true;
          this.updateStatusIndicator(true, this.folderPath);
          console.log('✅ Permisos re-otorgados, sesión restaurada:', this.folderPath);
          return true;
        }
      }
      
      console.log('⚠️ Permisos denegados, necesita reactivar manualmente');
      return false;
    } catch (error) {
      console.error('Error restaurando sesión:', error);
      return false;
    }
  }

  updateStatusIndicator(connected, path = '') {
    const btn = document.getElementById('connectionBtn');
    const icon = document.getElementById('connectionIcon');

    if (btn && icon) {
      if (connected) {
        // 🟢 Verde con gradiente Neomorphism
        btn.style.background = 'linear-gradient(145deg, #10b981, #059669)';
        btn.style.color = 'white';
        btn.title = path ? `✓ Conectado: ${path}` : '✓ Conectado';
        icon.textContent = '✓';
      } else {
        // 🔴 Rojo con gradiente Neomorphism
        btn.style.background = 'linear-gradient(145deg, #ef4444, #dc2626)';
        btn.style.color = 'white';
        btn.title = '✗ No conectado';
        icon.textContent = '✗';
      }
    }
  }

  async selectFolder() {
    try {
      const selectedFolder = await window.showDirectoryPicker({ mode: 'readwrite' });
      console.log('📁 Carpeta seleccionada por usuario:', selectedFolder.name);
      
      let workingFolder = selectedFolder;
      let detectedPath = selectedFolder.name;
      
      if (selectedFolder.name === 'INVENTARIO_PORTABLE') {
        console.log('🔍 Detectado INVENTARIO_PORTABLE, buscando INVENTARIO_STORAGE dentro...');
        try {
          const storageFolder = await selectedFolder.getDirectoryHandle('INVENTARIO_STORAGE', { create: false });
          workingFolder = storageFolder;
          detectedPath = `${selectedFolder.name}/${storageFolder.name}`;
          console.log('✅ INVENTARIO_STORAGE encontrado automáticamente!');
        } catch (e) {
          console.warn('⚠️ INVENTARIO_STORAGE no encontrada, creándola...');
          const storageFolder = await selectedFolder.getDirectoryHandle('INVENTARIO_STORAGE', { create: true });
          workingFolder = storageFolder;
          detectedPath = `${selectedFolder.name}/${storageFolder.name}`;
          console.log('✅ INVENTARIO_STORAGE creada automáticamente!');
        }
      } else if (selectedFolder.name === 'INVENTARIO_STORAGE') {
        console.log('✅ INVENTARIO_STORAGE seleccionada directamente');
      } else {
        console.log('🔍 Buscando INVENTARIO_STORAGE dentro de', selectedFolder.name);
        try {
          const storageFolder = await selectedFolder.getDirectoryHandle('INVENTARIO_STORAGE', { create: false });
          workingFolder = storageFolder;
          detectedPath = `${selectedFolder.name}/${storageFolder.name}`;
          console.log('✅ INVENTARIO_STORAGE encontrado dentro de', selectedFolder.name);
        } catch (e) {
          console.log('ℹ️ INVENTARIO_STORAGE no encontrada, usando carpeta seleccionada como está');
        }
      }
      
      this.directoryHandle = workingFolder;
      await this.ensureImageFolder();
      
      await this.saveDirectoryHandle(this.directoryHandle);
      localStorage.setItem('fsDirectory', 'enabled');
      
      this.folderPath = detectedPath;
      localStorage.setItem('fsFolderName', this.folderPath);
      
      this.isFileSystemMode = true;
      console.log('✅ Sistema configurado con carpeta:', detectedPath);
      
      this.updateStatusIndicator(true, detectedPath);
      
      return true;
    } catch (error) {
      console.error('Error seleccionando carpeta:', error);
      this.updateStatusIndicator(false);
      return false;
    }
  }

  async ensureImageFolder() {
    try {
      this.imagesFolder = await this.directoryHandle.getDirectoryHandle('imagenes', { create: true });
      console.log('✅ Carpeta "imagenes" accesible:', this.imagesFolder);
      
      let count = 0;
      for await (const entry of this.imagesFolder.values()) {
        count++;
        if (count <= 3) {
          console.log(`   📸 Encontrado: ${entry.name}`);
        }
      }
      console.log(`   📊 Total de archivos en carpeta imagenes: ${count}`);
    } catch (error) {
      console.error('❌ Error accediendo a carpeta imagenes:', error);
      this.imagesFolder = null;
    }
  }

  async saveJSON(data) {
    if (!this.isFileSystemMode) {
      return false; // No está en modo FileSystem
    }
    try {
      const fileHandle = await this.directoryHandle.getFileHandle('inventario.json', { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      console.log('✅ JSON guardado en archivo: inventario.json');
      return true;
    } catch (error) {
      console.error('❌ Error guardando JSON en FileSystem:', error);
      return false;
    }
  }

  async saveImage(blob, filename) {
    if (!this.isFileSystemMode) return null;
    try {
      const fileHandle = await this.imagesFolder.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
      console.log('✅ Imagen guardada:', filename);
      return './imagenes/' + filename;
    } catch (error) {
      console.error('Error guardando imagen:', error);
      return null;
    }
  }

  /**
   * Guarda imagen en carpeta jerárquica según ubicación
   */
  async saveImageJerarquica(blob, filename, carpetaDestino) {
    if (!this.isFileSystemMode) return null;
    try {
      const fileHandle = await carpetaDestino.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
      console.log('✅ Imagen guardada en carpeta jerárquica:', filename);
      return filename;
    } catch (error) {
      console.error('Error guardando imagen en carpeta jerárquica:', error);
      return null;
    }
  }

  /**
   * Lee un archivo desde el File System Access API
   * @param {string|Array} imagePath - Ruta del archivo (string con / o array de segmentos)
   * @returns {Promise<Blob|null>} - Blob del archivo o null si falla
   */
  async readFile(imagePath) {
    if (!this.isFileSystemMode) {
      console.warn('⚠️ FileSystem no está activo');
      return null;
    }

    try {
      // Convertir path string a array de segmentos
      const segments = Array.isArray(imagePath) 
        ? imagePath 
        : String(imagePath || '').split('/').filter(Boolean);

      if (!segments.length) {
        console.warn('⚠️ Ruta de imagen vacía');
        return null;
      }

      // Navegar por la jerarquía de carpetas
      let currentDir = this.directoryHandle;
      
      for (let i = 0; i < segments.length - 1; i++) {
        const folderName = segments[i];
        currentDir = await currentDir.getDirectoryHandle(folderName, { create: false });
      }

      // Obtener el archivo final
      const fileName = segments[segments.length - 1];
      const fileHandle = await currentDir.getFileHandle(fileName, { create: false });
      const file = await fileHandle.getFile();
      
      return file;
    } catch (error) {
      console.error('❌ Error leyendo archivo:', imagePath, error);
      return null;
    }
  }

  async deleteImage(imagePath) {
    if (!this.isFileSystemMode) return false;
    try {
      const filename = imagePath.replace('./imagenes/', '').replace('imagenes/', '');
      
      if (!filename) {
        console.warn('⚠️ Nombre de archivo inválido:', imagePath);
        return false;
      }
      
      console.log(`🗑️ Intentando eliminar archivo: ${filename}`);
      
      await this.imagesFolder.removeEntry(filename);
      console.log(`✅ Archivo eliminado del FileSystem: ${filename}`);
      return true;
    } catch (error) {
      if (error.name === 'NotFoundError') {
        console.warn(`⚠️ Archivo no encontrado (ya estaba eliminado): ${imagePath}`);
        return true; // Considerar como éxito si ya no existe
      }
      console.error('❌ Error eliminando imagen del FileSystem:', error);
      return false;
    }
  }

  async deleteMultipleImages(imagePaths) {
    if (!this.isFileSystemMode) return { deleted: 0, failed: 0 };
    
    let deleted = 0;
    let failed = 0;
    
    console.log(`🗑️ Eliminando ${imagePaths.length} imágenes del FileSystem...`);
    
    for (const imagePath of imagePaths) {
      const success = await this.deleteImage(imagePath);
      if (success) {
        deleted++;
      } else {
        failed++;
      }
    }
    
    console.log(`✅ Eliminadas: ${deleted} | ❌ Fallidas: ${failed}`);
    return { deleted, failed };
  }

  async getAllImagesInFolder() {
    if (!this.isFileSystemMode) return [];
    
    try {
      const images = [];
      for await (const entry of this.imagesFolder.values()) {
        if (entry.kind === 'file') {
          images.push(entry.name);
        }
      }
      return images;
    } catch (error) {
      console.error('Error listando imágenes:', error);
      return [];
    }
  }

  async cleanOrphanImages(repuestos) {
    if (!this.isFileSystemMode) return { orphans: 0, deleted: 0, failed: 0, size: 0 };
    
    console.log('🔍 Buscando imágenes huérfanas...');
    
    const allImages = await this.getAllImagesInFolder();
    console.log(`📂 Total de imágenes en carpeta: ${allImages.length}`);
    
    const referencedImages = new Set();
    repuestos.forEach(r => {
      if (r.multimedia) {
        r.multimedia
          .filter(m => m.type === 'image' && m.isFileSystem && m.url)
          .forEach(m => {
            const filename = m.url.replace('./imagenes/', '').replace('imagenes/', '');
            referencedImages.add(filename);
          });
      }
    });
    console.log(`🔗 Imágenes referenciadas: ${referencedImages.size}`);
    
    const orphanImages = allImages.filter(img => !referencedImages.has(img));
    console.log(`🗑️ Imágenes huérfanas encontradas: ${orphanImages.length}`);
    
    if (orphanImages.length === 0) {
      return { orphans: 0, deleted: 0, failed: 0, size: 0 };
    }
    
    let totalSize = 0;
    for (const filename of orphanImages) {
      try {
        const fileHandle = await this.imagesFolder.getFileHandle(filename);
        const file = await fileHandle.getFile();
        totalSize += file.size;
      } catch (error) {
        console.warn(`⚠️ No se pudo leer tamaño de: ${filename}`);
      }
    }
    
    let deleted = 0;
    let failed = 0;
    
    for (const filename of orphanImages) {
      try {
        await this.imagesFolder.removeEntry(filename);
        deleted++;
        console.log(`✅ Eliminada huérfana: ${filename}`);
      } catch (error) {
        failed++;
        console.error(`❌ Error eliminando: ${filename}`, error);
      }
    }
    
    console.log(`✅ Limpieza completada: ${deleted} eliminadas, ${failed} fallidas`);
    console.log(`💾 Espacio liberado: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
    
    return { 
      orphans: orphanImages.length, 
      deleted, 
      failed, 
      size: totalSize 
    };
  }
}

const fsManager = new FileSystemManager();
const indexedDBManager = new IndexedDBImageManager();

if (!('showDirectoryPicker' in window)) {
  indexedDBManager.init().then(() => {
    console.log('📱 IndexedDB Manager inicializado para modo móvil');
  }).catch(err => {
    console.error('❌ Error al inicializar IndexedDB:', err);
  });
}

const globalBlobCache = new Map();

// Función para obtener o crear Blob URL con caché global
async function getCachedBlobUrl(filename, loadFunction) {
  if (globalBlobCache.has(filename)) {
    const cached = globalBlobCache.get(filename);
    console.log(`📦 [CACHÉ GLOBAL] Reutilizando: ${filename}`);
    return cached.url;
  }
  
  const url = await loadFunction();
  if (url) {
    // Guardar con referencia fuerte
    globalBlobCache.set(filename, {
      url: url,
      timestamp: Date.now(),
      filename: filename
    });
    console.log(`✅ [CACHÉ GLOBAL] Guardado: ${filename} (Total: ${globalBlobCache.size})`);
  }
  return url;
}

function activarModoFileSystem() {
  if (!('showDirectoryPicker' in window)) {
    alert('Tu navegador no soporta FileSystem Access API.\n\nPor favor usa:\n• Google Chrome 86+\n• Microsoft Edge 86+');
    return;
  }
  fsManager.selectFolder().then(ok => {
    if (ok) {
      document.getElementById('fsBadge').style.display = 'inline';
      alert('Almacenamiento Ilimitado activado!\n\nAhora puedes agregar INFINITAS imágenes.\nCarpeta: ' + fsManager.folderPath);
    }
  });
}

// FUNCIÓN TOGGLE PARA ACTIVAR/DESACTIVAR ALMACENAMIENTO ILIMITADO
function toggleModoFileSystem() {
  if (fsManager.isFileSystemMode) {
    // Si está activo, mostrar confirmación para desactivar
    const confirmar = confirm(
      'Almacenamiento Ilimitado ACTIVO\n\n' +
      '¿Deseas DESACTIVAR el almacenamiento ilimitado?\n\n' +
      'Se volverá al modo localStorage (límite 10MB)\n' +
      'Los datos guardados en la carpeta NO se perderán'
    );
    if (confirmar) {
      desactivarModoFileSystem();
    }
  } else {
    // Si está inactivo, activar
    activarModoFileSystem();
  }
}

// 🔴 FUNCIÓN PARA DESACTIVAR MODO FILESYSTEM
function desactivarModoFileSystem() {
  console.log('🔴 Desactivando modo FileSystem...');
  
  // Limpiar estado del FileSystemManager
  fsManager.isFileSystemMode = false;
  fsManager.directoryHandle = null;
  fsManager.imagesFolder = null;
  fsManager.folderPath = null;
  
  // Limpiar localStorage
  localStorage.removeItem('fsDirectory');
  localStorage.removeItem('fsFolderName');
  
  // Eliminar base de datos IndexedDB
  const deleteRequest = indexedDB.deleteDatabase(fsManager.dbName);
  deleteRequest.onsuccess = () => {
    console.log('✅ Base de datos IndexedDB eliminada');
  };
  deleteRequest.onerror = () => {
    console.warn('⚠️ No se pudo eliminar la base de datos IndexedDB');
  };
  
  // Actualizar indicador visual
  fsManager.updateStatusIndicator(false);
  document.getElementById('fsBadge').style.display = 'none';
  
  // Mostrar notificación
  if (typeof app !== 'undefined' && app.showToast) {
    app.showToast('🔴 Modo Carpeta DESACTIVADO - Volviendo a localStorage (límite 10MB)', 'error', 4000);
  } else {
    alert('🔴 Modo Carpeta DESACTIVADO\n\nAhora usarás localStorage con límite de 10MB');
  }
  
  console.log('✅ Modo FileSystem desactivado completamente');
}

/* ═══════════════════════════════════════════════════════════════════════════════
   🗺️ MAP STORAGE SERVICE - INTEGRADO DESDE APP_BASE (FASE 4A)
   ═══════════════════════════════════════════════════════════════════════════════
   Gestiona el almacenamiento de mapas y áreas en FileSystem con backups y logs.
   ═══════════════════════════════════════════════════════════════════════════════ */

class MapStorageService {
  constructor(fsManager) {
    this.fsManager = fsManager;
    this.maps = [];
    this.areas = []; // Antes 'zones' - Mantener compatibilidad con zonas.json
    this.maxBackups = 5;
    this.mapsFileName = 'mapas.json';
    this.areasFileName = 'zonas.json'; // IMPORTANTE: Mantener 'zonas.json' para compatibilidad con datos existentes
    this.logsDirName = 'logs';
    this.logFileName = 'mapas-history.log';
    this.mapImagesPath = ['imagenes', 'mapas'];
    this.backupMapPath = ['backups', 'mapas'];
    this.backupAreaPath = ['backups', 'zonas']; // IMPORTANTE: Mantener 'zonas' para compatibilidad
    this.initialized = false;
    this.logsDirHandle = null;
    this.backupMapsDir = null;
    this.backupAreasDir = null; // Antes 'backupZonesDir'
    this.mapImagesDir = null;
  }

  get rootHandle() {
    return this.fsManager ? this.fsManager.storageHandle : null;
  }

  setMaxBackups(value) {
    if (typeof value === 'number' && value >= 1) {
      this.maxBackups = Math.floor(value);
    }
  }

  async init(options = {}) {
    const { autoReconnect = true } = options;
    if (!this.fsManager) {
      return false;
    }

    if (!this.fsManager.isConnected && autoReconnect && typeof this.fsManager.restoreFromPreviousSession === 'function') {
      try {
        await this.fsManager.restoreFromPreviousSession();
      } catch (error) {
        console.warn('No se pudo restaurar la carpeta de FileSystem:', error);
      }
    }

    if (!this.fsManager.isConnected) {
      return false;
    }

    await this.ensureStructure();
    await Promise.all([this.loadMaps(), this.loadAreas()]);
    this.initialized = true;
    
    return true;
  }

  async ensureStructure() {
    const root = this.rootHandle;
    if (!root) {
      return;
    }

    this.mapImagesDir = await this.ensureDirectory(this.mapImagesPath);
    this.backupMapsDir = await this.ensureDirectory(this.backupMapPath);
    this.backupAreasDir = await this.ensureDirectory(this.backupAreaPath);
    this.logsDirHandle = await this.ensureDirectory([this.logsDirName]);

    await this.ensureJSONFile(this.mapsFileName, '[]');
    await this.ensureJSONFile(this.areasFileName, '[]'); // Archivo zonas.json para compatibilidad
    await this.ensureLogFile();
  }

  async ensureDirectory(pathSegments) {
    let current = this.rootHandle;
    if (!current) {
      return null;
    }

    for (const segment of pathSegments) {
      if (!segment) {
        continue;
      }
      current = await current.getDirectoryHandle(segment, { create: true });
    }

    return current;
  }

  async ensureJSONFile(fileName, defaultContent) {
    const root = this.rootHandle;
    if (!root) {
      return;
    }

    try {
      await root.getFileHandle(fileName);
    } catch (error) {
      if (error.name === 'NotFoundError') {
        const handle = await root.getFileHandle(fileName, { create: true });
        const writable = await handle.createWritable();
        await writable.write(defaultContent);
        await writable.close();
      } else {
        console.warn(`No se pudo asegurar ${fileName}:`, error);
      }
    }
  }

  async ensureLogFile() {
    if (!this.logsDirHandle) {
      return;
    }

    try {
      await this.logsDirHandle.getFileHandle(this.logFileName);
    } catch (error) {
      if (error.name === 'NotFoundError') {
        const handle = await this.logsDirHandle.getFileHandle(this.logFileName, { create: true });
        const writable = await handle.createWritable();
        await writable.write('');
        await writable.close();
      } else {
        console.warn('No se pudo asegurar el archivo de log:', error);
      }
    }
  }

  async loadMaps() {
    if (!this.fsManager || !this.fsManager.isConnected) {
      this.maps = [];
      return this.maps;
    }

    try {
      const fileHandle = await this.rootHandle.getFileHandle(this.mapsFileName, { create: true });
      const file = await fileHandle.getFile();
      const raw = (await file.text()).trim();
      let parsed = [];
      if (raw) {
        parsed = JSON.parse(raw);
      }
      this.maps = Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.warn('No se pudieron cargar los mapas:', error);
      this.maps = [];
    }

    return this.maps;
  }

  async loadAreas() { // Antes loadZones
    if (!this.fsManager || !this.fsManager.isConnected) {
      this.areas = [];
      return this.areas;
    }

    try {
      const fileHandle = await this.rootHandle.getFileHandle(this.areasFileName, { create: true });
      const file = await fileHandle.getFile();
      const raw = (await file.text()).trim();
      let parsed = [];
      if (raw) {
        parsed = JSON.parse(raw);
      }
      this.areas = Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      console.warn('No se pudieron cargar las áreas:', error);
      this.areas = [];
    }

    return this.areas;
  }

  async writeJSON(fileName, data) {
    if (!this.fsManager || !this.fsManager.isConnected) {
      return false;
    }

    try {
      const handle = await this.rootHandle.getFileHandle(fileName, { create: true });
      const writable = await handle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      return true;
    } catch (error) {
      console.warn(`No se pudo escribir ${fileName}:`, error);
      return false;
    }
  }

  async saveMaps(maps, meta = {}) {
    const normalized = Array.isArray(maps) ? maps : [];

    if (!this.fsManager || !this.fsManager.isConnected) {
      this.maps = [...normalized];
      return false;
    }

    await this.createBackup(this.mapsFileName, 'maps');
    await this.writeJSON(this.mapsFileName, normalized);
    this.maps = [...normalized];

    await this.appendLog({ scope: 'maps', action: meta.action || 'save', mapId: meta.mapId || null, detail: meta.detail || null });
    return true;
  }

  async saveAreas(areas, meta = {}) { // Antes saveZones
    const normalized = Array.isArray(areas) ? areas : [];

    if (!this.fsManager || !this.fsManager.isConnected) {
      this.areas = [...normalized];
      return false;
    }

    await this.createBackup(this.areasFileName, 'areas'); // Backup sigue siendo 'areas'
    await this.writeJSON(this.areasFileName, normalized); // Archivo sigue siendo zonas.json
    this.areas = [...normalized];

    await this.appendLog({ scope: 'areas', action: meta.action || 'save', mapId: meta.mapId || null, areaId: meta.areaId || null, detail: meta.detail || null });
    return true;
  }

  async createBackup(fileName, namespace) {
    if (!this.fsManager || !this.fsManager.isConnected) {
      return;
    }

    const dirHandle = namespace === 'areas' ? this.backupAreasDir : this.backupMapsDir;
    if (!dirHandle) {
      return;
    }

    try {
      const fileHandle = await this.rootHandle.getFileHandle(fileName);
      const file = await fileHandle.getFile();
      const content = await file.text();
      if (!content || !content.trim()) {
        return;
      }

      const timestamp = this.formatTimestamp(new Date());
      const baseName = fileName.replace('.json', '');
      const backupHandle = await dirHandle.getFileHandle(`${baseName}-${timestamp}.json`, { create: true });
      const writable = await backupHandle.createWritable();
      await writable.write(content);
      await writable.close();

      await this.rotateBackups(dirHandle);
    } catch (error) {
      if (error.name !== 'NotFoundError') {
        console.warn(`No se pudo crear backup para ${fileName}:`, error);
      }
    }
  }

  async rotateBackups(dirHandle) {
    if (!dirHandle) {
      return;
    }

    const files = [];
    try {
      for await (const entry of dirHandle.values()) {
        if (entry.kind === 'file') {
          files.push(entry.name);
        }
      }
    } catch (error) {
      console.warn('No se pudo enumerar los backups:', error);
      return;
    }

    files.sort();

    while (files.length > this.maxBackups) {
      const oldest = files.shift();
      try {
        await dirHandle.removeEntry(oldest);
      } catch (error) {
        console.warn('No se pudo eliminar backup antiguo:', oldest, error);
        break;
      }
    }
  }

  async appendLog(event) {
    if (!event || typeof event !== 'object') {
      return;
    }

    if (!this.logsDirHandle) {
      return;
    }

    try {
      const payload = {
        scope: event.scope || 'maps',
        action: event.action || 'update',
        mapId: event.mapId || null,
        areaId: event.areaId || null, // Antes 'zoneId'
        detail: event.detail || null,
        timestamp: new Date().toISOString()
      };
      const handle = await this.logsDirHandle.getFileHandle(this.logFileName, { create: true });
      const file = await handle.getFile();
      const writable = await handle.createWritable({ keepExistingData: true });
      await writable.seek(file.size);
      await writable.write(JSON.stringify(payload) + '\n');
      await writable.close();
    } catch (error) {
      console.warn('No se pudo registrar el evento de mapa:', error);
    }
  }

  async readLog(limit = null) {
    if (!this.logsDirHandle) {
      return [];
    }

    try {
      const handle = await this.logsDirHandle.getFileHandle(this.logFileName, { create: true });
      const file = await handle.getFile();
      const text = await file.text();
      if (!text) {
        return [];
      }

      const lines = text.split('\n').filter(line => line.trim().length > 0);
      const events = [];
      for (const line of lines) {
        try {
          events.push(JSON.parse(line));
        } catch (error) {
          console.warn('Entrada de log invalida:', line);
        }
      }

      if (typeof limit === 'number' && limit > 0) {
        return events.slice(-limit);
      }

      return events;
    } catch (error) {
      console.warn('No se pudo leer el log de mapas:', error);
      return [];
    }
  }

  async getFileHandleFromPath(path) {
    if (!this.fsManager || !this.fsManager.isConnected) {
      return null;
    }

    const segments = Array.isArray(path) ? path : String(path || '').split('/').filter(Boolean);
    if (!segments.length) {
      return null;
    }

    let currentDir = this.rootHandle;
    try {
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const isLast = i === segments.length - 1;
        if (isLast) {
          return await currentDir.getFileHandle(segment, { create: false });
        }
        currentDir = await currentDir.getDirectoryHandle(segment, { create: false });
      }
    } catch (error) {
      console.warn('No se pudo resolver ruta de archivo:', path, error);
      return null;
    }

    return null;
  }

  async getMapImage(map) {
    if (!map || !map.imagePath) {
      return null;
    }

    try {
      const handle = await this.getFileHandleFromPath(map.imagePath);
      if (!handle) {
        return null;
      }
      return await handle.getFile();
    } catch (error) {
      console.warn('No se pudo obtener imagen del mapa:', error);
      return null;
    }
  }
  
  getMapById(mapId) {
    return this.maps.find(map => map.id === mapId) || null;
  }

  getAreasByMap(mapId) { // Antes getZonesByMap
    return this.areas.filter(area => area.mapId === mapId);
  }

  formatTimestamp(date = new Date()) {
    const pad = (value) => String(value).padStart(2, '0');
    const year = date.getFullYear();
    const month = pad(date.getMonth() + 1);
    const day = pad(date.getDate());
    const hours = pad(date.getHours());
    const minutes = pad(date.getMinutes());
    const seconds = pad(date.getSeconds());
    return `${year}${month}${day}-${hours}${minutes}${seconds}`;
  }

  // Métodos para exportación de respaldo completo
  async getMaps() {
    await this.loadMaps();
    return this.maps;
  }

  async getAreas() {
    await this.loadAreas();
    return this.areas;
  }
}

// 🗺️ Crear instancia de MapStorage (usa el fsManager ya existente)
const mapStorage = new MapStorageService(fsManager);
console.log('🗺️ MapStorage inicializado');

/* FIN MAP STORAGE SERVICE */

/* ═══════════════════════════════════════════════════════════════════════════════
   🗺️ MAP CONTROLLER - INTEGRADO DESDE APP_BASE (FASE 4B)
   ═══════════════════════════════════════════════════════════════════════════════
   Controlador principal del editor de mapas con canvas, zoom, pan y dibujo de áreas.
   ═══════════════════════════════════════════════════════════════════════════════ */

const mapController = {
  elements: {},
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // 📂 SISTEMA DE CATEGORÍAS PARA ÁREAS (Etapa 1.2)
  // ═══════════════════════════════════════════════════════════════════════════════
  categories: {
    area: { 
      icon: '🏭', 
      color: '#3b82f6',
      name: 'Área',
      description: 'Zona general de planta'
    },
    maquina: { 
      icon: '⚙️', 
      color: '#10b981',
      name: 'Máquina',
      description: 'Equipo industrial principal'
    },
    estructura: { 
      icon: '🔧', 
      color: '#64748b',
      name: 'Estructura',
      description: 'Componente estructural'
    },
    cinta: { 
      icon: '📦', 
      color: '#f59e0b',
      name: 'Cinta',
      description: 'Transportador o cinta'
    },
    componente: { 
      icon: '🔩', 
      color: '#8b5cf6',
      name: 'Componente',
      description: 'Pieza o elemento menor'
    }
  },
  
  state: {
    currentMapId: null,
    currentMap: null,
    currentImage: null,
    currentImageUrl: null,
    scale: 1,
    minScale: 0.05,
    maxScale: 20,
    offsetX: 0,
    offsetY: 0,
    isPanning: false,
    panStartX: 0,
    panStartY: 0,
    drawing: false,
    tempPoints: [],
    previewPoint: null,
    highlightAreaId: null, // Antes highlightZoneId
    showGrid: false,
    showRulers: false, // 📏 NUEVO: Mostrar reglas laterales
    gridSize: 50, // 📏 NUEVO: Tamaño de celda del grid (píxeles)
    showMinimap: true, // 🗺️ NUEVO: Mostrar minimap por defecto
    mostrarNombresAreas: true, // 👁️ NUEVO: Mostrar nombres de áreas
    mostrarPuntosRepuestos: true, // 📍 NUEVO: Mostrar puntos de repuestos
    repuestoFiltrado: null, // 🔍 NUEVO: ID del repuesto filtrado
    tooltipPinned: false, // 🆕 Tooltip fijado al hacer click
    pinnedAreaId: null, // 🆕 ID del área cuyo tooltip está fijado
    cascadaEditMode: false, // 🎯 NUEVO: Modo edición drag & drop en cascada
    mostrarSoloConJerarquia: false, // 🎯 NUEVO: Filtro para ocultar elementos sin jerarquía
    draggedRepuesto: null, // 🎯 NUEVO: Repuesto siendo arrastrado
    dropTargetArea: null, // 🎯 NUEVO: Área objetivo del drop
    areas: [], // Antes zones
    categoryFilter: null, // NUEVO: filtro activo por categoría
    
    // 🎯 ETAPA 3.1: Selección múltiple
    selectedAreaIds: [], // IDs de áreas seleccionadas
    isMultiSelectMode: false, // Modo selección múltiple activo
    
    // 🎯 ETAPA 3.2: Edición de puntos de áreas (reshape)
    isReshapeMode: false, // Modo reshape activo
    reshapeAreaId: null, // ID del área siendo editada
    reshapePoints: [], // Puntos del área en edición
    selectedPointIndex: null, // Índice del punto seleccionado
    isDraggingPoint: false, // Arrastrando un punto
    hoveredPointIndex: null, // Punto bajo el cursor
    hoveredEdgeIndex: null, // Borde bajo el cursor (para agregar punto)
    
    // Modo de edición de puntos
    editingAreaId: null, // Antes editingZoneId
    editingPoints: [],
    selectedPointIndex: null,
    isDraggingPoint: false,
    // Performance optimization
    animationFrameId: null,
    needsRedraw: false
  },

  init() {
    // 🗺️ Cargar categorías personalizadas desde localStorage
    const savedCategories = localStorage.getItem('mapCategories');
    if (savedCategories) {
      try {
        this.categories = JSON.parse(savedCategories);
        console.log('✅ Categorías personalizadas cargadas:', Object.keys(this.categories));
      } catch (e) {
        console.warn('⚠️ Error al cargar categorías personalizadas:', e);
      }
    }

    this.elements = {
      shell: document.querySelector('.map-shell'),
      connectBtn: document.getElementById('mapConnectBtn'),
      newBtn: document.getElementById('mapNewBtn'),
      drawBtn: document.getElementById('mapDrawAreaBtn'), // Antes mapDrawZoneBtn
      saveBtn: document.getElementById('mapSaveAreasBtn'), // Antes mapSaveZonesBtn
      mapList: document.getElementById('mapList'),
      areaList: document.getElementById('areaList'), // Antes zoneList
      logList: document.getElementById('mapLogList'),
      logRefreshBtn: document.getElementById('mapLogRefreshBtn'),
      connectionBadge: document.getElementById('mapConnectionBadge'),
      status: document.getElementById('mapStatus'),
      zoomBadge: document.getElementById('mapZoomBadge'),
      metaBadge: document.getElementById('mapMetaBadge'),
      toolbar: document.getElementById('mapToolbar'),
      canvasStage: document.querySelector('.map-canvas-stage'),
      canvas: document.getElementById('mapCanvas'),
      hint: document.getElementById('mapHint'),
      tooltip: document.getElementById('mapTooltip'), // 🎨 NUEVO: Tooltip para áreas
      minimapContainer: document.getElementById('mapMinimapContainer'), // 🗺️ NUEVO: Contenedor minimap
      minimap: document.getElementById('mapMinimap'), // 🗺️ NUEVO: Canvas minimap
      minimapViewport: document.getElementById('mapMinimapViewport'), // 🗺️ NUEVO: Indicador viewport
      modal: document.getElementById('mapModalOverlay'),
      modalBody: document.getElementById('mapModalBody'),
      modalTitle: document.getElementById('mapModalTitle'),
      modalClose: document.getElementById('mapModalClose')
    };

    if (!this.elements.canvas) {
      console.warn('mapController: canvas no disponible');
      return;
    }

    this.ctx = this.elements.canvas.getContext('2d', { alpha: false, desynchronized: true });
    
    // 🗺️ NUEVO: Inicializar contexto del minimap
    if (this.elements.minimap) {
      this.minimapCtx = this.elements.minimap.getContext('2d', { alpha: true });
    }
    
    this.bindEvents();
    this.updateConnectionBadge();
    this.resizeCanvas();

    if (mapStorage.initialized) {
      this.loadData();
    } else if (fsManager.isConnected) {
      mapStorage.init({ autoReconnect: false }).then(() => this.loadData()).catch((error) => {
        console.warn('mapController: no se pudo inicializar mapStorage de inmediato', error);
      });
    } else {
      this.drawMessage('Conecta la carpeta INVENTARIO_STORAGE para comenzar.');
      this.renderMapList([]);
      this.renderAreaList([]);
    }
  },

  bindEvents() {
    const { connectBtn, newBtn, drawBtn, toolbar, logRefreshBtn, modalClose, modal } = this.elements;

    if (connectBtn) connectBtn.addEventListener('click', () => this.handleConnect());
    if (newBtn) newBtn.addEventListener('click', () => this.openNewMapModal());
    if (drawBtn) drawBtn.addEventListener('click', () => this.toggleDrawingMode());
    
    // 🆕 BOTÓN AGREGAR MARCADOR
    const addMarkerBtn = document.getElementById('mapAddMarkerBtn');
    if (addMarkerBtn) {
      addMarkerBtn.addEventListener('click', () => this.toggleModoAgregarMarcador());
    }
    
    if (toolbar) {
      toolbar.addEventListener('click', (event) => {
        const target = event.target.closest('[data-action]');
        if (!target) return;
        const action = target.dataset.action;
        event.preventDefault();
        this.handleToolbarAction(action);
      });
    }
    if (logRefreshBtn) logRefreshBtn.addEventListener('click', () => this.refreshLog());
    if (modalClose) modalClose.addEventListener('click', () => this.closeModal());
    if (modal) modal.addEventListener('click', (event) => {
      if (event.target === modal) this.closeModal();
    });

    // Event listeners para filtros de historial
    const filterAction = document.getElementById('mapLogFilterAction');
    const filterScope = document.getElementById('mapLogFilterScope');
    const helpBtn = document.getElementById('mapLogHelpBtn');
    
    if (filterAction) filterAction.addEventListener('change', () => this.refreshLog());
    if (filterScope) filterScope.addEventListener('change', () => this.refreshLog());
    if (helpBtn) helpBtn.addEventListener('click', () => this.showHistorialHelp());

    // 📂 NUEVO: Event listeners para filtros de categoría
    const categoryFilterBtns = document.querySelectorAll('.map-category-filter-btn');
    categoryFilterBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const category = e.target.dataset.category;
        this.applyCategoryFilter(category);
        
        // Actualizar estilos de botones activo/inactivo
        categoryFilterBtns.forEach(b => {
          if (b.dataset.category === category) {
            b.style.background = 'var(--primary)';
            b.style.color = 'white';
          } else {
            b.style.background = 'var(--bg-tertiary)';
            b.style.color = 'var(--text-primary)';
          }
        });
      });
    });

    // 🔍 NUEVO: Event listener para buscador de áreas
    const areaSearchInput = document.getElementById('mapAreaSearch');
    if (areaSearchInput) {
      areaSearchInput.addEventListener('input', () => {
        // Re-renderizar la lista con el filtro de búsqueda aplicado
        if (this.state.currentMapId) {
          const currentAreas = this.state.areas.filter(a => a.mapId === this.state.currentMapId);
          this.renderAreaList(currentAreas);
        }
      });
    }

    // 🗺️ NUEVO: Event listener para clic en minimap
    if (this.elements.minimap) {
      this.elements.minimap.addEventListener('click', (event) => {
        this.handleMinimapClick(event);
      });
    }

    this.registerCanvasEvents();
    window.addEventListener('resize', () => this.handleResize());
  },

  async handleConnect() {
    if (typeof fsManager?.checkFileSystemAPI === 'function' && !fsManager.checkFileSystemAPI()) {
      this.showToast('Tu navegador no soporta File System Access API. Usa Microsoft Edge o Chrome.', 'warning');
      return;
    }

    // 🔌 USAR MÉTODO CENTRALIZADO
    try {
      console.log('🔌 Iniciando conexión...');
      const connected = await app.connectWorkspace(false, true); // isReconnect=false, promptUser=true
      console.log('🔌 Resultado conexión:', connected);
      
      // 🔄 SIEMPRE recargar página después de intentar conectar
      console.log('🔄 Recargando página en 1 segundo...');
      setTimeout(() => {
        location.reload();
      }, 1000);
      
    } catch (error) {
      console.error('Error conectando carpeta:', error);
      this.showToast('No se pudo conectar la carpeta: ' + (error?.message || error), 'error');
    }
  },

  updateConnectionBadge() {
    const { connectionBadge, status } = this.elements;
    if (!connectionBadge) return;

    if (mapStorage.initialized && fsManager.isConnected) {
      connectionBadge.textContent = fsManager.folderPath || 'INVENTARIO_STORAGE';
      connectionBadge.classList.remove('map-status-badge--off');
      connectionBadge.classList.add('map-status-badge--on');
      if (status) {
        status.textContent = 'Selecciona un mapa o crea uno nuevo para comenzar a trabajar.';
      }
    } else {
      connectionBadge.textContent = 'Sin carpeta';
      connectionBadge.classList.remove('map-status-badge--on');
      connectionBadge.classList.add('map-status-badge--off');
      if (status) {
        status.textContent = 'Conecta la carpeta INVENTARIO_STORAGE para habilitar el editor de mapas.';
      }
    }
  },

  async loadData(options = {}) {
    if (!mapStorage.initialized) {
      this.renderMapList([]);
      this.renderAreaList([]);
      this.drawMessage('Conecta la carpeta INVENTARIO_STORAGE para comenzar.');
      return;
    }

    try {
      if (options.force) {
        await mapStorage.ensureStructure();
        await Promise.all([mapStorage.loadMaps(), mapStorage.loadAreas()]);
      }

      const maps = mapStorage.maps || [];
      this.renderMapList(maps);

      if (!maps.length) {
        this.state.currentMapId = null;
        this.state.currentMap = null;
        this.cleanupImage();
        this.renderAreaList([]);
        this.drawMessage('Crea un mapa para comenzar a dibujar zonas.');
        return;
      }

      if (!this.state.currentMapId || !maps.some(m => m.id === this.state.currentMapId)) {
        await this.selectMap(maps[0].id);
      } else {
        await this.selectMap(this.state.currentMapId, { keepViewport: true });
      }

      await this.refreshLog();
    } catch (error) {
      console.error('mapController.loadData error:', error);
      this.showToast('No se pudieron cargar los mapas. Revisa la consola.', 'error');
    }
  },

  renderMapList(maps) {
    const { mapList } = this.elements;
    if (!mapList) return;

    if (!Array.isArray(maps) || !maps.length) {
      mapList.innerHTML = `<div style="padding: 16px; border: 1px dashed var(--border-color); border-radius: 10px; color: var(--text-secondary); font-size: 0.85rem;">Aún no hay mapas registrados.</div>`;
      return;
    }

    const activeId = this.state.currentMapId;
    mapList.innerHTML = maps.map(map => {
      const isActive = activeId === map.id;
      const createdAt = map.createdAt ? new Date(map.createdAt).toLocaleDateString('es-CL') : '';
      const dimensions = map.width && map.height ? `${map.width} × ${map.height}px` : 'Dimensiones pendientes';
      const areasCount = (mapStorage.areas || []).filter(z => z.mapId === map.id).length;
      return `
        <article class="map-card ${isActive ? 'map-card--active' : ''}" data-map-id="${map.id}">
          <div class="map-card-content" data-action="select-map">
            <div class="map-card-title">${this.escapeHtml(map.name || 'Mapa sin nombre')}</div>
            <div class="map-card-meta">${dimensions}</div>
            <div class="map-card-meta">${areasCount} Ã¡rea(s) registradas</div>
            ${createdAt ? `<div class="map-card-meta">Creado: ${createdAt}</div>` : ''}
          </div>
          <div class="map-card-actions">
            <button class="map-card-btn map-card-btn--edit" data-action="edit-map" data-map-id="${map.id}" title="Editar mapa">
              ✏️
            </button>
            <button class="map-card-btn map-card-btn--delete" data-action="delete-map" data-map-id="${map.id}" title="Eliminar mapa">
              🗑️
            </button>
          </div>
        </article>
      `;
    }).join('');

    // Event listeners para seleccionar mapa
    Array.from(mapList.querySelectorAll('[data-action="select-map"]')).forEach(content => {
      content.addEventListener('click', async (e) => {
        const card = e.target.closest('.map-card');
        const mapId = card?.getAttribute('data-map-id');
        if (!mapId) return;
        await this.selectMap(mapId);
      });
    });

    // Event listeners para editar mapa
    Array.from(mapList.querySelectorAll('[data-action="edit-map"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const mapId = btn.getAttribute('data-map-id');
        await this.openEditMapModal(mapId);
      });
    });

    // Event listeners para eliminar mapa
    Array.from(mapList.querySelectorAll('[data-action="delete-map"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const mapId = btn.getAttribute('data-map-id');
        await this.deleteMap(mapId);
      });
    });
  },

  // 🆕 FUNCIÓN CENTRALIZADA: Calcular correlativos para todo el mapa
  calcularCorrelativosGlobales(mapId) {
    if (!app || !app.repuestos || !Array.isArray(app.repuestos)) return {};
    
    const correlativosGlobales = {}; // { repuestoId: { ubicacionIndex: numeroCorrelativo, total: X } }
    
    // Primer paso: contar totales por repuesto
    const totales = {};
    app.repuestos.forEach(repuesto => {
      if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) return;
      
      const count = repuesto.ubicaciones.filter(ub => 
        String(ub.mapId) === String(mapId) && ub.markerX && ub.markerY
      ).length;
      
      if (count > 0) {
        totales[repuesto.id] = count;
      }
    });
    
    // Segundo paso: asignar números correlativos
    app.repuestos.forEach(repuesto => {
      if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) return;
      if (!totales[repuesto.id]) return;
      
      let contador = 0;
      repuesto.ubicaciones.forEach((ubicacion, index) => {
        if (String(ubicacion.mapId) !== String(mapId)) return;
        if (!ubicacion.markerX || !ubicacion.markerY) return;
        
        contador++;
        
        if (!correlativosGlobales[repuesto.id]) {
          correlativosGlobales[repuesto.id] = {};
        }
        
        correlativosGlobales[repuesto.id][index] = {
          numero: contador,
          total: totales[repuesto.id]
        };
      });
    });
    
    return correlativosGlobales;
  },

  // 🆕 Obtener marcadores agrupados por área y categoría con numeración correlativa GLOBAL
  getMarcadoresPorArea(areaId) {
    if (!app || !app.repuestos || !Array.isArray(app.repuestos)) return {};
    
    const mapId = this.state.currentMapId;
    const marcadoresPorCategoria = {};
    
    // Obtener correlativos globales una sola vez
    const correlativosGlobales = this.calcularCorrelativosGlobales(mapId);
    
    app.repuestos.forEach(repuesto => {
      if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) return;
      
      repuesto.ubicaciones.forEach((ubicacion, index) => {
        // Filtrar por mapa y área actual
        if (String(ubicacion.mapId) !== String(mapId)) return;
        if (String(ubicacion.areaId) !== String(areaId)) return;
        
        const categoria = ubicacion.categoria || 'Sin categoría';
        
        if (!marcadoresPorCategoria[categoria]) {
          marcadoresPorCategoria[categoria] = [];
        }
        
        // Obtener correlativo global
        const corrInfo = correlativosGlobales[repuesto.id]?.[index] || { numero: 1, total: 1 };
        
        marcadoresPorCategoria[categoria].push({
          repuesto: repuesto,
          ubicacion: ubicacion,
          ubicacionIndex: index,
          numeroCorrelativo: corrInfo.numero,
          totalInstancias: corrInfo.total
        });
      });
    });
    
    return marcadoresPorCategoria;
  },

  // Toggle para expandir/colapsar área
  toggleArea(toggleBtn) {
    const areaDiv = toggleBtn.closest('[data-area-id]');
    if (!areaDiv) return;
    
    const children = areaDiv.nextElementSibling;
    if (!children || !children.classList.contains('area-children')) return;
    
    const isCollapsed = children.style.display === 'none';
    children.style.display = isCollapsed ? 'block' : 'none';
    toggleBtn.textContent = isCollapsed ? 'v' : '>';
  },

  // 🆕 Toggle para expandir/colapsar categoría
  toggleCategoria(catHeader) {
    const catGroup = catHeader.closest('.categoria-group');
    if (!catGroup) return;
    
    const marcadores = catGroup.querySelector('.categoria-marcadores');
    const toggle = catHeader.querySelector('.categoria-toggle');
    if (!marcadores || !toggle) return;
    
    const isCollapsed = marcadores.style.display === 'none';
    marcadores.style.display = isCollapsed ? 'block' : 'none';
    toggle.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(-90deg)';
  },

  // 🆕 Hacer zoom a un marcador específico
  focusOnMarker(repuestoId, ubicacionIndex) {
    // 🔧 Limpiar selección anterior antes de seleccionar nuevo
    const prevSelection = this.state.highlightMarker;
    const sameMarker = prevSelection && 
                       prevSelection.repuestoId === repuestoId && 
                       prevSelection.ubicacionIndex === ubicacionIndex;
    
    // Si es el mismo marcador, no hacer nada (ya está seleccionado)
    if (sameMarker) {
      console.log('📍 Marcador ya seleccionado');
      return;
    }
    
    // 🌟 Si había una animación anterior, detenerla
    if (prevSelection) {
      this.stopMarkerAnimation();
    }
    
    const repuesto = app.repuestos.find(r => r.id === repuestoId);
    if (!repuesto || !repuesto.ubicaciones || !repuesto.ubicaciones[ubicacionIndex]) {
      console.warn('focusOnMarker: repuesto o ubicación no encontrada', { repuestoId, ubicacionIndex });
      return;
    }
    
    const ubicacion = repuesto.ubicaciones[ubicacionIndex];
    
    if (!ubicacion.markerX || !ubicacion.markerY) {
      console.warn('focusOnMarker: ubicación sin coordenadas', ubicacion);
      return;
    }
    
    const canvas = this.elements.canvas;
    if (!canvas) {
      console.warn('focusOnMarker: canvas no disponible');
      return;
    }
    
    // 🔧 SOLUCIÓN: Centrar el marcador manteniendo el zoom actual
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // 🔍 Calcular nuevo offset para centrar el marcador
    // Fórmula canvas: screenPos = translate(offset) + scale(worldPos)
    // Para centrar: centerX = offsetX + (markerX * scale)
    // Por lo tanto: offsetX = centerX - (markerX * scale)
    this.state.offsetX = centerX - (ubicacion.markerX * this.state.scale);
    this.state.offsetY = centerY - (ubicacion.markerY * this.state.scale);
    
    console.log(`� Marcador centrado: ${repuesto.nombre} #${ubicacionIndex + 1}`, {
      worldPos: [ubicacion.markerX.toFixed(1), ubicacion.markerY.toFixed(1)],
      zoom: `${Math.round(this.state.scale * 100)}%`,
      nuevoOffset: [this.state.offsetX.toFixed(1), this.state.offsetY.toFixed(1)]
    });
    
    // 🔧 Resaltar marcador de forma persistente
    this.state.highlightMarker = { repuestoId, ubicacionIndex };
    
    // 🌟 ANIMACIÓN: Iniciar loop para el efecto de halo pulsante
    this.startMarkerAnimation();
    
    // Redibujar para mostrar el resaltado
    this.draw();
  },
  
  // 🌟 NUEVO: Iniciar animación continua para marcador resaltado
  startMarkerAnimation() {
    // Si ya hay una animación activa, no crear otra
    if (this.state.markerAnimationId) {
      return;
    }
    
    const animate = () => {
      // Solo continuar si hay un marcador resaltado
      if (this.state.highlightMarker) {
        this.draw();
        this.state.markerAnimationId = requestAnimationFrame(animate);
      } else {
        this.state.markerAnimationId = null;
      }
    };
    
    this.state.markerAnimationId = requestAnimationFrame(animate);
  },
  
  // 🌟 NUEVO: Detener animación de marcador
  stopMarkerAnimation() {
    if (this.state.markerAnimationId) {
      cancelAnimationFrame(this.state.markerAnimationId);
      this.state.markerAnimationId = null;
    }
  },
  
  // 🆕 Limpiar selección de marcador (llamar al hacer click fuera o seleccionar otro)
  clearMarkerSelection() {
    if (this.state.highlightMarker) {
      this.state.highlightMarker = null;
      this.stopMarkerAnimation(); // 🌟 Detener animación del halo
      this.scheduleRender();
    }
  },

  // 🆕 Abrir modal para editar datos de un marcador (jerarquía, categoría)
  openEditMarkerModal(repuestoId, ubicacionIndex) {
    const repuesto = app.repuestos.find(r => r.id === repuestoId);
    if (!repuesto || !repuesto.ubicaciones || !repuesto.ubicaciones[ubicacionIndex]) {
      this.showToast('❌ Marcador no encontrado', 'error');
      return;
    }
    
    const ubicacion = repuesto.ubicaciones[ubicacionIndex];
    const area = this.state.areas.find(a => a.id === ubicacion.areaId);
    
    // 🧠 CALCULAR NIVEL SUGERIDO basado en la jerarquía del área
    let nivelSugerido = 'N8'; // Por defecto N8 (Detalle)
    let razonSugerencia = '';
    
    if (area && area.jerarquia) {
      // Mapeo de niveles: planta → N2, areaGeneral → N3, subArea → N4, etc.
      const mapaJerarquia = {
        'planta': 'N2',
        'areaGeneral': 'N3', 
        'subArea': 'N4',
        'sistemaEquipo': 'N5',
        'subSistema': 'N6',
        'seccion': 'N7',
        'detalle': 'N8'
      };
      
      // Encontrar el nivel más profundo definido en el área
      const nivelesDefinidos = ['detalle', 'seccion', 'subSistema', 'sistemaEquipo', 'subArea', 'areaGeneral', 'planta'];
      for (const nivel of nivelesDefinidos) {
        if (area.jerarquia[nivel]) {
          nivelSugerido = mapaJerarquia[nivel];
          razonSugerencia = `Basado en ${area.jerarquia[nivel]}`;
          break;
        }
      }
      
      // Si el área tiene nivel, el repuesto debería estar un nivel más abajo
      const nivelNumerico = parseInt(nivelSugerido.substring(1));
      if (nivelNumerico < 8) {
        nivelSugerido = 'N' + (nivelNumerico + 1);
        razonSugerencia = `Repuesto dentro de ${razonSugerencia}`;
      }
    }
    
    // Obtener nivel jerárquico actual del repuesto
    const nivelActual = repuesto.nivelJerarquico || nivelSugerido;
    
    // Crear modal
    const modalHTML = `
      <div style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 100000;">
        <div style="background: var(--bg-secondary); border-radius: 6px; padding: 20px; width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
          <h3 style="margin: 0 0 16px 0; color: var(--text-primary); font-size: 1rem; font-weight: 600;">
            📝 Editar Datos del Repuesto
          </h3>
          
          <div style="margin-bottom: 12px; padding: 10px; background: var(--bg-tertiary); border-radius: 4px;">
            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 4px;">Repuesto:</div>
            <div style="font-weight: 600; color: var(--text-primary); font-size: 0.95rem;">
              ${this.escapeHtml(repuesto.nombre)}
            </div>
            ${repuesto.codSAP ? `<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">SAP: ${repuesto.codSAP}</div>` : ''}
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; margin-bottom: 4px; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500;">
              📌 Ubicación Actual:
            </label>
            <div style="padding: 8px; background: var(--bg-tertiary); border-radius: 4px; color: var(--text-primary); font-size: 0.85rem;">
              ${this.escapeHtml(area ? area.name : 'Desconocida')}
            </div>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; margin-bottom: 4px; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500;">
              🏷️ Nivel Jerárquico:
            </label>
            ${nivelActual !== nivelSugerido && razonSugerencia ? `
              <div style="margin-bottom: 8px; padding: 8px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 4px;">
                <div style="font-size: 0.75rem; color: #22c55e; font-weight: 600; margin-bottom: 2px;">
                  💡 Nivel sugerido: ${nivelSugerido}
                </div>
                <div style="font-size: 0.7rem; color: var(--text-secondary);">
                  ${razonSugerencia}
                </div>
                <button onclick="document.getElementById('editMarkerNivel').value='${nivelSugerido}'; this.parentElement.style.display='none';" style="margin-top: 6px; padding: 4px 12px; background: #22c55e; color: white; border: none; border-radius: 3px; font-size: 0.7rem; cursor: pointer; font-weight: 600;">
                  ✓ Aplicar Sugerencia
                </button>
              </div>
            ` : ''}
            <select id="editMarkerNivel" style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.9rem;">
              <option value="N1" ${nivelActual === 'N1' ? 'selected' : ''}>N1 - Empresa</option>
              <option value="N2" ${nivelActual === 'N2' ? 'selected' : ''}>N2 - Planta (Planta Principal, Acopio, etc.)</option>
              <option value="N3" ${nivelActual === 'N3' ? 'selected' : ''}>N3 - Área General</option>
              <option value="N4" ${nivelActual === 'N4' ? 'selected' : ''}>N4 - Sub-Área</option>
              <option value="N5" ${nivelActual === 'N5' ? 'selected' : ''}>N5 - Sistema/Equipo</option>
              <option value="N6" ${nivelActual === 'N6' ? 'selected' : ''}>N6 - Sub-Sistema</option>
              <option value="N7" ${nivelActual === 'N7' ? 'selected' : ''}>N7 - Sección</option>
              <option value="N8" ${nivelActual === 'N8' ? 'selected' : ''}>N8 - Detalle (predeterminado)</option>
            </select>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; margin-bottom: 4px; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500;">
              🔖 Categoría:
            </label>
            <select id="editMarkerCategoria" style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 0.9rem;">
              <option value="Sin categoría" ${ubicacion.categoria === 'Sin categoría' ? 'selected' : ''}>Sin categoría</option>
              <option value="Componentes" ${ubicacion.categoria === 'Componentes' ? 'selected' : ''}>Componentes</option>
              <option value="Eléctrico" ${ubicacion.categoria === 'Eléctrico' ? 'selected' : ''}>Eléctrico</option>
              <option value="Mecánico" ${ubicacion.categoria === 'Mecánico' ? 'selected' : ''}>Mecánico</option>
              <option value="Hidráulico" ${ubicacion.categoria === 'Hidráulico' ? 'selected' : ''}>Hidráulico</option>
              <option value="Neumático" ${ubicacion.categoria === 'Neumático' ? 'selected' : ''}>Neumático</option>
              <option value="Estructura" ${ubicacion.categoria === 'Estructura' ? 'selected' : ''}>Estructura</option>
              <option value="Seguridad" ${ubicacion.categoria === 'Seguridad' ? 'selected' : ''}>Seguridad</option>
              <option value="Instrumentación" ${ubicacion.categoria === 'Instrumentación' ? 'selected' : ''}>Instrumentación</option>
              <option value="Otro" ${ubicacion.categoria === 'Otro' ? 'selected' : ''}>Otro</option>
            </select>
          </div>
          
          <div style="margin-bottom: 16px; padding: 10px; background: rgba(99,102,241,0.08); border-left: 3px solid #6366f1; border-radius: 4px;">
            <p style="margin: 0 0 6px 0; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500;">
              💡 Sobre el nivel jerárquico:
            </p>
            <p style="margin: 0; color: var(--text-secondary); font-size: 0.75rem; line-height: 1.4;">
              El nivel determina el orden en cascada e inventario. N1 (Empresa) es el más alto, N8 (Detalle) el más específico. Usa los mismos niveles configurados en Configuración.
            </p>
          </div>
          
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="editMarkerCancelBtn" style="padding: 8px 16px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); cursor: pointer; font-size: 0.9rem;">
              Cancelar
            </button>
            <button id="editMarkerSaveBtn" style="padding: 8px 16px; background: var(--primary); border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.9rem; font-weight: 600;">
              Guardar
            </button>
          </div>
        </div>
      </div>
    `;
    
    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = modalHTML;
    document.body.appendChild(modalContainer);
    
    // Event listeners
    const cancelBtn = modalContainer.querySelector('#editMarkerCancelBtn');
    const saveBtn = modalContainer.querySelector('#editMarkerSaveBtn');
    
    cancelBtn.onclick = () => {
      document.body.removeChild(modalContainer);
    };
    
    saveBtn.onclick = () => {
      const nuevaCategoria = modalContainer.querySelector('#editMarkerCategoria').value;
      const nuevoNivel = modalContainer.querySelector('#editMarkerNivel').value;
      
      // Actualizar la categoría en la ubicación específica
      repuesto.ubicaciones[ubicacionIndex].categoria = nuevaCategoria;
      
      // Actualizar el nivel jerárquico del repuesto (aplica a todas sus ubicaciones)
      repuesto.nivelJerarquico = nuevoNivel;
      
      // Guardar cambios
      app.guardarDatos();
      
      // Cerrar modal
      document.body.removeChild(modalContainer);
      
      // Re-renderizar lista
      this.renderAreaList(this.state.areas);
      
      this.showToast(`✅ Repuesto actualizado: Nivel ${nuevoNivel}`, 'success');
    };
  },

  renderAreaList(areas) {
    const { areaList } = this.elements;
    if (!areaList) return;

    // 📂 Aplicar filtro de categoría si está activo
    let filteredAreas = areas;
    if (this.state.categoryFilter) {
      filteredAreas = areas.filter(area => (area.category || 'area') === this.state.categoryFilter);
    }

    // 🔍 NUEVO: Aplicar filtro de búsqueda si existe texto
    const searchInput = document.getElementById('mapAreaSearch');
    if (searchInput && searchInput.value.trim()) {
      const searchTerm = searchInput.value.trim().toLowerCase();
      filteredAreas = filteredAreas.filter(area => {
        const areaName = (area.name || '').toLowerCase();
        const jerarquia = area.jerarquia ? Object.values(area.jerarquia).filter(Boolean).join(' ').toLowerCase() : '';
        return areaName.includes(searchTerm) || jerarquia.includes(searchTerm);
      });
    }

    if (!Array.isArray(filteredAreas) || !filteredAreas.length) {
      const mensaje = this.state.categoryFilter 
        ? `No hay áreas de la categoría seleccionada.`
        : (searchInput && searchInput.value.trim() ? `No se encontraron áreas con "${searchInput.value.trim()}".` : `No hay áreas registradas para este mapa.`);
      areaList.innerHTML = `<div style="padding: 12px; border: 1px dashed var(--border-color); border-radius: 8px; color: var(--text-secondary); font-size: 0.8rem;">${mensaje}</div>`;
      return;
    }

    // 🌳 Construir árbol jerárquico completo (6 niveles)
    const tree = this.buildHierarchyTree(filteredAreas);
    areaList.innerHTML = this.renderHierarchyTree(tree);

    // Event listeners para enfocar zona
    Array.from(areaList.querySelectorAll('[data-action="focus-area"]')).forEach(content => {
      content.addEventListener('click', (e) => {
        const areaId = e.target.closest('[data-area-id]')?.getAttribute('data-area-id');
        if (areaId) this.focusArea(areaId);
      });
    });

    // Event listeners para editar forma (puntos) de zona
    Array.from(areaList.querySelectorAll('[data-action="edit-area-points"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        await this.startEditAreaPoints(areaId);
      });
    });

    // Event listeners para editar metadatos de zona
    Array.from(areaList.querySelectorAll('[data-action="edit-area-metadata"]')).forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        this.openEditAreaMetadataModal(areaId);
      });
    });

    // Event listeners para eliminar zona
    Array.from(areaList.querySelectorAll('[data-action="delete-area"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        await this.deleteArea(areaId);
      });
    });
  },

  // 🔍 MODAL CASCADA JERÁRQUICA GRANDE
  openCascadaModal() {
    console.log('🔍 openCascadaModal llamado');
    
    const modal = document.getElementById('modalCascada');
    const contentDiv = document.getElementById('cascadaContent');
    
    console.log('Modal:', modal);
    console.log('ContentDiv:', contentDiv);
    
    if (!modal || !contentDiv) {
      console.error('❌ Modal de cascada no encontrado en el DOM');
      alert('Error: Modal no encontrado. Por favor recarga la página.');
      return;
    }

    // Obtener áreas del mapa actual desde el state
    const currentMap = this.state.currentMap;
    const areas = this.state.areas || [];
    
    console.log('Current Map:', currentMap);
    console.log('Areas:', areas);
    
    if (!currentMap || !areas || areas.length === 0) {
      console.log('⚠️ No hay áreas en el mapa actual');
      contentDiv.innerHTML = `
        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
          <div style="font-size: 4rem; margin-bottom: 16px;">📭</div>
          <h3 style="margin: 0 0 8px 0;">No hay áreas en este mapa</h3>
          <p style="margin: 0; opacity: 0.7;">Dibuja algunas áreas primero para ver la cascada jerárquica</p>
        </div>
      `;
      modal.style.display = 'block';
      console.log('✅ Modal mostrado (sin áreas)');
      return;
    }

    // Construir y renderizar el árbol jerárquico
    const tree = this.buildHierarchyTree(areas);
    contentDiv.innerHTML = this.renderHierarchyTree(tree);

    // Agregar event listeners para interacción
    this.attachCascadaEventListeners(contentDiv);
    
    // Calcular y mostrar estadísticas
    this.updateCascadaStats(areas);

    // Mostrar modal
    console.log('🎨 Mostrando modal...');
    modal.style.display = 'block';
    modal.style.zIndex = '99999'; // Forzar z-index muy alto
    console.log('✅ Modal display:', modal.style.display);
    console.log('✅ Modal z-index:', modal.style.zIndex);

    // ESC key para cerrar
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        console.log('🔑 ESC presionado, cerrando modal');
        modal.style.display = 'none';
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);

    // Limpiar input de búsqueda
    const searchInput = document.getElementById('cascadaSearchInput');
    if (searchInput) searchInput.value = '';
    
    console.log('✅ Modal completamente configurado y visible');
  },

  // Agregar event listeners a la cascada en el modal
  attachCascadaEventListeners(container) {
    // Event listeners para enfocar zona
    Array.from(container.querySelectorAll('[data-action="focus-area"]')).forEach(content => {
      content.addEventListener('click', (e) => {
        const areaId = e.target.closest('[data-area-id]')?.getAttribute('data-area-id');
        if (areaId) {
          this.focusArea(areaId);
          // Cerrar modal después de enfocar
          document.getElementById('modalCascada').style.display = 'none';
        }
      });
    });

    // Event listeners para editar forma (puntos) de zona
    Array.from(container.querySelectorAll('[data-action="edit-area-points"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        await this.startEditAreaPoints(areaId);
        document.getElementById('modalCascada').style.display = 'none';
      });
    });

    // Event listeners para editar metadatos de zona
    Array.from(container.querySelectorAll('[data-action="edit-area-metadata"]')).forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        this.openEditAreaMetadataModal(areaId);
        document.getElementById('modalCascada').style.display = 'none';
      });
    });

    // Event listeners para editar jerarquía de área
    Array.from(container.querySelectorAll('[data-action="edit-area-hierarchy"]')).forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        this.openEditAreaHierarchyModal(areaId);
      });
    });

    // Event listeners para eliminar zona
    Array.from(container.querySelectorAll('[data-action="delete-area"]')).forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const areaId = btn.getAttribute('data-area-id');
        await this.deleteArea(areaId);
        // Refrescar contenido del modal
        this.openCascadaModal();
      });
    });
  },

  // Filtrar cascada por búsqueda
  filterCascada(searchTerm) {
    const contentDiv = document.getElementById('cascadaContent');
    if (!contentDiv) return;

    const areas = this.state.areas || [];
    
    if (!areas || areas.length === 0) return;

    // Filtrar áreas por término de búsqueda
    const filtered = searchTerm.trim() 
      ? areas.filter(area => {
          const jerarquia = area.jerarquia || {};
          const searchLower = searchTerm.toLowerCase();
          return (
            (area.name || '').toLowerCase().includes(searchLower) ||
            Object.values(jerarquia).some(val => 
              (val || '').toLowerCase().includes(searchLower)
            )
          );
        })
      : areas;

    const tree = this.buildHierarchyTree(filtered);
    contentDiv.innerHTML = filtered.length > 0 
      ? this.renderHierarchyTree(tree)
      : `<div style="text-align: center; padding: 40px; color: var(--text-secondary);">
           <div style="font-size: 3rem;">🔍</div>
           <p>No se encontraron áreas con "${searchTerm}"</p>
         </div>`;

    this.attachCascadaEventListeners(contentDiv);
  },

  // Expandir todos los nodos
  expandAllCascada() {
    const contentDiv = document.getElementById('cascadaContent');
    if (!contentDiv) return;
    
    // Buscar todos los divs que tienen el toggle
    const allParents = contentDiv.querySelectorAll('[onclick*="nextElementSibling.style.display"]');
    allParents.forEach(parent => {
      const content = parent.nextElementSibling;
      const toggleIcon = parent.querySelector('.toggle');
      if (content && toggleIcon) {
        content.style.display = 'block';
        toggleIcon.textContent = 'v';
      }
    });
    
    console.log('✅ Todos los nodos expandidos');
  },

  // Colapsar todos los nodos
  collapseAllCascada() {
    const contentDiv = document.getElementById('cascadaContent');
    if (!contentDiv) return;
    
    // Buscar todos los divs que tienen el toggle
    const allParents = contentDiv.querySelectorAll('[onclick*="nextElementSibling.style.display"]');
    allParents.forEach(parent => {
      const content = parent.nextElementSibling;
      const toggleIcon = parent.querySelector('.toggle');
      if (content && toggleIcon) {
        content.style.display = 'none';
        toggleIcon.textContent = '>';
      }
    });
    
    console.log('✅ Todos los nodos colapsados');
  },

  // Modal para editar solo la jerarquía de un área
  openEditAreaHierarchyModal(areaId) {
    const numericId = typeof areaId === 'string' ? parseInt(areaId, 10) : areaId;
    const area = this.state.areas.find(a => a.id === numericId);
    
    if (!area) {
      this.showToast('Área no encontrada', 'error');
      return;
    }

    const jerarquia = area.jerarquia || {};
    const appJerarquia = app?.opcionesJerarquia || {};
    
    const buildDatalist = (id, values) => {
      if (!Array.isArray(values) || !values.length) return '';
      return `<datalist id="${id}">${values.map(v => `<option value="${this.escapeHtml(v)}"></option>`).join('')}</datalist>`;
    };

    // Crear modal simple
    const modalHTML = `
      <div id="modalEditHierarchy" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100000; display: flex; align-items: center; justify-content: center;" onclick="if(event.target.id==='modalEditHierarchy') this.remove()">
        <div style="background: var(--bg-primary); border-radius: 8px; padding: 20px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="margin: 0; color: var(--text-primary);">Editar Jerarquía de Área</h3>
            <button onclick="document.getElementById('modalEditHierarchy').remove()" style="background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer;">×</button>
          </div>
          
          <div style="padding: 12px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 16px;">
            <div style="color: var(--text-secondary); font-size: 0.9rem;">
              <strong style="color: var(--text-primary);">Área:</strong> ${this.escapeHtml(area.name || 'Sin nombre')}
            </div>
          </div>
          
          <form id="formEditHierarchy" style="display: flex; flex-direction: column; gap: 12px;">
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N1 - Planta</label>
              <input type="text" name="planta" list="plantaList" placeholder="Ej: Planta Principal" value="${this.escapeHtml(jerarquia.planta || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('plantaList', appJerarquia.planta || [])}
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N2 - Área General</label>
              <input type="text" name="areaGeneral" list="areaGeneralList" placeholder="Ej: Filete" value="${this.escapeHtml(jerarquia.areaGeneral || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('areaGeneralList', appJerarquia.areaGeneral || [])}
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N3 - Sub-Área</label>
              <input type="text" name="subArea" list="subAreaList" placeholder="Ej: Cinta Curva Filete" value="${this.escapeHtml(jerarquia.subArea || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('subAreaList', appJerarquia.subArea || [])}
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N4 - Sistema/Equipo</label>
              <input type="text" name="sistemaEquipo" list="sistemaEquipoList" placeholder="Ej: Grader Baader" value="${this.escapeHtml(jerarquia.sistemaEquipo || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('sistemaEquipoList', appJerarquia.sistemaEquipo || [])}
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N5 - Sub-Sistema</label>
              <input type="text" name="subSistema" list="subSistemaList" placeholder="Ej: Motor Principal" value="${this.escapeHtml(jerarquia.subSistema || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('subSistemaList', appJerarquia.subSistema || [])}
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <label style="color: var(--text-secondary); font-size: 0.85rem; font-weight: 600;">N6 - Sección</label>
              <input type="text" name="seccion" list="seccionList" placeholder="Ej: Módulo 1" value="${this.escapeHtml(jerarquia.seccion || '')}" style="padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary);" />
              ${buildDatalist('seccionList', appJerarquia.seccion || [])}
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 8px;">
              <button type="button" onclick="document.getElementById('modalEditHierarchy').remove()" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); cursor: pointer;">
                Cancelar
              </button>
              <button type="submit" style="flex: 1; padding: 10px; background: var(--primary); border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: 600;">
                Guardar Jerarquía
              </button>
            </div>
          </form>
        </div>
      </div>
    `;
    
    // Agregar al DOM
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Event listener para el formulario
    const form = document.getElementById('formEditHierarchy');
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const formData = new FormData(form);
      const newJerarquia = {
        planta: formData.get('planta'),
        areaGeneral: formData.get('areaGeneral'),
        subArea: formData.get('subArea'),
        sistemaEquipo: formData.get('sistemaEquipo'),
        subSistema: formData.get('subSistema'),
        seccion: formData.get('seccion')
      };
      
      // Actualizar área
      area.jerarquia = newJerarquia;
      
      // Guardar
      await mapStorage.updateArea(area);
      
      // Cerrar modal
      document.getElementById('modalEditHierarchy').remove();
      
      // Refrescar cascada
      this.openCascadaModal();
      
      this.showToast('✅ Jerarquía actualizada', 'success');
    });
  },

  // Exportar cascada a JSON
  exportCascada() {
    const currentMap = this.state.currentMap;
    const areas = this.state.areas || [];
    
    if (!currentMap || !areas || areas.length === 0) {
      alert('No hay datos para exportar');
      return;
    }

    const tree = this.buildHierarchyTree(areas);
    const dataStr = JSON.stringify(tree, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `cascada_jerarquica_${currentMap.name || 'mapa'}_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  },

  // Toggle modo edición de cascada
  toggleCascadaEditMode() {
    this.state.cascadaEditMode = !this.state.cascadaEditMode;
    const btn = document.getElementById('cascadaEditModeBtn');
    
    if (this.state.cascadaEditMode) {
      if (btn) {
        btn.classList.add('active');
        btn.style.background = 'var(--success)';
        btn.style.color = 'white';
      }
      this.showToast('✏️ Modo edición activado', 'success');
      console.log('✏️ Modo edición de cascada ACTIVADO');
    } else {
      if (btn) {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.color = '';
      }
      this.showToast('✅ Modo edición desactivado', 'info');
      console.log('✅ Modo edición de cascada DESACTIVADO');
    }
  },

  // Calcular estadísticas de la cascada
  updateCascadaStats(areas) {
    const statsAreas = document.getElementById('statsAreas');
    const statsMarcadores = document.getElementById('statsMarcadores');
    const statsSinJerarquia = document.getElementById('statsSinJerarquia');
    
    if (!statsAreas || !statsMarcadores || !statsSinJerarquia) return;
    
    // Contar áreas
    const totalAreas = areas.length;
    
    // Contar áreas sin jerarquía definida (todas vacías o "Sin...")
    const areasSinJerarquia = areas.filter(area => {
      const j = area.jerarquia || {};
      return (!j.planta || j.planta === 'Sin planta') && 
             (!j.areaGeneral || j.areaGeneral === 'Sin área') &&
             !j.subArea && !j.sistemaEquipo && !j.subSistema && !j.seccion;
    }).length;
    
    // Contar marcadores
    let totalMarcadores = 0;
    let marcadoresSinNivel = 0;
    
    const repuestos = app?.repuestos || [];
    repuestos.forEach(rep => {
      if (rep.ubicaciones && Array.isArray(rep.ubicaciones)) {
        rep.ubicaciones.forEach(ub => {
          if (ub.mapaId === this.state.currentMapId) {
            totalMarcadores++;
            if (!rep.nivelJerarquico || rep.nivelJerarquico === '') {
              marcadoresSinNivel++;
            }
          }
        });
      }
    });
    
    // Actualizar UI
    statsAreas.textContent = totalAreas;
    statsMarcadores.textContent = totalMarcadores;
    statsSinJerarquia.textContent = areasSinJerarquia + marcadoresSinNivel;
    
    // Cambiar color si hay elementos sin jerarquía
    const statsSinJerarquiaParent = statsSinJerarquia.parentElement;
    if (areasSinJerarquia + marcadoresSinNivel > 0) {
      statsSinJerarquiaParent.style.color = '#f59e0b';
    } else {
      statsSinJerarquiaParent.style.color = 'var(--text-secondary)';
    }
  },

  // Toggle mostrar solo elementos con jerarquía
  toggleMostrarSoloConJerarquia() {
    this.state.mostrarSoloConJerarquia = !this.state.mostrarSoloConJerarquia;
    const btn = document.getElementById('btnToggleVacias');
    
    if (this.state.mostrarSoloConJerarquia) {
      btn.textContent = '👁️ Mostrar vacías';
      btn.style.background = 'var(--primary)';
      btn.style.color = 'white';
    } else {
      btn.textContent = '👁️ Ocultar vacías';
      btn.style.background = '';
      btn.style.color = '';
    }
    
    // Refrescar vista
    this.openCascadaModal();
  },

  // 🌳 Construir árbol jerárquico de 6 niveles (MEJORADO: sin duplicados)
  buildHierarchyTree(areas) {
    const tree = {};
    
    // Filtrar áreas vacías si está activado
    let areasToProcess = areas;
    if (this.state.mostrarSoloConJerarquia) {
      areasToProcess = areas.filter(area => {
        const j = area.jerarquia || {};
        return (j.planta && j.planta !== 'Sin planta') || 
               (j.areaGeneral && j.areaGeneral !== 'Sin área') ||
               j.subArea || j.sistemaEquipo || j.subSistema || j.seccion;
      });
    }
    
    areasToProcess.forEach(area => {
      const jerarquia = area.jerarquia || {};
      const planta = jerarquia.planta || 'Sin planta';
      const areaGeneral = jerarquia.areaGeneral || 'Sin área';
      const subArea = jerarquia.subArea || null;
      const sistema = jerarquia.sistemaEquipo || null;
      const subSistema = jerarquia.subSistema || null;
      const seccion = jerarquia.seccion || null;
      
      // 🔍 DETECTAR NIVEL MÁS PROFUNDO - El área solo se agrega UNA VEZ en su nivel más específico
      let nivelMasProfundo = null;
      let targetNode = null;
      
      // Nivel 1: Planta
      if (!tree[planta]) tree[planta] = {};
      
      // Nivel 2: Área General
      if (!tree[planta][areaGeneral]) tree[planta][areaGeneral] = {};
      
      // Si no hay más niveles definidos, el área va aquí
      if (!subArea && !sistema && !subSistema && !seccion) {
        nivelMasProfundo = 'areaGeneral';
        targetNode = tree[planta][areaGeneral];
      }
      
      // Nivel 3: Sub-área
      if (subArea) {
        if (!tree[planta][areaGeneral][subArea]) tree[planta][areaGeneral][subArea] = {};
        
        // Si no hay más niveles, el área va aquí
        if (!sistema && !subSistema && !seccion) {
          nivelMasProfundo = 'subArea';
          targetNode = tree[planta][areaGeneral][subArea];
        }
        
        // Nivel 4: Sistema/Equipo
        if (sistema) {
          if (!tree[planta][areaGeneral][subArea][sistema]) tree[planta][areaGeneral][subArea][sistema] = {};
          
          // Si no hay más niveles, el área va aquí
          if (!subSistema && !seccion) {
            nivelMasProfundo = 'sistema';
            targetNode = tree[planta][areaGeneral][subArea][sistema];
          }
          
          // Nivel 5: Sub-sistema
          if (subSistema) {
            if (!tree[planta][areaGeneral][subArea][sistema][subSistema]) tree[planta][areaGeneral][subArea][sistema][subSistema] = {};
            
            // Si no hay más niveles, el área va aquí
            if (!seccion) {
              nivelMasProfundo = 'subSistema';
              targetNode = tree[planta][areaGeneral][subArea][sistema][subSistema];
            }
            
            // Nivel 6: Sección (nivel más profundo posible)
            if (seccion) {
              if (!tree[planta][areaGeneral][subArea][sistema][subSistema][seccion]) {
                tree[planta][areaGeneral][subArea][sistema][subSistema][seccion] = { _areas: [] };
              }
              nivelMasProfundo = 'seccion';
              targetNode = tree[planta][areaGeneral][subArea][sistema][subSistema][seccion];
            }
          }
        }
      }
      
      // 🎯 AGREGAR EL ÁREA SOLO UNA VEZ EN SU NIVEL MÁS PROFUNDO
      if (targetNode) {
        if (!targetNode._areas) {
          targetNode._areas = [];
        }
        // Evitar duplicados por ID
        if (!targetNode._areas.find(a => a.id === area.id)) {
          targetNode._areas.push(area);
        }
      }
    });
    
    return tree;
  },

  // 🎨 Renderizar árbol jerárquico completo (MEJORADO: ordenado alfabéticamente)
  renderHierarchyTree(tree, level = 0) {
    let html = '';
    const indent = level * 12; // 12px por nivel
    
    // 🆕 ORDENAR CLAVES alfabéticamente (español), _areas siempre al final
    const keys = Object.keys(tree).sort((a, b) => {
      if (a === '_areas') return 1; // _areas al final
      if (b === '_areas') return -1;
      return a.localeCompare(b, 'es', { sensitivity: 'base', numeric: true });
    });
    
    for (const key of keys) {
      if (key === '_areas') {
        // 🆕 ORDENAR ÁREAS alfabéticamente por nombre
        const areasOrdenadas = [...tree[key]].sort((a, b) => {
          return (a.name || '').localeCompare(b.name || '', 'es', { sensitivity: 'base' });
        });
        
        // Renderizar áreas en este nivel
        areasOrdenadas.forEach(area => {
          html += this.renderAreaItem(area, indent, level);
        });
      } else {
        // Renderizar nodo de jerarquía
        const childrenHTML = this.renderHierarchyTree(tree[key], level + 1);
        const hasChildren = childrenHTML.trim().length > 0;
        
        // 🆕 Badge de nivel jerárquico - MOVIDO A LA IZQUIERDA
        const nivelBadge = `<span style="
          background: rgba(59, 130, 246, 0.2);
          color: #60a5fa;
          padding: 1px 4px;
          border-radius: 2px;
          font-size: 0.65rem;
          font-weight: 600;
          font-family: monospace;
          min-width: 22px;
          text-align: center;
        ">N${level}</span>`;
        
        html += `
          <div style="margin-bottom: 1px;">
            <div style="
              padding: 4px 6px;
              padding-left: ${indent + 6}px;
              background: rgba(255,255,255,0.02);
              border-left: 2px solid rgba(100,100,100,0.3);
              font-size: 0.75rem;
              font-weight: 600;
              color: #d4d4d4;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
            " onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.toggle').textContent = this.nextElementSibling.style.display === 'none' ? '>' : 'v'">
              <span class="toggle" style="font-size: 0.7rem; width: 8px; font-family: monospace;">${hasChildren ? 'v' : '>'}</span>
              ${nivelBadge}
              <span style="flex: 1;">${this.escapeHtml(key)}</span>
            </div>
            <div style="display: ${hasChildren ? 'block' : 'none'};">
              ${childrenHTML}
            </div>
          </div>
        `;
      }
    }
    
    return html;
  },

  // 📍 Renderizar item de área individual
  renderAreaItem(area, indent, level = 0) {
    const color = area.color || '#3b82f6';
    const category = area.category || 'area';
    
    // 🆕 Obtener marcadores agrupados por categoría para esta área
    const marcadoresPorCategoria = this.getMarcadoresPorArea(area.id);
    const totalMarcadores = Object.values(marcadoresPorCategoria).reduce((sum, markers) => sum + markers.length, 0);

    // 🆕 Badge de nivel jerárquico para área (nivel+1 porque el área es un nivel más profundo que su nodo padre)
    const nivelBadge = `<span style="
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
      padding: 1px 4px;
      border-radius: 2px;
      font-size: 0.65rem;
      font-weight: 600;
      font-family: monospace;
      margin-left: 4px;
    ">N${level + 1}</span>`;

    // Generar HTML para las categorías y marcadores
    let categoriasHTML = '';
    const categorias = Object.keys(marcadoresPorCategoria).sort();
    
    if (categorias.length > 0) {
      categoriasHTML = categorias.map(catNombre => {
        const marcadores = marcadoresPorCategoria[catNombre];
        
        const marcadoresHTML = marcadores.map(m => {
          // Mostrar número correlativo solo si hay más de 1 instancia
          const showCorrelativo = m.totalInstancias > 1;
          
          return `
          <div class="marker-item" style="
            padding: 3px 8px;
            padding-left: ${indent + 24}px;
            font-size: 0.72rem;
            color: #bbb;
            cursor: pointer;
            transition: all 0.1s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
          " 
          onmouseover="this.style.background='rgba(255,255,255,0.05)'; this.style.color='#fff'; this.querySelector('.marker-edit-btn').style.opacity='1'"
          onmouseout="this.style.background='transparent'; this.style.color='#bbb'; this.querySelector('.marker-edit-btn').style.opacity='0'">
            <span onclick="mapController.focusOnMarker('${m.repuesto.id}', ${m.ubicacionIndex})" style="flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; gap: 4px;">
              <span style="overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(m.repuesto.nombre || 'Sin nombre')}</span>
              ${showCorrelativo ? `<span style="
                background: #222;
                color: #fff;
                padding: 1px 4px;
                border-radius: 2px;
                font-size: 0.65rem;
                font-weight: 600;
                font-family: monospace;
                flex-shrink: 0;
              ">#${m.numeroCorrelativo}</span>` : ''}
            </span>
            <button 
              class="marker-edit-btn"
              onclick="event.stopPropagation(); mapController.openEditMarkerModal('${m.repuesto.id}', ${m.ubicacionIndex})" 
              style="
                opacity: 0;
                transition: opacity 0.15s;
                background: none;
                border: none;
                color: #888;
                cursor: pointer;
                padding: 0;
                font-size: 0.7rem;
              " 
              title="Editar marcador">E</button>
          </div>
        `;
        }).join('');
        
        return `
          <div class="categoria-group" style="
            display: block;
            border-left: 1px solid rgba(255,255,255,0.05);
            margin-bottom: 1px;
          ">
            <div class="categoria-header" style="
              padding: 3px 8px;
              padding-left: ${indent + 16}px;
              font-size: 0.72rem;
              font-weight: 500;
              color: #aaa;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              transition: background 0.1s;
            "
            onclick="mapController.toggleCategoria(this)"
            onmouseover="this.style.background='rgba(255,255,255,0.03)'"
            onmouseout="this.style.background='transparent'">
              <span class="categoria-toggle" style="
                font-size: 0.7rem; 
                font-family: monospace;
                width: 8px;
              ">v</span>
              <span>${catNombre}</span>
              <span style="
                font-size: 0.65rem;
                color: #666;
                background: rgba(255,255,255,0.05);
                padding: 1px 5px;
                border-radius: 3px;
                margin-left: auto;
              ">${marcadores.length}</span>
            </div>
            <div class="categoria-marcadores" style="display: block;">
              ${marcadoresHTML}
            </div>
          </div>
        `;
      }).join('');
    }
    
    return `
      <div style="
        padding: 4px 6px;
        padding-left: ${indent + 6}px;
        background: rgba(255,255,255,0.02);
        border-left: 2px solid ${color};
        font-size: 0.75rem;
        font-weight: 500;
        color: #d4d4d4;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        position: relative;
        margin-bottom: 1px;
      "
      data-area-id="${area.id}"
      onmouseover="this.querySelector('.map-area-actions').style.opacity='1'"
      onmouseout="this.querySelector('.map-area-actions').style.opacity='0'">
        <div class="area-toggle" 
             onclick="mapController.toggleArea(this)" 
             style="
               cursor: pointer; 
               font-size: 0.7rem;
               font-family: monospace;
               user-select: none;
               width: 8px;
             ">${totalMarcadores > 0 ? 'v' : '>'}</div>
        <span style="
          background: rgba(59, 130, 246, 0.3);
          color: #60a5fa;
          padding: 1px 5px;
          border-radius: 2px;
          font-size: 0.65rem;
          font-weight: 700;
          font-family: monospace;
        ">ÁREA</span>
        ${nivelBadge}
        <div class="map-area-content" 
             data-action="focus-area" 
             style="flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
          ${this.escapeHtml(area.name || 'Area sin nombre')}${totalMarcadores > 0 ? ` (${totalMarcadores})` : ''}
        </div>
        <div class="map-area-actions" style="
          display: flex; 
          gap: 6px;
          opacity: 0;
          transition: opacity 0.15s;
          font-size: 0.7rem;
          color: #888;
        ">
          <span data-action="edit-area-hierarchy" data-area-id="${area.id}" title="Editar jerarquía" style="cursor: pointer; color: #8b5cf6;">J</span>
          <span data-action="edit-area-points" data-area-id="${area.id}" title="Editar forma" style="cursor: pointer;">E</span>
          <span data-action="edit-area-metadata" data-area-id="${area.id}" title="Editar datos" style="cursor: pointer;">C</span>
          <span data-action="delete-area" data-area-id="${area.id}" title="Eliminar" style="cursor: pointer; color: #c55;">X</span>
        </div>
      </div>
      ${totalMarcadores > 0 ? `
        <div class="area-children" style="display: block;">
          ${categoriasHTML}
        </div>
      ` : ''}
    `;
  },

  // 📂 NUEVO: Aplicar filtro de categoría
  applyCategoryFilter(category) {
    console.log(`📂 Filtro de categoría aplicado: ${category}`);
    
    if (category === 'all') {
      this.state.categoryFilter = null;
    } else {
      this.state.categoryFilter = category;
    }
    
    // Re-renderizar la lista con el filtro aplicado
    this.renderAreaList(this.state.areas);
    
    // Mostrar toast informativo
    const categoryName = category === 'all' 
      ? 'Todas las categorías' 
      : this.categories[category]?.name || category;
    this.showToast(`Filtrando: ${categoryName}`, 'info');
  },

  async selectMap(mapId, options = {}) {
    if (!mapId) return;
    if (!mapStorage.initialized) {
      this.showToast('Conecta la carpeta primero.', 'warning');
      return;
    }

    const numericId = typeof mapId === 'string' ? parseInt(mapId, 10) : mapId;
    const map = mapStorage.getMapById(numericId);

    if (!map) {
      this.showToast('Mapa no encontrado.', 'warning');
      return;
    }

    this.state.currentMapId = map.id;
    this.state.currentMap = map;
    this.state.areas = mapStorage.getAreasByMap(map.id);
    this.state.highlightAreaId = null;

    if (!options.keepViewport) {
      this.state.scale = 1;
      this.state.offsetX = 0;
      this.state.offsetY = 0;
    }

    await this.loadMapImage(map, options);
    this.renderMapList(mapStorage.maps);
    this.renderAreaList(this.state.areas);
    this.updateMetaBadge();
    this.syncButtonStates(); // 🆕 Sincronizar estado visual de botones
  },

  async loadMapImage(map, options = {}) {
    this.cleanupImage();

    if (!map.imagePath) {
      this.drawMessage('El mapa seleccionado no tiene imagen asociada.');
      return;
    }

    try {
      const file = await mapStorage.getMapImage(map);
      if (!file) {
        this.drawMessage('No se encontró la imagen del mapa.');
        return;
      }

      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        this.state.currentImage = img;
        this.state.currentImageUrl = url;
        this.configureCanvasForImage(img, options);
        this.draw();
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        this.drawMessage('Error cargando la imagen del mapa.');
      };
      img.src = url;
    } catch (error) {
      console.error('Error cargando imagen del mapa:', error);
      this.drawMessage('No se pudo cargar la imagen del mapa.');
    }
  },

  configureCanvasForImage(img, options = {}) {
    const canvas = this.elements.canvas;
    if (!canvas) return;

    const container = this.elements.canvasStage || canvas.parentElement;
    if (container) {
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      
      // ✅ Buffer del canvas = tamaño del contenedor
      canvas.width = containerWidth;
      canvas.height = containerHeight;
      
      // ✅ Canvas CSS ocupa TODO el contenedor amarillo
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    } else {
      // Fallback
      canvas.width = img.width;
      canvas.height = img.height;
    }

    if (!options.keepViewport) {
      this.state.scale = 1;
      this.state.offsetX = 0;
      this.state.offsetY = 0;
    }

    this.updateZoomBadge();
  },

  cleanupImage() {
    if (this.state.currentImageUrl) {
      try {
        URL.revokeObjectURL(this.state.currentImageUrl);
      } catch (error) {
        console.debug('cleanupImage revoke fall:', error);
      }
    }
    this.state.currentImageUrl = null;
    this.state.currentImage = null;
  },

  handleResize() {
    if (!this.elements.canvas) return;
    if (!this.state.currentImage) {
      this.resizeCanvas();
      return;
    }

    // ✅ Canvas siempre ocupa TODO el contenedor amarillo (100%)
    this.elements.canvas.style.width = '100%';
    this.elements.canvas.style.height = '100%';

    this.draw();
  },

  resizeCanvas() {
    const canvas = this.elements.canvas;
    if (!canvas) return;

    if (!this.state.currentImage) {
      const container = this.elements.canvasStage || canvas.parentElement;
      const rectWidth = container ? container.clientWidth : 640;
      const rectHeight = container ? container.clientHeight : 480;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.max(1, Math.round(rectWidth * dpr));
      canvas.height = Math.max(1, Math.round(rectHeight * dpr));
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.drawMessage('Conecta la carpeta INVENTARIO_STORAGE para comenzar.');
    } else {
      this.handleResize();
    }
  },

  drawMessage(message) {
    const canvas = this.elements.canvas;
    if (!canvas || !this.ctx) return;
    const ctx = this.ctx;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(148, 163, 184, 0.9)';
    ctx.font = '16px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(message, canvas.width / 2, canvas.height / 2);
    ctx.restore();
  },

  draw() {
    const canvas = this.elements.canvas;
    if (!canvas || !this.ctx) return;

    const ctx = this.ctx;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ✅ Aplicar transformaciones de pan y zoom
    ctx.translate(this.state.offsetX, this.state.offsetY);
    ctx.scale(this.state.scale, this.state.scale);
    
    if (this.state.currentImage) {
      // ✅ SIMPLE: Dibujar imagen en tamaño nativo (el CSS maneja el escalado visual)
      ctx.drawImage(this.state.currentImage, 0, 0);
    }

    if (this.state.showGrid) {
      this.drawGrid(ctx);
    }

    this.drawAreas(ctx);
    this.drawTempShape(ctx);
    this.drawEditPoints(ctx);

    // 🎯 ETAPA 3.2: Dibujar handles de reshape
    if (this.state.isReshapeMode && this.state.reshapeAreaId) {
      this.drawReshapeHandles(ctx);
    }

    // 🎯 NUEVO: Dibujar marcadores de repuestos
    this.drawMarkers(ctx);
    
    // 🆕 NUEVO: Dibujar ubicaciones resaltadas (con animación)
    this.dibujarUbicacionesResaltadas(ctx);

    ctx.restore();
    this.updateZoomBadge();
    
    // 📏 NUEVO: Dibujar reglas si están activadas
    if (this.state.showRulers) {
      this.drawRulers();
    }
    
    // 🗺️ NUEVO: Dibujar minimap si está activado
    if (this.state.showMinimap && this.state.currentImage) {
      this.drawMinimap();
    }
  },

  // Rendering optimizado con requestAnimationFrame
  scheduleRender() {
    if (this.state.animationFrameId) {
      return; // Ya hay un render pendiente
    }
    this.state.animationFrameId = requestAnimationFrame(() => {
      this.draw();
      this.state.animationFrameId = null;
    });
  },

  drawCanvas() {
    // Alias para draw()
    this.draw();
  },

  drawGrid(ctx) {
    if (!this.state.currentImage) return;
    const step = this.state.gridSize || 50; // 📏 Usar gridSize configurable
    const width = this.state.currentImage.width;
    const height = this.state.currentImage.height;
    ctx.save();
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.25)';
    ctx.lineWidth = 1 / this.state.scale;

    for (let x = step; x < width; x += step) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    for (let y = step; y < height; y += step) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }

    ctx.restore();
  },

  // 📏 NUEVO: Dibujar reglas laterales con medidas
  drawRulers() {
    if (!this.state.showRulers || !this.state.currentImage) return;

    const canvas = this.elements.canvas;
    const ctx = this.ctx;
    const rulerSize = 30; // Ancho/alto de las reglas en píxeles
    const gridSize = this.state.gridSize || 50;

    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Resetear transformación

    // Fondo de las reglas
    ctx.fillStyle = 'rgba(15, 23, 42, 0.9)';
    
    // Regla horizontal (arriba)
    ctx.fillRect(rulerSize, 0, canvas.width - rulerSize, rulerSize);
    
    // Regla vertical (izquierda)
    ctx.fillRect(0, rulerSize, rulerSize, canvas.height - rulerSize);
    
    // Esquina (intersección)
    ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
    ctx.fillRect(0, 0, rulerSize, rulerSize);

    // Configuración de texto
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Calcular rango visible en coordenadas del mundo
    const viewLeft = -this.state.offsetX / this.state.scale;
    const viewRight = (canvas.width - this.state.offsetX) / this.state.scale;
    const viewTop = -this.state.offsetY / this.state.scale;
    const viewBottom = (canvas.height - this.state.offsetY) / this.state.scale;

    // Dibujar marcas horizontales (regla superior)
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
    ctx.fillStyle = 'rgba(226, 232, 240, 0.9)';
    ctx.lineWidth = 1;

    const startX = Math.floor(viewLeft / gridSize) * gridSize;
    for (let x = startX; x <= viewRight; x += gridSize) {
      const screenX = x * this.state.scale + this.state.offsetX;
      if (screenX < rulerSize || screenX > canvas.width) continue;

      // Línea de marca
      ctx.beginPath();
      ctx.moveTo(screenX, rulerSize - 8);
      ctx.lineTo(screenX, rulerSize);
      ctx.stroke();

      // Número
      if (x % (gridSize * 2) === 0) { // Mostrar cada 2 marcas
        ctx.fillText(Math.round(x).toString(), screenX, rulerSize / 2);
      }
    }

    // Dibujar marcas verticales (regla izquierda)
    ctx.textAlign = 'left';
    const startY = Math.floor(viewTop / gridSize) * gridSize;
    for (let y = startY; y <= viewBottom; y += gridSize) {
      const screenY = y * this.state.scale + this.state.offsetY;
      if (screenY < rulerSize || screenY > canvas.height) continue;

      // Línea de marca
      ctx.beginPath();
      ctx.moveTo(rulerSize - 8, screenY);
      ctx.lineTo(rulerSize, screenY);
      ctx.stroke();

      // Número (rotado)
      if (y % (gridSize * 2) === 0) {
        ctx.save();
        ctx.translate(rulerSize / 2, screenY);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText(Math.round(y).toString(), 0, 0);
        ctx.restore();
      }
    }

    // Borde de las reglas
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(rulerSize, 0, canvas.width - rulerSize, rulerSize);
    ctx.strokeRect(0, rulerSize, rulerSize, canvas.height - rulerSize);

    ctx.restore();
  },

  drawAreas(ctx) {
    if (!Array.isArray(this.state.areas) || !this.state.areas.length) return;

    ctx.save();
    this.state.areas.forEach(area => {
      if (!Array.isArray(area.points) || area.points.length < 3) return;
      const color = area.color || '#3b82f6';
      const opacity = typeof area.opacity === 'number' ? area.opacity : 0.35;
      
      // 🎯 ETAPA 3.1: Verificar si el área está seleccionada
      const isSelected = this.state.selectedAreaIds.includes(area.id);
      
      ctx.beginPath();
      area.points.forEach((point, index) => {
        if (index === 0) ctx.moveTo(point.x, point.y);
        else ctx.lineTo(point.x, point.y);
      });
      ctx.closePath();
      
      // 🔥 Si es el área resaltada, usar relleno amarillo brillante
      if (area.id === this.state.highlightAreaId) {
        ctx.fillStyle = 'rgba(251, 191, 36, 0.4)'; // Amarillo brillante semi-transparente
      } else {
        ctx.fillStyle = this.hexToRgba(color, opacity);
      }
      
      // 🎯 Cambiar estilo de borde según estado
      if (isSelected) {
        ctx.strokeStyle = '#10b981'; // Verde para seleccionadas
        ctx.lineWidth = 4 / this.state.scale;
      } else if (area.id === this.state.highlightAreaId) {
        // 🔥 ÁREA RESALTADA - EFECTO SUPER VISIBLE
        // Sombra exterior brillante (resplandor)
        ctx.shadowColor = '#fbbf24'; // Amarillo brillante
        ctx.shadowBlur = 20 / this.state.scale;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Borde amarillo grueso
        ctx.strokeStyle = '#fbbf24'; // Amarillo muy visible
        ctx.lineWidth = 6 / this.state.scale;
      } else {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2 / this.state.scale;
      }
      
      ctx.fill();
      ctx.stroke();
      
      // Limpiar sombra para el resto del dibujo
      ctx.shadowBlur = 0;

      // 🆕 Solo dibujar nombres si están habilitados
      if (this.state.mostrarNombresAreas) {
        const centroid = this.calculateCentroid(area.points);
        if (centroid) {
          // 🎨 ETAPA 2: Etiqueta mejorada con fondo semi-transparente y texto multi-línea
          ctx.save();
          
          // Obtener offset personalizado (por defecto 0, 0)
          const labelOffsetX = area.labelOffsetX || 0;
          const labelOffsetY = area.labelOffsetY || 0;
          const labelX = centroid.x + labelOffsetX;
          const labelY = centroid.y + labelOffsetY;
          
          // 🆕 TAMAÑO DE FUENTE ADAPTATIVO AL ZOOM
          // Formula mejorada: Tamaño base decrece con el zoom para no ocupar tanto espacio
          // Zoom 1.0 (normal): 28px
          // Zoom 0.5 (alejado 2x): 20px
          // Zoom 0.25 (alejado 4x): 14px (mínimo)
          const baseFontSize = 28;
          const minFontSize = 14;
          const zoomFactor = this.state.zoom || 1.0;
          
          // Aplicar raíz cuadrada para suavizar el cambio
        const fontSize = Math.max(minFontSize, baseFontSize / Math.sqrt(zoomFactor));
        
        ctx.font = `bold ${fontSize}px "Segoe UI", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 🆕 MEJORA: Dividir texto largo en múltiples líneas (máximo 20 caracteres por línea)
        const text = area.name || 'Área';
        const maxCharsPerLine = 20;
        const lines = [];
        
        if (text.length <= maxCharsPerLine) {
          lines.push(text);
        } else {
          // Dividir por palabras para no cortar a la mitad
          const words = text.split(' ');
          let currentLine = '';
          
          words.forEach((word, idx) => {
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            if (testLine.length <= maxCharsPerLine) {
              currentLine = testLine;
            } else {
              if (currentLine) lines.push(currentLine);
              currentLine = word;
            }
            if (idx === words.length - 1 && currentLine) {
              lines.push(currentLine);
            }
          });
        }
        
        // Medir el ancho máximo de todas las líneas
        let maxWidth = 0;
        lines.forEach(line => {
          const metrics = ctx.measureText(line);
          if (metrics.width > maxWidth) maxWidth = metrics.width;
        });
        
        const textWidth = maxWidth;
        const lineHeight = fontSize * 1.2;
        const textHeight = lineHeight * lines.length;
        
        // 🆕 Padding interno adaptativo al zoom (más pequeño cuando hay zoom)
        const paddingX = Math.max(6, 12 / Math.sqrt(zoomFactor));
        const paddingY = Math.max(4, 8 / Math.sqrt(zoomFactor));
        
        // Dimensiones del rectángulo
        const rectWidth = textWidth + paddingX * 2;
        const rectHeight = textHeight + paddingY * 2;
        const rectX = labelX - rectWidth / 2;
        const rectY = labelY - rectHeight / 2;
        
        // 🎨 MEJORA: Fondo semi-transparente con efecto glassmorphism
        const isSelected = this.state.selectedAreaIds.includes(area.id);
        const isHighlighted = area.id === this.state.highlightAreaId;
        
        // 🆕 Sombra adaptativa al zoom
        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = Math.max(4, 8 / Math.sqrt(zoomFactor));
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = Math.max(1, 2 / Math.sqrt(zoomFactor));
        
        // Fondo con gradiente sutil
        const gradient = ctx.createLinearGradient(rectX, rectY, rectX, rectY + rectHeight);
        if (isSelected) {
          gradient.addColorStop(0, 'rgba(209, 250, 229, 0.95)');  // Verde claro
          gradient.addColorStop(1, 'rgba(167, 243, 208, 0.95)');
        } else if (isHighlighted) {
          gradient.addColorStop(0, 'rgba(254, 249, 195, 0.95)');  // Amarillo claro
          gradient.addColorStop(1, 'rgba(253, 230, 138, 0.95)');
        } else {
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.92)');  // Blanco semi-transparente
          gradient.addColorStop(1, 'rgba(249, 250, 251, 0.92)');
        }
        ctx.fillStyle = gradient;
        
        // 🆕 Rectángulo con bordes redondeados adaptativos
        const radius = Math.max(3, 6 / Math.sqrt(zoomFactor));
        ctx.beginPath();
        ctx.moveTo(rectX + radius, rectY);
        ctx.lineTo(rectX + rectWidth - radius, rectY);
        ctx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
        ctx.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
        ctx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
        ctx.lineTo(rectX + radius, rectY + rectHeight);
        ctx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
        ctx.lineTo(rectX, rectY + radius);
        ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
        ctx.closePath();
        ctx.fill();
        
        // Remover sombra para el borde
        ctx.shadowBlur = 0;
        
        // Dibujar borde (verde si seleccionado, amarillo si resaltado, gris si normal)
        if (isSelected) {
          ctx.strokeStyle = '#10b981';
          ctx.lineWidth = 3 / this.state.scale;
        } else if (isHighlighted) {
          ctx.strokeStyle = '#facc15';
          ctx.lineWidth = 3 / this.state.scale;
        } else {
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.lineWidth = 2 / this.state.scale;
        }
        ctx.stroke();
        
        // 🆕 MEJORA: Dibujar texto multi-línea con mejor contraste
        ctx.fillStyle = isSelected ? '#064e3b' : (isHighlighted ? '#713f12' : '#1f2937');
        ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        ctx.shadowBlur = 3 / this.state.scale;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Calcular posición Y inicial (centrada verticalmente)
        const startY = labelY - (textHeight / 2) + (lineHeight / 2);
        
        lines.forEach((line, idx) => {
          const lineY = startY + (idx * lineHeight);
          ctx.fillText(line, labelX, lineY);
        });
        
        ctx.shadowBlur = 0;
        
        // 🎯 Agregar check mark si está seleccionado
        if (isSelected) {
          ctx.font = `bold ${fontSize * 0.9}px "Segoe UI", sans-serif`;
          ctx.fillStyle = '#10b981';
          ctx.shadowBlur = 0;
          ctx.fillText('✓', rectX + rectWidth + (paddingX * 1.5), labelY);
        }
        
        // 🏷️ ICONOS DE CATEGORÍA REMOVIDOS (ocupaban mucho espacio)
        // Los nombres ahora se muestran sin iconos para mejor legibilidad
        
        ctx.restore();
        } // Fin del if mostrarNombresAreas
      } // Fin del if centroid
    });
    ctx.restore();
  },

  // 🎯 NUEVO: Dibujar marcadores de repuestos en el mapa
  drawMarkers(ctx) {
    // 🆕 MODIFICADO: Si el botón está OFF, solo mostrar el marcador seleccionado
    // Si está ON, mostrar todos los marcadores
    
    if (!app || !app.repuestos) return;
    
    ctx.save();
    
    // 🆕 Usar función centralizada para correlativos
    const correlativosGlobales = this.calcularCorrelativosGlobales(this.state.currentMapId);
    
    // 🆕 PASO 2: Buscar repuestos con ubicaciones en el mapa actual y asignar número correlativo
    const marcadores = [];
    
    app.repuestos.forEach(repuesto => {
      // Formato NUEVO: array de ubicaciones
      if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
        repuesto.ubicaciones.forEach((ub, index) => {
          if (String(ub.mapId) === String(this.state.currentMapId) && ub.markerX && ub.markerY) {
            const corrInfo = correlativosGlobales[repuesto.id]?.[index] || { numero: 1, total: 1 };
            marcadores.push({
              repuesto: repuesto,
              x: ub.markerX,
              y: ub.markerY,
              areaId: ub.areaId,
              ubicacionIndex: index,
              numeroCorrelativo: corrInfo.numero,
              totalInstancias: corrInfo.total
            });
          }
        });
      }
      
      // Formato ANTIGUO: propiedades directas (compatibilidad)
      if (repuesto.mapId && String(repuesto.mapId) === String(this.state.currentMapId) && repuesto.markerX && repuesto.markerY) {
        const corrInfo = correlativosGlobales[repuesto.id]?.[0] || { numero: 1, total: 1 };
        marcadores.push({
          repuesto: repuesto,
          x: repuesto.markerX,
          y: repuesto.markerY,
          areaId: repuesto.areaId,
          ubicacionIndex: 0,
          numeroCorrelativo: corrInfo.numero,
          totalInstancias: corrInfo.total
        });
      }
    });
    
    // 🆕 FILTRAR: Si hay un repuesto filtrado, mostrar solo sus marcadores
    let marcadoresFiltrados = marcadores;
    if (this.state.repuestoFiltrado) {
      marcadoresFiltrados = marcadores.filter(m => 
        String(m.repuesto.id) === String(this.state.repuestoFiltrado)
      );
      console.log(`🔍 Filtro activo: Mostrando ${marcadoresFiltrados.length} de ${marcadores.length} marcadores`);
    }
    
    // 🆕 NUEVO FILTRO: Si el botón de puntos está OFF, solo mostrar el marcador seleccionado
    if (!this.state.mostrarPuntosRepuestos) {
      if (this.state.highlightMarker) {
        // Solo mostrar el marcador resaltado
        marcadoresFiltrados = marcadores.filter(m => 
          String(m.repuesto.id) === String(this.state.highlightMarker.repuestoId) &&
          m.ubicacionIndex === this.state.highlightMarker.ubicacionIndex
        );
        console.log(`👁️ Botón OFF: Mostrando solo marcador seleccionado`);
      } else {
        // No hay selección, no mostrar nada
        ctx.restore();
        return;
      }
    }
    
    // 🆕 Si hay un marcador siendo arrastrado, dibujarlo en posición temporal
    if (this.state.marcadorArrastre && this.state.marcadorArrastre.iniciado) {
      const { info, mapX, mapY } = this.state.marcadorArrastre;
      
  // Dibujar marcador en posición temporal con efecto fantasma
  this.dibujarMarcadorIndividual(ctx, info.repuesto, mapX, mapY, info.ubicacion.areaId, true, 1.0, info.ubicacionIndex, info.numeroCorrelativo, info.totalInstancias);
      
      // También mostrar la posición original con opacidad reducida
      marcadoresFiltrados.forEach((m, i) => {
        const esElMismomarcador = m.repuesto.id === info.repuesto.id && 
                                  Math.abs(m.x - info.x) < 1 && 
                                  Math.abs(m.y - info.y) < 1;
        
  this.dibujarMarcadorIndividual(ctx, m.repuesto, m.x, m.y, m.areaId, false, esElMismomarcador ? 0.3 : 1.0, m.ubicacionIndex, m.numeroCorrelativo, m.totalInstancias);
      });
    } else {
      // Dibujar todos los marcadores (filtrados o todos)
    if (marcadoresFiltrados.length === 0) {
      ctx.restore();
      return;
    }
    
    // console.log(`🎯 Dibujando ${marcadoresFiltrados.length} marcadores en el mapa`);
    
    marcadoresFiltrados.forEach(({ repuesto, x, y, areaId, ubicacionIndex, numeroCorrelativo, totalInstancias }) => {
      this.dibujarMarcadorIndividual(ctx, repuesto, x, y, areaId, false, 1.0, ubicacionIndex, numeroCorrelativo, totalInstancias);
    });
  }    ctx.restore();
  },
  
  // 🆕 NUEVA FUNCIÓN: Dibujar un marcador individual
  dibujarMarcadorIndividual(ctx, repuesto, x, y, areaId, esPreview = false, opacidad = 1.0, ubicacionIndex = null, numeroCorrelativo = null, totalInstancias = 1) {
    ctx.save();
    
    // Verificar si este es el pin en modo edición
    const esEdicionPin = this.state.pinAMover && 
                         this.state.pinAMover.editando && 
                         String(repuesto.id) === String(this.state.pinAMover.repuestoId);
    
    // 🆕 Verificar si este marcador está resaltado (highlight)
    // IMPORTANTE: Verificar también el ubicacionIndex para resaltar solo el correcto
  const esResaltado = this.state.highlightMarker &&
            String(repuesto.id) === String(this.state.highlightMarker.repuestoId) &&
            (ubicacionIndex !== null && ubicacionIndex === this.state.highlightMarker.ubicacionIndex);
    
    // Si es preview, aplicar efecto pulsante
    if (esPreview) {
      ctx.globalAlpha = 0.8;
      const pulso = Math.sin(Date.now() / 100) * 0.1 + 0.9;
      // No aplicar scale, solo dibujar en la posición temporal
    } else if (esResaltado) {
      // 🆕 Efecto pulsante para marcador resaltado
      ctx.globalAlpha = 1.0;
    } else {
      ctx.globalAlpha = opacidad;
    }
    
    // 📍 Dibujar marcador tipo "pin"
    // 🔧 CORRECCIÓN: Aplicar efecto pulsante al tamaño en lugar de ctx.scale()
    // para evitar que el marcador se "mueva" por el escalado desde origen (0,0)
    const pulsoMultiplicador = esResaltado ? (Math.sin(Date.now() / 200) * 0.15 + 1.15) : 1.0;
    const pinHeight = Math.max(30, 40 / this.state.scale) * pulsoMultiplicador;
    const pinWidth = Math.max(20, 26 / this.state.scale) * pulsoMultiplicador;
    
    // 🌟 EFECTO HALO: Dibujar aura pulsante para marcador resaltado
    if (esResaltado) {
      const haloPulso = Math.sin(Date.now() / 300) * 0.3 + 0.7; // Pulso suave entre 0.4 y 1.0
      const haloRadius = (pinWidth * 1.8) * haloPulso;
      
      // Dibujar múltiples anillos semi-transparentes para efecto de "ondas"
      for (let i = 3; i >= 1; i--) {
        ctx.beginPath();
        ctx.arc(x, y - pinHeight / 2, haloRadius * (1 + i * 0.15), 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(251, 191, 36, ${0.2 / i})`; // Amarillo dorado semi-transparente
        ctx.lineWidth = Math.max(2, 4 / this.state.scale);
        ctx.stroke();
      }
      
      // Círculo de relleno suave en el centro del halo
      const gradientHalo = ctx.createRadialGradient(x, y - pinHeight / 2, 0, x, y - pinHeight / 2, haloRadius);
      gradientHalo.addColorStop(0, 'rgba(251, 191, 36, 0.15)');
      gradientHalo.addColorStop(0.7, 'rgba(251, 191, 36, 0.05)');
      gradientHalo.addColorStop(1, 'rgba(251, 191, 36, 0)');
      
      ctx.fillStyle = gradientHalo;
      ctx.beginPath();
      ctx.arc(x, y - pinHeight / 2, haloRadius * 1.3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Sombra del pin (más pronunciada para marcador resaltado)
    if (esResaltado) {
      ctx.shadowColor = 'rgba(251, 191, 36, 0.8)'; // Sombra amarilla para resaltado
      ctx.shadowBlur = 25 / this.state.scale;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 8 / this.state.scale;
    } else {
      ctx.shadowColor = esPreview ? 'rgba(59, 130, 246, 0.6)' : 
                        esEdicionPin ? 'rgba(249, 115, 22, 0.6)' : 
                        'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 15 / this.state.scale;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 5 / this.state.scale;
    }
    
    // Color según stock o modo edición
    const cantidad = repuesto.cantidad || 0;
    const minimo = repuesto.minimo || 5;
    let markerColor, markerBorder;
    
    if (esEdicionPin) {
      // 🔥 NARANJA para modo edición (como cuando editas áreas)
      markerColor = '#f97316'; // Naranja brillante
      markerBorder = '#ea580c';
    } else if (esResaltado) {
      // 🆕 AMARILLO BRILLANTE para marcador resaltado
      markerColor = '#fbbf24'; // Amarillo dorado
      markerBorder = '#f59e0b';
    } else if (esPreview) {
      markerColor = '#3b82f6'; // Azul para preview
      markerBorder = '#2563eb';
    } else if (cantidad === 0) {
      markerColor = '#ef4444'; // Rojo - sin stock
      markerBorder = '#dc2626';
    } else if (cantidad < minimo) {
      markerColor = '#f59e0b'; // Naranja - bajo stock
      markerBorder = '#d97706';
    } else {
      markerColor = '#10b981'; // Verde - stock OK
      markerBorder = '#059669';
    }
    
    // Dibujar forma de pin (gota invertida)
    ctx.beginPath();
    
    // Círculo superior del pin
    const circleRadius = pinWidth / 2;
    ctx.arc(x, y - pinHeight + circleRadius, circleRadius, 0, Math.PI * 2);
    
    // Punta del pin (triángulo hacia abajo)
    ctx.moveTo(x - circleRadius * 0.5, y - circleRadius);
    ctx.lineTo(x, y);
    ctx.lineTo(x + circleRadius * 0.5, y - circleRadius);
    
    ctx.fillStyle = markerColor;
    ctx.fill();
    
    // Borde del pin
    ctx.strokeStyle = markerBorder;
    ctx.lineWidth = Math.max(1.5, 2 / this.state.scale);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Punto central blanco dentro del círculo
    ctx.beginPath();
    ctx.arc(x, y - pinHeight + circleRadius, circleRadius * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    
    // 🏷️ Etiqueta del repuesto (ESCALADA SEGÚN ZOOM)
    // Fórmula similar a nombres de áreas: baseFontSize / √zoomFactor
    const baseFontSize = 18;
    const minFontSize = 10;
    const zoomFactor = this.state.zoom || 1.0;
    const fontSize = Math.max(minFontSize, baseFontSize / Math.sqrt(zoomFactor));
    
    ctx.font = `bold ${fontSize}px "Segoe UI", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    
    // Limitar longitud del texto
    let text = repuesto.nombre;
    if (text.length > 20) {
      text = text.substring(0, 17) + '...';
    }
    
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    
    // Padding adaptativo según zoom
    const paddingX = Math.max(4, 8 / Math.sqrt(zoomFactor));
    const paddingY = Math.max(2.5, 5 / Math.sqrt(zoomFactor));
    
    // Fondo de la etiqueta con bordes redondeados
    const rectX = x - textWidth / 2 - paddingX;
    const rectY = y - pinHeight - fontSize - paddingY * 2.5;
    const rectWidth = textWidth + paddingX * 2;
    const rectHeight = fontSize + paddingY * 2;
    const cornerRadius = Math.max(2, 4 / Math.sqrt(zoomFactor));
    
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = Math.max(5, 10 / Math.sqrt(zoomFactor));
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = Math.max(1, 2 / Math.sqrt(zoomFactor));
    
    // Rectángulo con esquinas redondeadas
    ctx.beginPath();
    ctx.moveTo(rectX + cornerRadius, rectY);
    ctx.lineTo(rectX + rectWidth - cornerRadius, rectY);
    ctx.arcTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius, cornerRadius);
    ctx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
    ctx.arcTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight, cornerRadius);
    ctx.lineTo(rectX + cornerRadius, rectY + rectHeight);
    ctx.arcTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius, cornerRadius);
    ctx.lineTo(rectX, rectY + cornerRadius);
    ctx.arcTo(rectX, rectY, rectX + cornerRadius, rectY, cornerRadius);
    ctx.closePath();
    
    ctx.fillStyle = esPreview ? 'rgba(59, 130, 246, 0.95)' : 'rgba(0, 0, 0, 0.85)';
    ctx.fill();
    
    // Borde de la etiqueta
    ctx.strokeStyle = markerColor;
    ctx.lineWidth = Math.max(1, 1.5 / this.state.scale);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Texto del nombre
    ctx.fillStyle = '#ffffff';
    ctx.fillText(text, x, y - pinHeight - paddingY * 1.5);
    
    // 📊 Badge de cantidad (pequeño círculo con número)
    if (cantidad >= 0 && !esPreview) {
      const badgeRadius = Math.max(10, 14 / this.state.scale);
      const badgeX = x + circleRadius * 0.7;
      const badgeY = y - pinHeight + circleRadius - circleRadius * 0.7;
      
      // Círculo del badge
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
      ctx.fillStyle = cantidad === 0 ? '#dc2626' : (cantidad < minimo ? '#d97706' : '#059669');
      ctx.fill();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = Math.max(1, 2 / this.state.scale);
      ctx.stroke();
      
      // Número de cantidad
      const badgeFontSize = Math.max(9, 12 / this.state.scale);
      ctx.font = `bold ${badgeFontSize}px "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(cantidad.toString(), badgeX, badgeY);
    }
    
    // 🔢 Badge de número correlativo (solo si hay múltiples instancias)
    if (totalInstancias > 1 && numeroCorrelativo && !esPreview) {
      const correlativoBadgeRadius = Math.max(9, 12 / this.state.scale);
      const correlativoBadgeX = x - circleRadius * 0.7;
      const correlativoBadgeY = y - pinHeight + circleRadius - circleRadius * 0.7;
      
      // Círculo del badge negro
      ctx.beginPath();
      ctx.arc(correlativoBadgeX, correlativoBadgeY, correlativoBadgeRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#222222';
      ctx.fill();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = Math.max(1, 1.5 / this.state.scale);
      ctx.stroke();
      
      // Número correlativo
      const correlativoFontSize = Math.max(8, 10 / this.state.scale);
      ctx.font = `bold ${correlativoFontSize}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(`#${numeroCorrelativo}`, correlativoBadgeX, correlativoBadgeY);
    }
    
    // Texto "ARRASTRANDO" si es preview
    if (esPreview) {
      const previewFontSize = Math.max(10, 14 / this.state.scale);
      ctx.font = `bold ${previewFontSize}px "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#3b82f6';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3 / this.state.scale;
      ctx.strokeText('🎯 ARRASTRANDO', x, y + 10 / this.state.scale);
      ctx.fillText('🎯 ARRASTRANDO', x, y + 10 / this.state.scale);
    }
    
  ctx.restore();
},

// 🆕 Continuar con ubicaciones resaltadas (solo si no hay arrastre activo)
dibujarUbicacionesResaltadas(ctx) {
  if (!this.state.ubicacionesResaltadas || this.state.ubicacionesResaltadas.length === 0) return;
  if (this.state.marcadorArrastre && this.state.marcadorArrastre.iniciado) return;
  
  // 🎨 OPTIMIZADO: Animación más sutil y menos costosa
  // Solo animar cada 100ms en lugar de cada frame
  const ahora = Date.now();
  if (!this.state.ultimaAnimacion || ahora - this.state.ultimaAnimacion > 100) {
    this.state.ultimaAnimacion = ahora;
    this.state.pulsoAnimacion = (this.state.pulsoAnimacion || 0) + 0.15;
  }
  
  this.state.ubicacionesResaltadas.forEach(({ x, y, repuesto, descripcion }, index) => {
    // Animación simple: solo un anillo pulsante
    const pulso = Math.sin(this.state.pulsoAnimacion + index * 0.5) * 0.3 + 0.7; // 0.4 a 1.0
    
    // Tamaño base adaptable al zoom
    const baseSize = Math.max(25, 40 / this.state.scale);
    const ringRadius = baseSize * pulso;
    
    // UN SOLO anillo (en lugar de 2)
    ctx.beginPath();
    ctx.arc(x, y, ringRadius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(59, 130, 246, ${0.5 * pulso})`;
    ctx.lineWidth = Math.max(2, 4 / this.state.scale);
    ctx.stroke();
    
    // Punto central SIN sombra (las sombras son costosas)
    const centerRadius = Math.max(10, 15 / this.state.scale);
    
    ctx.beginPath();
    ctx.arc(x, y, centerRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#3b82f6';
    ctx.fill();
    
    // Borde blanco del punto
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = Math.max(2, 3 / this.state.scale);
    ctx.stroke();
    
    // Punto interno
    ctx.beginPath();
    ctx.arc(x, y, centerRadius * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
  });
  
  // 🔄 Continuar animación solo si hay ubicaciones resaltadas
  if (this.state.ubicacionesResaltadas && this.state.ubicacionesResaltadas.length > 0) {
    if (!this.state.animacionResaltadaActiva) {
      this.state.animacionResaltadaActiva = true;
      const animarResaltado = () => {
        if (this.state.ubicacionesResaltadas && this.state.ubicacionesResaltadas.length > 0) {
          this.draw();
          requestAnimationFrame(animarResaltado);
        } else {
          this.state.animacionResaltadaActiva = false;
        }
      };
      requestAnimationFrame(animarResaltado);
    }
  }
},

  // 🆕 NUEVA FUNCIÓN: Guardar nueva posición del marcador después de arrastrar
  async guardarNuevaPosicionMarcador(marcadorInfo, nuevoX, nuevoY) {
    const { repuesto, ubicacionIndex, ubicacion } = marcadorInfo;
    
    console.log(`💾 Guardando nueva posición del marcador:`, {
      repuesto: repuesto.nombre,
      indice: ubicacionIndex,
      antiguaPos: { x: ubicacion.markerX, y: ubicacion.markerY },
      nuevaPos: { x: nuevoX, y: nuevoY }
    });
    
    // Verificar que la nueva posición esté en un área válida
    const areasCercanas = this.buscarAreasCercanas(nuevoX, nuevoY, 300);
    
    if (areasCercanas.length === 0) {
      this.showToast('⚠️ No hay áreas cercanas. Coloca el marcador dentro de un área.', 'warning');
      this.draw(); // Redibujar sin cambios
      return;
    }
    
    // Si hay un área válida, usar la primera (más cercana)
    const areaNueva = areasCercanas[0].area;
    
    // Actualizar ubicación en el repuesto
    if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
      const ub = repuesto.ubicaciones[ubicacionIndex];
      if (ub) {
        ub.markerX = nuevoX;
        ub.markerY = nuevoY;
        ub.areaId = areaNueva.id; // Actualizar área si cambió
      }
    }
    
    // Guardar cambios
    try {
      await app.saveData();
      this.showToast(`✅ Posición actualizada en "${areaNueva.name}"`, 'success');
      this.draw(); // Redibujar con nueva posición
    } catch (error) {
      console.error('Error guardando posición:', error);
      this.showToast('❌ Error al guardar la nueva posición', 'error');
      // Revertir cambio
      if (repuesto.ubicaciones && repuesto.ubicaciones[ubicacionIndex]) {
        repuesto.ubicaciones[ubicacionIndex].markerX = ubicacion.markerX;
        repuesto.ubicaciones[ubicacionIndex].markerY = ubicacion.markerY;
        repuesto.ubicaciones[ubicacionIndex].areaId = ubicacion.areaId;
      }
      this.draw();
    }
  },

  drawTempShape(ctx) {
    if (!this.state.drawing || this.state.tempPoints.length === 0) return;

    ctx.save();
    
    // 🎨 MEJORA: Líneas más gruesas y visibles
    ctx.strokeStyle = 'rgba(59, 130, 246, 1)'; // Opacidad 100%
    ctx.fillStyle = 'rgba(59, 130, 246, 0.25)'; // Más opaco
    ctx.lineWidth = Math.max(3, 3 / this.state.scale); // Mínimo 3px
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // 🎨 SOMBRA para el polígono
    ctx.shadowColor = 'rgba(59, 130, 246, 0.5)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    ctx.beginPath();
    this.state.tempPoints.forEach((point, index) => {
      if (index === 0) ctx.moveTo(point.x, point.y);
      else ctx.lineTo(point.x, point.y);
    });

    if (this.state.previewPoint) {
      ctx.lineTo(this.state.previewPoint.x, this.state.previewPoint.y);
    }

    if (this.state.tempPoints.length >= 2) {
      ctx.fill();
    }
    ctx.stroke();

    // 🎨 PUNTOS más grandes y visibles con borde
    ctx.shadowBlur = 0; // Quitar sombra para puntos
    
    this.state.tempPoints.forEach((point, index) => {
      const radius = Math.max(6, 8 / this.state.scale); // Mínimo 6px
      
      // Borde blanco
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius + 2 / this.state.scale, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      
      // Punto principal azul
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = index === 0 ? '#facc15' : '#3b82f6'; // Primer punto amarillo
      ctx.fill();
      
      // Número del punto
      if (this.state.tempPoints.length > 2) {
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${Math.max(10, 12 / this.state.scale)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((index + 1).toString(), point.x, point.y);
      }
    });
    
    // 🎨 Punto de preview (cursor)
    if (this.state.previewPoint && this.state.tempPoints.length > 0) {
      const radius = Math.max(4, 6 / this.state.scale);
      ctx.beginPath();
      ctx.arc(this.state.previewPoint.x, this.state.previewPoint.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(59, 130, 246, 0.5)';
      ctx.fill();
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2 / this.state.scale;
      ctx.stroke();
    }
    
    ctx.restore();
  },

  drawEditPoints(ctx) {
    if (!this.state.editingAreaId || !this.state.editingPoints.length) return;

    ctx.save();
    
    const lineWidth = Math.max(3, 3 / this.state.scale);
    const pointRadius = Math.max(16, 16 / this.state.scale); // MÁS GRANDE: 16px (era 14px)
    const selectedRadius = Math.max(22, 22 / this.state.scale); // MÁS GRANDE: 22px (era 20px)
    
    // Dibujar las líneas de la forma
    ctx.beginPath();
    this.state.editingPoints.forEach((point, index) => {
      if (index === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    });
    ctx.closePath();
    
    // Línea con estilo destacado
    ctx.strokeStyle = '#f59e0b'; // Amber para indicar modo edición
    ctx.lineWidth = lineWidth;
    ctx.setLineDash([10 / this.state.scale, 5 / this.state.scale]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Dibujar TODOS los puntos editables (todos visibles y arrastrables)
    this.state.editingPoints.forEach((point, index) => {
      const isSelected = index === this.state.selectedPointIndex;
      const isDragging = isSelected && this.state.isDraggingPoint;
      const radius = isSelected ? selectedRadius : pointRadius;
      
      // Sombra más pronunciada para puntos seleccionados
      if (isDragging) {
        ctx.shadowColor = 'rgba(245, 158, 11, 0.6)';
        ctx.shadowBlur = 20 / this.state.scale;
      } else {
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 15 / this.state.scale;
      }
      ctx.shadowOffsetX = 3 / this.state.scale;
      ctx.shadowOffsetY = 3 / this.state.scale;
      
      // Círculo exterior (color principal) - MÁS TRANSPARENTE
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
      
      // Color según estado - con transparencia para ver el fondo
      if (isDragging) {
        ctx.fillStyle = 'rgba(245, 158, 11, 0.7)'; // Amber semi-transparente
      } else if (isSelected) {
        ctx.fillStyle = 'rgba(251, 146, 60, 0.7)'; // Amber claro semi-transparente
      } else {
        ctx.fillStyle = 'rgba(59, 130, 246, 0.6)'; // Azul semi-transparente
      }
      ctx.fill();
      
      // Quitar sombra para el borde
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Borde blanco grueso
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 3 / this.state.scale;
      ctx.stroke();
      
      // Punto interior blanco semi-transparente para ver a través
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius * 0.4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fill();
      
      // Anillo interior para puntos seleccionados
      if (isSelected) {
        ctx.beginPath();
        ctx.arc(point.x, point.y, radius * 0.65, 0, Math.PI * 2);
        ctx.strokeStyle = isDragging ? '#fbbf24' : '#fb923c';
        ctx.lineWidth = 2 / this.state.scale;
        ctx.stroke();
      }
      
      // Número del punto con fondo semi-transparente
      const fontSize = Math.max(16, 16 / this.state.scale);
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const labelY = point.y - radius - 14 / this.state.scale;
      const text = String(index + 1);
      
      // Medir texto para el fondo
      const metrics = ctx.measureText(text);
      const padding = 5 / this.state.scale;
      const bgWidth = metrics.width + padding * 2;
      const bgHeight = fontSize + padding * 2;
      
      // Fondo semi-transparente con bordes redondeados
      ctx.fillStyle = isSelected ? 'rgba(245, 158, 11, 0.85)' : 'rgba(0, 0, 0, 0.75)';
      const bgX = point.x - bgWidth / 2;
      const bgY = labelY - bgHeight / 2;
      const borderRadius = 5 / this.state.scale;
      
      ctx.beginPath();
      ctx.roundRect(bgX, bgY, bgWidth, bgHeight, borderRadius);
      ctx.fill();
      
      // Borde blanco del fondo
      ctx.strokeStyle = isSelected ? '#fbbf24' : 'white';
      ctx.lineWidth = 2 / this.state.scale;
      ctx.stroke();
      
      // Texto blanco
      ctx.fillStyle = 'white';
      ctx.fillText(text, point.x, labelY);
    });
    
    ctx.restore();
  },

  // 🎯 ETAPA 3.2: Dibujar handles de reshape (puntos editables)
  drawReshapeHandles(ctx) {
    if (!this.state.reshapeAreaId || !this.state.reshapePoints.length) return;
    
    ctx.save();
    
    const lineWidth = Math.max(3, 3 / this.state.scale);
    const pointRadius = Math.max(8, 8 / this.state.scale);
    const selectedRadius = Math.max(12, 12 / this.state.scale);
    const hoveredRadius = Math.max(10, 10 / this.state.scale);
    
    // Dibujar el polígono en edición con estilo destacado
    ctx.beginPath();
    this.state.reshapePoints.forEach((point, index) => {
      if (index === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    });
    ctx.closePath();
    
    // Línea punteada azul
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = lineWidth;
    ctx.setLineDash([8 / this.state.scale, 4 / this.state.scale]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Dibujar bordes con indicador de hover (para agregar puntos)
    if (this.state.hoveredEdgeIndex !== null && this.state.hoveredEdgeIndex !== -1) {
      const p1 = this.state.reshapePoints[this.state.hoveredEdgeIndex];
      const p2 = this.state.reshapePoints[(this.state.hoveredEdgeIndex + 1) % this.state.reshapePoints.length];
      
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = '#10b981'; // Verde para indicar que puede agregar
      ctx.lineWidth = lineWidth * 1.5;
      ctx.stroke();
      
      // Dibujar punto fantasma donde se agregaría
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      
      ctx.beginPath();
      ctx.arc(midX, midY, pointRadius * 0.8, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
      ctx.fill();
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 2 / this.state.scale;
      ctx.stroke();
    }
    
    // Dibujar puntos editables
    this.state.reshapePoints.forEach((point, index) => {
      const isSelected = index === this.state.selectedPointIndex;
      const isHovered = index === this.state.hoveredPointIndex;
      const isDragging = isSelected && this.state.isDraggingPoint;
      
      let radius = pointRadius;
      if (isSelected) radius = selectedRadius;
      else if (isHovered) radius = hoveredRadius;
      
      // Sombra
      ctx.shadowColor = isDragging ? 'rgba(59, 130, 246, 0.6)' : 'rgba(0, 0, 0, 0.3)';
      ctx.shadowBlur = isDragging ? 12 / this.state.scale : 6 / this.state.scale;
      ctx.shadowOffsetX = 2 / this.state.scale;
      ctx.shadowOffsetY = 2 / this.state.scale;
      
      // Círculo principal
      ctx.beginPath();
      ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
      
      if (isDragging) {
        ctx.fillStyle = '#3b82f6'; // Azul sólido
      } else if (isSelected) {
        ctx.fillStyle = '#60a5fa'; // Azul claro
      } else if (isHovered) {
        ctx.fillStyle = '#93c5fd'; // Azul muy claro
      } else {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Blanco semi-transparente
      }
      ctx.fill();
      
      // Quitar sombra para el borde
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Borde
      ctx.strokeStyle = isSelected || isDragging ? '#3b82f6' : '#64748b';
      ctx.lineWidth = 2 / this.state.scale;
      ctx.stroke();
      
      // Punto interior
      if (isSelected || isHovered) {
        ctx.beginPath();
        ctx.arc(point.x, point.y, radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = '#3b82f6';
        ctx.fill();
      }
      
      // Número del punto
      const fontSize = Math.max(10, 10 / this.state.scale);
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const labelY = point.y - radius - 10 / this.state.scale;
      const text = String(index + 1);
      
      // Fondo del número
      const metrics = ctx.measureText(text);
      const padding = 3 / this.state.scale;
      const bgWidth = metrics.width + padding * 2;
      const bgHeight = fontSize + padding;
      
      ctx.fillStyle = isSelected ? '#3b82f6' : 'rgba(0, 0, 0, 0.7)';
      const bgX = point.x - bgWidth / 2;
      const bgY = labelY - bgHeight / 2;
      
      ctx.beginPath();
      ctx.roundRect(bgX, bgY, bgWidth, bgHeight, 3 / this.state.scale);
      ctx.fill();
      
      // Texto
      ctx.fillStyle = 'white';
      ctx.fillText(text, point.x, labelY);
    });
    
    // Mostrar controles en pantalla
    if (this.state.reshapeAreaId) {
      ctx.restore(); // Restaurar para dibujar en coordenadas de pantalla
      
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Resetear transformación
      
      // Panel de ayuda
      const canvas = this.elements.canvas;
      const panelX = 10;
      const panelY = canvas.height - 100;
      const panelWidth = 280;
      const panelHeight = 90;
      
      // Fondo del panel
      ctx.fillStyle = 'rgba(15, 23, 42, 0.95)';
      ctx.beginPath();
      ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 8);
      ctx.fill();
      
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Texto de ayuda
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('🎯 Modo Edición de Puntos', panelX + 12, panelY + 20);
      
      ctx.font = '11px sans-serif';
      ctx.fillStyle = '#cbd5e1';
      ctx.fillText('• Arrastra puntos para moverlos', panelX + 12, panelY + 40);
      ctx.fillText('• Click en borde para agregar punto', panelX + 12, panelY + 55);
      ctx.fillText('• Selecciona + Delete para eliminar', panelX + 12, panelY + 70);
      
      // Botones
      const btnY = panelY + panelHeight + 10;
      const btnHeight = 32;
      const btnPadding = 8;
      
      // Botón Guardar
      const saveBtn = { x: panelX, y: btnY, width: 100, height: btnHeight };
      ctx.fillStyle = '#10b981';
      ctx.beginPath();
      ctx.roundRect(saveBtn.x, saveBtn.y, saveBtn.width, saveBtn.height, 6);
      ctx.fill();
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('✓ Guardar (Enter)', saveBtn.x + saveBtn.width / 2, saveBtn.y + saveBtn.height / 2);
      
      // Botón Cancelar
      const cancelBtn = { x: panelX + 110, y: btnY, width: 100, height: btnHeight };
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.roundRect(cancelBtn.x, cancelBtn.y, cancelBtn.width, cancelBtn.height, 6);
      ctx.fill();
      
      ctx.fillStyle = 'white';
      ctx.fillText('✗ Cancelar (Esc)', cancelBtn.x + cancelBtn.width / 2, cancelBtn.y + cancelBtn.height / 2);
      
      ctx.restore();
      return; // Ya hicimos restore
    }
    
    ctx.restore();
  },

  // 🗺️ NUEVO: Renderizar minimap con vista general
  drawMinimap() {
    if (!this.minimapCtx || !this.elements.minimap || !this.state.currentImage) return;

    const minimap = this.elements.minimap;
    const ctx = this.minimapCtx;
    const container = this.elements.minimapContainer;
    
    // Ajustar tamaño del canvas minimap al contenedor
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    
    if (minimap.width !== containerWidth || minimap.height !== containerHeight) {
      minimap.width = containerWidth;
      minimap.height = containerHeight;
    }

    // Limpiar minimap
    ctx.clearRect(0, 0, minimap.width, minimap.height);
    ctx.fillStyle = 'rgba(15, 23, 42, 0.5)';
    ctx.fillRect(0, 0, minimap.width, minimap.height);

    // Calcular escala para que la imagen completa quepa en el minimap
    const imgWidth = this.state.currentImage.width;
    const imgHeight = this.state.currentImage.height;
    const scaleX = minimap.width / imgWidth;
    const scaleY = minimap.height / imgHeight;
    const minimapScale = Math.min(scaleX, scaleY) * 0.95; // 95% para dejar margen

    // Centrar imagen en minimap
    const drawWidth = imgWidth * minimapScale;
    const drawHeight = imgHeight * minimapScale;
    const offsetX = (minimap.width - drawWidth) / 2;
    const offsetY = (minimap.height - drawHeight) / 2;

    // Dibujar imagen en minimap
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(minimapScale, minimapScale);
    ctx.globalAlpha = 0.6;
    ctx.drawImage(this.state.currentImage, 0, 0);
    ctx.globalAlpha = 1;

    // Dibujar áreas en minimap
    this.state.areas.forEach(area => {
      if (!Array.isArray(area.points) || area.points.length < 3) return;

      ctx.beginPath();
      area.points.forEach((point, index) => {
        if (index === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.closePath();

      // Color del área
      ctx.fillStyle = area.color ? `${area.color}40` : 'rgba(59, 130, 246, 0.25)';
      ctx.fill();
      ctx.strokeStyle = area.color || '#3b82f6';
      ctx.lineWidth = 1.5 / minimapScale;
      ctx.stroke();
    });

    ctx.restore();

    // Dibujar rectángulo del viewport actual
    const viewport = this.elements.minimapViewport;
    if (viewport) {
      const mainCanvas = this.elements.canvas;
      
      // Calcular viewport en coordenadas del mundo
      const viewLeft = -this.state.offsetX / this.state.scale;
      const viewTop = -this.state.offsetY / this.state.scale;
      const viewWidth = mainCanvas.width / this.state.scale;
      const viewHeight = mainCanvas.height / this.state.scale;

      // Convertir a coordenadas del minimap
      const vpLeft = offsetX + viewLeft * minimapScale;
      const vpTop = offsetY + viewTop * minimapScale;
      const vpWidth = viewWidth * minimapScale;
      const vpHeight = viewHeight * minimapScale;

      viewport.style.left = `${Math.max(0, Math.min(vpLeft, minimap.width))}px`;
      viewport.style.top = `${Math.max(0, Math.min(vpTop, minimap.height))}px`;
      viewport.style.width = `${Math.max(0, Math.min(vpWidth, minimap.width - vpLeft))}px`;
      viewport.style.height = `${Math.max(0, Math.min(vpHeight, minimap.height - vpTop))}px`;
    }
  },

  registerCanvasEvents() {
    const canvas = this.elements.canvas;
    if (!canvas) return;

    canvas.addEventListener('mousedown', (event) => {
      if (event.button === 0) {
        const rect = canvas.getBoundingClientRect();
        const screenX = event.clientX - rect.left;
        const screenY = event.clientY - rect.top;
        
        // Calcular coordenadas transformadas (coordenadas de la imagen)
        const mapX = (screenX - this.state.offsetX) / this.state.scale;
        const mapY = (screenY - this.state.offsetY) / this.state.scale;
        
        // 🆕 VERIFICAR SI SE HIZO CLICK EN EL NOMBRE DE UN ÁREA (para fijar tooltip)
        if (this.state.mostrarNombresAreas && !this.state.drawing && !this.state.editingAreaId && !this.state.modoAgregarMarcadorActivo) {
          let clickedOnLabel = false;
          let clickedArea = null;
          
          for (const area of this.state.areas) {
            if (!Array.isArray(area.points) || area.points.length < 3) continue;
            
            const centroid = this.calculateCentroid(area.points);
            if (!centroid) continue;
            
            const labelOffsetX = area.labelOffsetX || 0;
            const labelOffsetY = area.labelOffsetY || 0;
            const labelX = centroid.x + labelOffsetX;
            const labelY = centroid.y + labelOffsetY;
            
            // Calcular dimensiones del rectángulo del texto
            const text = area.name || 'Área';
            const maxCharsPerLine = 20;
            const lines = [];
            
            if (text.length <= maxCharsPerLine) {
              lines.push(text);
            } else {
              const words = text.split(' ');
              let currentLine = '';
              words.forEach((word, idx) => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                if (testLine.length <= maxCharsPerLine) {
                  currentLine = testLine;
                } else {
                  if (currentLine) lines.push(currentLine);
                  currentLine = word;
                }
                if (idx === words.length - 1 && currentLine) {
                  lines.push(currentLine);
                }
              });
            }
            
            const baseFontSize = 28;
            const minFontSize = 14;
            const zoomFactor = this.state.zoom || 1.0;
            const fontSize = Math.max(minFontSize, baseFontSize / Math.sqrt(zoomFactor));
            
            const maxLineLength = Math.max(...lines.map(l => l.length));
            const textWidth = maxLineLength * fontSize * 0.6;
            const lineHeight = fontSize * 1.2;
            const textHeight = lineHeight * lines.length;
            
            const paddingX = Math.max(6, 12 / Math.sqrt(zoomFactor));
            const paddingY = Math.max(4, 8 / Math.sqrt(zoomFactor));
            
            const rectWidth = textWidth + paddingX * 2;
            const rectHeight = textHeight + paddingY * 2;
            const rectX = labelX - rectWidth / 2;
            const rectY = labelY - rectHeight / 2;
            
            // Verificar si el click está dentro del rectángulo del nombre
            if (mapX >= rectX && mapX <= rectX + rectWidth &&
                mapY >= rectY && mapY <= rectY + rectHeight) {
              clickedOnLabel = true;
              clickedArea = area;
              break;
            }
          }
          
          if (clickedOnLabel && clickedArea) {
            // Si el tooltip ya está fijado en esta área, desfijarlo
            if (this.state.tooltipPinned && this.state.pinnedAreaId === clickedArea.id) {
              this.state.tooltipPinned = false;
              this.state.pinnedAreaId = null;
              this.state.highlightAreaId = null; // 🔧 Quitar resaltado amarillo
              this.elements.tooltip.classList.add('hidden');
              this.scheduleRender(); // 🔧 Redibujar para quitar el amarillo
              console.log('📌 Tooltip desfijado');
            } else {
              // Fijar el tooltip en esta área
              this.state.tooltipPinned = true;
              this.state.pinnedAreaId = clickedArea.id;
              this.state.highlightAreaId = clickedArea.id; // 🔧 Resaltar área en amarillo
              // Forzar actualización del tooltip
              this.updateTooltip(event);
              this.scheduleRender(); // 🔧 Redibujar con resaltado
              console.log('📌 Tooltip fijado en:', clickedArea.name);
            }
            
            // Prevenir otros comportamientos
            event.preventDefault();
            event.stopPropagation();
            return;
          } else if (!clickedOnLabel && this.state.tooltipPinned) {
            // Si se hace click fuera del label y el tooltip está fijado, desfijarlo
            this.state.tooltipPinned = false;
            this.state.pinnedAreaId = null;
            this.state.highlightAreaId = null; // 🔧 Quitar resaltado amarillo
            this.elements.tooltip.classList.add('hidden');
            this.scheduleRender(); // 🔧 Redibujar para quitar el amarillo
            console.log('📌 Tooltip desfijado por click fuera');
          }
          
          // 🔧 NUEVO: Si se hace click fuera, quitar selección de marcador también
          if (!clickedOnLabel) {
            this.clearMarkerSelection();
          }
        }
        
        // 🆕 MODO AGREGAR MARCADOR: Detectar click en área y abrir modal
        if (this.state.modoAgregarMarcadorActivo) {
          console.log('📍 Click en modo agregar marcador:', { 
            screen: { screenX, screenY },
            map: { mapX, mapY },
            transform: { offsetX: this.state.offsetX, offsetY: this.state.offsetY, scale: this.state.scale }
          });
          
          // Buscar el área donde se hizo click (usando coordenadas de la imagen)
          const areas = this.state.areas || [];
          console.log('📍 Áreas en el mapa:', areas.length);
          
          if (areas.length === 0) {
            console.warn('⚠️ No hay áreas cargadas!');
            this.showToast('⚠️ Este mapa no tiene áreas definidas', 'warning');
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          
          // Probar cada área
          let areaClickeada = null;
          for (const area of areas) {
            console.log(`� Probando área "${area.name}":`, {
              points: area.points.length,
              primer_punto: area.points[0],
              click: { mapX, mapY }
            });
            
            const dentro = this.puntoEnArea(mapX, mapY, area);
            console.log(`  → Resultado: ${dentro ? '✅ DENTRO' : '❌ fuera'}`);
            
            if (dentro) {
              areaClickeada = area;
              break;
            }
          }
          
          if (areaClickeada) {
            console.log('✅✅✅ Click dentro del área:', areaClickeada.name);
            // Usar coordenadas de la imagen para el marcador
            this.abrirModalBusquedaRepuesto(mapX, mapY, areaClickeada);
          } else {
            console.log('❌ No se encontró área en las coordenadas:', { mapX, mapY });
            this.showToast('⚠️ Debes hacer click dentro de un área', 'warning');
          }
          
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        
        // 🆕 MODO MOVER PIN: Si estamos en modo edición de pin
        if (this.state.pinAMover && this.state.pinAMover.editando) {
          console.log('🖱️ Click en modo edición de pin');
          
          const marcadorClickeado = this.detectarClickEnMarcador(mapX, mapY);
          
          if (marcadorClickeado && 
              String(marcadorClickeado.repuesto.id) === String(this.state.pinAMover.repuestoId) &&
              marcadorClickeado.ubicacionIndex === this.state.pinAMover.ubicacionIndex) {
            
            console.log('✅ Click en el pin correcto! Activando arrastre...');
            
            // Activar arrastre del pin
            this.state.marcadorArrastre = {
              info: marcadorClickeado,
              iniciado: true,
              inicioX: screenX,
              inicioY: screenY,
              tiempoInicio: Date.now(),
              mapX: mapX,
              mapY: mapY,
              esEdicionPin: true  // Bandera especial para saber que es edición de pin
            };
            
            canvas.style.cursor = 'grabbing';
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
        
        // 🆕 CLICK EN MARCADORES FUERA DE MODO EDICIÓN: Fijar tarjeta hover
        if (!this.state.isReshapeMode && !this.state.pinAMover) {
          const marcadorClickeado = this.detectarClickEnMarcador(mapX, mapY);
          if (marcadorClickeado) {
            console.log('📍 Click en marcador → Fijar tarjeta hover');
            
            // 🔧 SOLUCIÓN: Delay para evitar que se cierre inmediatamente
            // Primero cerrar tarjeta anterior
            const tarjetaAnterior = document.getElementById('tarjetaHoverRepuesto');
            if (tarjetaAnterior) {
              tarjetaAnterior.remove();
            }
            
            // Marcar que estamos abriendo una nueva tarjeta
            this.state.abriendo_tarjeta_fija = true;
            
            // Abrir nueva tarjeta con delay
            setTimeout(() => {
              this.fijarTarjetaHoverRepuesto(marcadorClickeado, screenX, screenY);
              // Resetear bandera después de que se haya montado
              setTimeout(() => {
                this.state.abriendo_tarjeta_fija = false;
              }, 150);
            }, 10);
            
            event.preventDefault();
            event.stopPropagation();
            return;
          } else {
            // Click fuera de marcadores → Cerrar tarjeta fija si existe
            // Solo cerrar si NO estamos abriendo una nueva
            if (!this.state.abriendo_tarjeta_fija) {
              this.cerrarTarjetaFija();
            }
          }
        }
        
        // 🎯 PRIORIDAD MÁXIMA: Modo marcador de repuesto
        if (this.state.modoMarcador && this.state.marcadorPendiente) {
          console.log('🎯 Click detectado en modo marcador:', { mapX, mapY });
          this.colocarMarcador(mapX, mapY);
          return;
        }
        
        // 🎯 ETAPA 3.2: Detectar click en botones del panel de reshape
        if (this.state.isReshapeMode && this.state.reshapeAreaId) {
          const rect = canvas.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const clickY = event.clientY - rect.top;
          
          const panelY = canvas.height - 100;
          const btnY = panelY + 90 + 10;
          const btnHeight = 32;
          
          // Botón Guardar
          if (clickX >= 10 && clickX <= 110 && clickY >= btnY && clickY <= btnY + btnHeight) {
            this.saveReshapeChanges();
            return;
          }
          
          // Botón Cancelar
          if (clickX >= 120 && clickX <= 220 && clickY >= btnY && clickY <= btnY + btnHeight) {
            this.cancelReshape();
            return;
          }
        }
        
        // 🎯 ETAPA 3.2: Modo reshape (edición de puntos Y repuestos)
        if (this.state.isReshapeMode) {
          // 🆕 PRIORIDAD 1: Verificar si se clickeó un marcador de repuesto
          const marcadorClickeado = this.detectarClickEnMarcador(mapX, mapY);
          if (marcadorClickeado) {
            console.log('📍 Modo edición: Click en marcador de repuesto - PERMITIR ARRASTRE');
            // ✅ Activar arrastre del marcador (SOLO en modo edición)
            this.state.marcadorArrastre = {
              info: marcadorClickeado,
              iniciado: false, // Se activará al mover el mouse
              inicioX: screenX,
              inicioY: screenY,
              tiempoInicio: Date.now(),
              modoEdicion: true // Bandera para saber que está en modo edición
            };
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          
          // 🆕 PRIORIDAD 2: Si no hay marcador, verificar puntos de área
          const pointIndex = this.state.reshapeAreaId ? this.findPointAtCursor(
            (event.clientX - this.elements.canvas.getBoundingClientRect().left - this.state.offsetX) / this.state.scale,
            (event.clientY - this.elements.canvas.getBoundingClientRect().top - this.state.offsetY) / this.state.scale
          ) : -1;
          
          if (pointIndex !== -1) {
            // Iniciar arrastre de punto de área
            this.state.selectedPointIndex = pointIndex;
            this.state.isDraggingPoint = true;
          } else {
            // Click normal en reshape (seleccionar área)
            this.handleReshapeClick(event);
          }
        }
        // 🎯 ETAPA 3.1: Modo selección múltiple
        else if (this.state.isMultiSelectMode && !this.state.drawing && !this.state.editingAreaId) {
          this.handleMultiSelectClick(event);
        } else if (this.state.editingAreaId) {
          // Modo edición de puntos
          this.handleEditPointMouseDown(event);
        } else if (this.state.drawing) {
          this.addPoint(event);
        } else {
          this.beginPan(event);
        }
      }
    });

    canvas.addEventListener('mousemove', (event) => {
      // 🆕 ARRASTRE DE MARCADOR: Detectar movimiento para activar arrastre
      if (this.state.marcadorArrastre && !this.state.marcadorArrastre.iniciado) {
        const rect = canvas.getBoundingClientRect();
        const screenX = event.clientX - rect.left;
        const screenY = event.clientY - rect.top;
        
        const distancia = Math.sqrt(
          Math.pow(screenX - this.state.marcadorArrastre.inicioX, 2) +
          Math.pow(screenY - this.state.marcadorArrastre.inicioY, 2)
        );
        
        // Si se movió más de 5px, activar modo arrastre
        if (distancia > 5) {
          this.state.marcadorArrastre.iniciado = true;
          canvas.style.cursor = 'grabbing';
        }
      }
      
      // 🆕 ARRASTRE DE MARCADOR: Mover marcador
      if (this.state.marcadorArrastre && this.state.marcadorArrastre.iniciado) {
        const rect = canvas.getBoundingClientRect();
        const screenX = event.clientX - rect.left;
        const screenY = event.clientY - rect.top;
        const mapX = (screenX - this.state.offsetX) / this.state.scale;
        const mapY = (screenY - this.state.offsetY) / this.state.scale;
        
        // Actualizar posición temporal para dibujo
        this.state.marcadorArrastre.mapX = mapX;
        this.state.marcadorArrastre.mapY = mapY;
        
        // Si es edición de pin, actualizar también ubicacionesResaltadas
        if (this.state.marcadorArrastre.esEdicionPin) {
          this.state.ubicacionesResaltadas = [{
            x: mapX,
            y: mapY,
            repuesto: 'Nueva posición',
            descripcion: 'Suelta aquí para guardar'
          }];
        }
        
        requestAnimationFrame(() => this.draw());
        return;
      }
      
      //  ETAPA 3.2: Modo reshape
      if (this.state.isReshapeMode && this.state.reshapeAreaId) {
        this.handleReshapeMouseMove(event);
      }
      else if (this.state.isDraggingPoint) {
        // Arrastrando un punto en modo edición
        this.handleEditPointDrag(event);
      } else if (this.state.editingAreaId) {
        // Hover sobre puntos en modo edición
        this.updateEditPointHover(event);
      } else if (this.state.drawing) {
        this.updatePreviewPoint(event);
      } else if (this.state.isPanning) {
        this.pan(event);
      } else {
        // 🎯 Cambiar cursor y mostrar tarjeta hover si está sobre un marcador
        const rect = canvas.getBoundingClientRect();
        const screenX = event.clientX - rect.left;
        const screenY = event.clientY - rect.top;
        const mapX = (screenX - this.state.offsetX) / this.state.scale;
        const mapY = (screenY - this.state.offsetY) / this.state.scale;
        
        const marcadorHover = this.detectarClickEnMarcador(mapX, mapY);
        if (marcadorHover) {
          canvas.style.cursor = this.state.isReshapeMode ? 'grab' : 'pointer';
          
          // 🆕 Mostrar tarjeta hover simplificada
          this.mostrarTarjetaHoverRepuesto(marcadorHover, screenX, screenY);
        } else {
          canvas.style.cursor = 'default';
          
          // Ocultar tarjeta hover
          this.ocultarTarjetaHoverRepuesto();
        }
        
        // 🎨 NUEVO: Mostrar tooltip al pasar sobre áreas
        this.updateTooltip(event);
      }
    });

    ['mouseup', 'mouseleave'].forEach(type => {
      canvas.addEventListener(type, (event) => {
        // 🆕 ARRASTRE DE MARCADOR: Finalizar arrastre o mostrar menú
        if (this.state.marcadorArrastre) {
          if (this.state.marcadorArrastre.iniciado) {
            // Se arrastró el marcador
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            const mapX = (screenX - this.state.offsetX) / this.state.scale;
            const mapY = (screenY - this.state.offsetY) / this.state.scale;
            
            // Si es edición de pin, NO guardar automáticamente
            if (this.state.marcadorArrastre.esEdicionPin) {
              console.log('📍 Pin soltado en modo edición');
              // Solo actualizar la posición visual, el usuario debe hacer click en "Guardar"
              canvas.style.cursor = 'grab';
            } else {
              // Arrastre normal, guardar automáticamente
              this.guardarNuevaPosicionMarcador(
                this.state.marcadorArrastre.info,
                mapX,
                mapY
              );
              canvas.style.cursor = 'default';
            }
          } else {
            // Click corto - distinguir entre modo edición y modo normal
            if (this.state.marcadorArrastre.modoEdicion) {
              // En modo edición, NO mostrar menú (solo arrastre o nada)
              console.log('📍 Click corto en modo edición - no hacer nada');
            } else if (!this.state.marcadorArrastre.esEdicionPin) {
              // Modo normal: mostrar menú contextual
              const tiempoClick = Date.now() - this.state.marcadorArrastre.tiempoInicio;
              
              if (tiempoClick < 300) {
                // Click rápido = menú contextual
                this.mostrarMenuMarcador(
                  this.state.marcadorArrastre.info,
                  this.state.marcadorArrastre.inicioX,
                  this.state.marcadorArrastre.inicioY
                );
              }
            }
          }
          
          this.state.marcadorArrastre = null;
          return;
        }
        
        // 🎯 ETAPA 3.2: Soltar punto en reshape
        if (this.state.isReshapeMode && this.state.isDraggingPoint) {
          this.state.isDraggingPoint = false;
          this.draw();
        }
        else if (this.state.isDraggingPoint) {
          this.handleEditPointMouseUp();
        }
        this.endPan();
      });
    });

    // Event listener pasivo para wheel - mejora rendimiento
    canvas.addEventListener('wheel', (event) => this.handleWheel(event), { passive: false });

    canvas.addEventListener('dblclick', (event) => {
      if (this.state.editingAreaId) {
        event.preventDefault();
        // No hacer nada, los botones de guardar/cancelar están en pantalla
        return;
      } else if (this.state.drawing) {
        event.preventDefault();
        this.finishDrawing();
      } else {
        // 🆕 Doble click afuera: Limpiar filtro de repuesto
        if (this.state.repuestoFiltrado || this.state.ubicacionesResaltadas.length > 0) {
          this.state.repuestoFiltrado = null;
          this.state.ubicacionesResaltadas = [];
          this.showToast('✅ Filtro limpiado - Mostrando todos los repuestos', 'success', 2000);
          this.draw();
        }
      }
    });

    canvas.addEventListener('contextmenu', (event) => {
      if (this.state.editingAreaId) {
        event.preventDefault();
        // No cancelar con click derecho, solo los botones en pantalla
        return;
      } else if (this.state.drawing) {
        event.preventDefault();
        this.finishDrawing();
      }
    });

    // 🎯 ETAPA 3.1: Atajos de teclado para selección múltiple
    document.addEventListener('keydown', (event) => {
      // Solo si el mapa está visible y activo
      if (!this.state.currentMap) return;
      
      // 🎯 ETAPA 3.2: Atajos de reshape
      if (this.state.isReshapeMode && this.state.reshapeAreaId) {
        // Delete: Eliminar punto seleccionado
        if (event.key === 'Delete' && this.state.selectedPointIndex !== null) {
          event.preventDefault();
          this.deleteSelectedPoint();
          return;
        }
        
        // Enter: Guardar cambios
        if (event.key === 'Enter') {
          event.preventDefault();
          this.saveReshapeChanges();
          return;
        }
        
        // Escape: Cancelar edición
        if (event.key === 'Escape') {
          event.preventDefault();
          this.cancelReshape();
          return;
        }
      }
      
      // Ctrl+A: Seleccionar todas las áreas
      if (event.ctrlKey && event.key === 'a' && this.state.isMultiSelectMode) {
        event.preventDefault();
        this.selectAllAreas();
      }
      
      // Escape: Deseleccionar todas
      if (event.key === 'Escape' && this.state.selectedAreaIds.length > 0) {
        event.preventDefault();
        this.deselectAllAreas();
      }
      
      // Delete: Eliminar áreas seleccionadas
      if (event.key === 'Delete' && this.state.selectedAreaIds.length > 0 && this.state.isMultiSelectMode) {
        event.preventDefault();
        this.batchDeleteAreas();
      }
      
      // Ctrl+B: Abrir operaciones en lote
      if (event.ctrlKey && event.key === 'b' && this.state.selectedAreaIds.length > 0) {
        event.preventDefault();
        this.openBatchOperationsModal();
      }
    });
  },

  beginPan(event) {
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    this.state.isPanning = true;
    this.state.panStartX = canvasX - this.state.offsetX;
    this.state.panStartY = canvasY - this.state.offsetY;
    this.elements.canvas.style.cursor = 'grabbing';
  },

  pan(event) {
    if (!this.state.isPanning) return;
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    this.state.offsetX = canvasX - this.state.panStartX;
    this.state.offsetY = canvasY - this.state.panStartY;
    this.scheduleRender();
  },

  endPan() {
    if (this.state.isPanning) {
      this.state.isPanning = false;
      this.elements.canvas.style.cursor = this.state.drawing ? 'crosshair' : 'grab';
    }
  },

  handleWheel(event) {
    if (!this.state.currentImage) return;
    event.preventDefault();
    const delta = event.deltaY > 0 ? 0.85 : 1.15;
    const coords = this.getCanvasCoordinates(event);
    this.zoomAt(coords.canvasX, coords.canvasY, delta);
  },

  handleEditPointMouseDown(event) {
    if (!this.state.editingAreaId || !this.state.editingPoints.length) return;
    
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const threshold = 50; // Threshold ENORME: 50px (era 35px)
    
    // Buscar el punto más cercano
    let closestIndex = -1;
    let closestDist = Infinity;
    
    this.state.editingPoints.forEach((point, index) => {
      // Convertir punto de imagen a pantalla
      const screenX = point.x * this.state.scale + this.state.offsetX;
      const screenY = point.y * this.state.scale + this.state.offsetY;
      
      const dx = screenX - canvasX;
      const dy = screenY - canvasY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < threshold && dist < closestDist) {
        closestDist = dist;
        closestIndex = index;
      }
    });
    
    if (closestIndex !== -1) {
      this.state.selectedPointIndex = closestIndex;
      this.state.isDraggingPoint = true;
      this.elements.canvas.style.cursor = 'grabbing';
      this.draw(); // Redibujar para mostrar punto seleccionado
      console.log('🎯 Punto', closestIndex + 1, 'seleccionado, distancia:', closestDist.toFixed(1), 'px');
    }
  },

  handleEditPointDrag(event) {
    if (!this.state.isDraggingPoint || this.state.selectedPointIndex === null) return;
    
    const { mapX, mapY } = this.getMapPoint(event);
    if (!Number.isFinite(mapX) || !Number.isFinite(mapY)) return;
    
    // Actualizar posición del punto seleccionado
    this.state.editingPoints[this.state.selectedPointIndex] = { x: mapX, y: mapY };
    this.scheduleRender();
  },

  handleEditPointMouseUp() {
    if (this.state.isDraggingPoint) {
      this.state.isDraggingPoint = false;
      // NO limpiar selectedPointIndex para mantener el punto resaltado
      console.log('✋ Punto', (this.state.selectedPointIndex + 1), 'soltado, listo para mover otro');
      this.elements.canvas.style.cursor = 'grab';
      this.scheduleRender(); // Redibujar
    }
  },

  updateEditPointHover(event) {
    if (!this.state.editingAreaId || !this.state.editingPoints.length || this.state.isDraggingPoint) return;
    
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const threshold = 50; // 50px en pantalla
    
    // Ver si el cursor está cerca de algún punto (en coordenadas de pantalla)
    let nearPoint = false;
    for (const point of this.state.editingPoints) {
      const screenX = point.x * this.state.scale + this.state.offsetX;
      const screenY = point.y * this.state.scale + this.state.offsetY;
      
      const dx = screenX - canvasX;
      const dy = screenY - canvasY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < threshold) {
        nearPoint = true;
        break;
      }
    }
    
    this.elements.canvas.style.cursor = nearPoint ? 'grab' : 'default';
  },

  // 🎨 NUEVO: Mostrar tooltip al pasar sobre el NOMBRE del área (no el área completa)
  updateTooltip(event) {
    const tooltip = this.elements.tooltip;
    if (!tooltip || !this.state.currentImage || this.state.drawing || this.state.editingAreaId) {
      if (tooltip && !this.state.tooltipPinned) {
        tooltip.classList.add('hidden');
      }
      return;
    }

    // Si el tooltip está "fijado" (pinned), mantenerlo con el área fijada
    if (this.state.tooltipPinned && this.state.pinnedAreaId) {
      const pinnedArea = this.state.areas.find(a => a.id === this.state.pinnedAreaId);
      if (pinnedArea) {
        this.renderTooltipContent(pinnedArea, event);
        return;
      } else {
        // Si el área ya no existe, desfijar
        this.state.tooltipPinned = false;
        this.state.pinnedAreaId = null;
        this.state.highlightAreaId = null; // 🔧 Quitar resaltado
        this.scheduleRender(); // 🔧 Redibujar
      }
    }

    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    
    // Convertir coordenadas de canvas a coordenadas del mundo (imagen)
    const worldX = (canvasX - this.state.offsetX) / this.state.scale;
    const worldY = (canvasY - this.state.offsetY) / this.state.scale;

    // Buscar área cuyo NOMBRE esté bajo el cursor
    let hoveredArea = null;
    
    if (this.state.mostrarNombresAreas) {
      for (const area of this.state.areas) {
        if (!Array.isArray(area.points) || area.points.length < 3) continue;
        
        // Calcular centroide y posición del label
        const centroid = this.calculateCentroid(area.points);
        if (!centroid) continue;
        
        const labelOffsetX = area.labelOffsetX || 0;
        const labelOffsetY = area.labelOffsetY || 0;
        const labelX = centroid.x + labelOffsetX;
        const labelY = centroid.y + labelOffsetY;
        
        // Calcular dimensiones del rectángulo del texto
        const text = area.name || 'Área';
        const maxCharsPerLine = 20;
        const lines = [];
        
        if (text.length <= maxCharsPerLine) {
          lines.push(text);
        } else {
          const words = text.split(' ');
          let currentLine = '';
          words.forEach((word, idx) => {
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            if (testLine.length <= maxCharsPerLine) {
              currentLine = testLine;
            } else {
              if (currentLine) lines.push(currentLine);
              currentLine = word;
            }
            if (idx === words.length - 1 && currentLine) {
              lines.push(currentLine);
            }
          });
        }
        
        // Estimar dimensiones (aproximado, sin usar ctx.measureText)
        const baseFontSize = 28;
        const minFontSize = 14;
        const zoomFactor = this.state.zoom || 1.0;
        const fontSize = Math.max(minFontSize, baseFontSize / Math.sqrt(zoomFactor));
        
        // Aproximar ancho: cada carácter ~0.6 del fontSize
        const maxLineLength = Math.max(...lines.map(l => l.length));
        const textWidth = maxLineLength * fontSize * 0.6;
        const lineHeight = fontSize * 1.2;
        const textHeight = lineHeight * lines.length;
        
        const paddingX = Math.max(6, 12 / Math.sqrt(zoomFactor));
        const paddingY = Math.max(4, 8 / Math.sqrt(zoomFactor));
        
        const rectWidth = textWidth + paddingX * 2;
        const rectHeight = textHeight + paddingY * 2;
        const rectX = labelX - rectWidth / 2;
        const rectY = labelY - rectHeight / 2;
        
        // Verificar si el cursor está dentro del rectángulo del nombre
        if (worldX >= rectX && worldX <= rectX + rectWidth &&
            worldY >= rectY && worldY <= rectY + rectHeight) {
          hoveredArea = area;
          break;
        }
      }
    }

    if (hoveredArea) {
      this.renderTooltipContent(hoveredArea, event);
    } else {
      tooltip.classList.add('hidden');
    }
  },

  // 🆕 Renderizar contenido del tooltip para un área
  renderTooltipContent(area, event) {
    const tooltip = this.elements.tooltip;
    if (!tooltip) return;
    
    // Obtener categoría
    const category = this.categories[area.category] || this.categories.area;
    
    // Construir contenido del tooltip
    let tooltipHTML = `
      <div class="map-tooltip-title">
        <span>${category.icon}</span>
        <span>${area.name || 'Sin nombre'}</span>
      </div>
      <div class="map-tooltip-category">${category.name}</div>
    `;
    
    // Agregar equipos si existen
    if (Array.isArray(area.equipos) && area.equipos.length > 0) {
      const equiposPreview = area.equipos.slice(0, 3).join(', ');
      const moreText = area.equipos.length > 3 ? ` (+${area.equipos.length - 3} mas)` : '';
      tooltipHTML += `
        <div class="map-tooltip-equipos">
          <strong>Equipos:</strong>
          ${equiposPreview}${moreText}
        </div>
      `;
    }
    
    // Indicar si está fijado
    const pinnedIndicator = this.state.tooltipPinned && this.state.pinnedAreaId === area.id
      ? '<div style="font-size: 0.7rem; color: #fbbf24; margin-top: 4px;">📌 Fijado (click para desfijar)</div>'
      : '<div style="font-size: 0.7rem; color: #888; margin-top: 4px;">Click en el nombre para fijar</div>';
    
    // Agregar botones de accion
    tooltipHTML += `
      ${pinnedIndicator}
      <div style="display: flex; gap: 6px; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
        <button onclick="mapController.startEditAreaPoints('${area.id}');" style="flex: 1; padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 3px; color: var(--text-primary); cursor: pointer; font-size: 0.75rem;">
          E Forma
        </button>
        <button onclick="mapController.openEditAreaMetadataModal('${area.id}');" style="flex: 1; padding: 4px 8px; background: var(--primary); border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 500;">
          C Datos
        </button>
        <button onclick="mapController.deleteArea('${area.id}');" style="padding: 4px 8px; background: #dc2626; border: none; border-radius: 3px; color: white; cursor: pointer; font-size: 0.75rem;">
          X
        </button>
      </div>
    `;
    
    tooltip.innerHTML = tooltipHTML;
    
    // 🔧 Agregar/quitar clase 'pinned' según estado
    if (this.state.tooltipPinned && this.state.pinnedAreaId === area.id) {
      tooltip.classList.add('pinned');
    } else {
      tooltip.classList.remove('pinned');
    }
    
    // Posicionar tooltip cerca del cursor (solo si no está fijado)
    if (!this.state.tooltipPinned) {
      const rect = this.elements.canvasStage.getBoundingClientRect();
      let tooltipX = event.clientX - rect.left + 15;
      let tooltipY = event.clientY - rect.top + 15;
      
      // Ajustar si se sale del canvas
      const tooltipRect = tooltip.getBoundingClientRect();
      if (tooltipX + tooltipRect.width > rect.width) {
        tooltipX = event.clientX - rect.left - tooltipRect.width - 15;
      }
      if (tooltipY + tooltipRect.height > rect.height) {
        tooltipY = event.clientY - rect.top - tooltipRect.height - 15;
      }
      
      tooltip.style.left = `${tooltipX}px`;
      tooltip.style.top = `${tooltipY}px`;
    }
    
    tooltip.classList.remove('hidden');
  },

  // Función helper para detectar si un punto está dentro de un polígono
  isPointInPolygon(point, polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x, yi = polygon[i].y;
      const xj = polygon[j].x, yj = polygon[j].y;
      
      const intersect = ((yi > point.y) !== (yj > point.y))
        && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  },

  zoomAt(canvasX, canvasY, factor) {
    const newScale = Math.max(this.state.minScale, Math.min(this.state.maxScale, this.state.scale * factor));
    if (newScale === this.state.scale) return;

    const worldX = (canvasX - this.state.offsetX) / this.state.scale;
    const worldY = (canvasY - this.state.offsetY) / this.state.scale;

    this.state.scale = newScale;
    this.state.offsetX = canvasX - worldX * newScale;
    this.state.offsetY = canvasY - worldY * newScale;
    this.updateZoomBadge(); // 🔍 Actualizar badge de zoom
    this.draw();
  },

  handleToolbarAction(action) {
    switch (action) {
      case 'zoom-in':
        this.zoomCentered(1.2);
        break;
      case 'zoom-out':
        this.zoomCentered(1 / 1.2);
        break;
      case 'reset-view':
        this.resetView();
        break;
      case 'toggle-nombres-areas':
        this.toggleNombresAreas();
        break;
      case 'toggle-puntos-repuestos':
        this.togglePuntosRepuestos();
        break;
      case 'toggle-grid':
        this.toggleGrid();
        break;
      case 'toggle-minimap':
        this.toggleMinimap();
        break;
      case 'toggle-rulers':
        this.toggleRulers();
        break;
      case 'toggle-multiselect':
        this.toggleMultiSelect();
        break;
      case 'toggle-reshape':
        this.toggleReshape();
        break;
      case 'recenter':
        this.recenter();
        break;
      default:
        console.debug('Acción de toolbar no implementada:', action);
    }
  },

  zoomCentered(factor) {
    if (!this.state.currentImage) return;
    const canvas = this.elements.canvas;
    const canvasX = canvas.width / 2;
    const canvasY = canvas.height / 2;
    this.zoomAt(canvasX, canvasY, factor);
  },

  resetView() {
    this.state.scale = 1;
    this.state.offsetX = 0;
    this.state.offsetY = 0;
    this.updateZoomBadge(); // 🔍 Actualizar badge de zoom
    this.draw();
  },

  recenter() {
    if (!this.state.currentImage) return;
    const canvas = this.elements.canvas;
    const centerX = (this.state.currentImage.width / 2) * this.state.scale;
    const centerY = (this.state.currentImage.height / 2) * this.state.scale;
    this.state.offsetX = canvas.width / 2 - centerX;
    this.state.offsetY = canvas.height / 2 - centerY;
    this.draw();
  },

  toggleGrid() {
    this.state.showGrid = !this.state.showGrid;
    this.draw();
    this.showToast(this.state.showGrid ? 'Rejilla activada.' : 'Rejilla desactivada.', 'info');
  },

  toggleNombresAreas() {
    this.state.mostrarNombresAreas = !this.state.mostrarNombresAreas;
    this.draw();
    const btn = document.querySelector('[data-action="toggle-nombres-areas"]');
    if (btn) {
      btn.style.background = this.state.mostrarNombresAreas ? '#3b82f6' : '';
      btn.style.color = this.state.mostrarNombresAreas ? 'white' : '';
    }
    this.showToast(this.state.mostrarNombresAreas ? '👁️ Nombres de áreas visibles' : '👁️ Nombres de áreas ocultos', 'info');
  },

  togglePuntosRepuestos() {
    this.state.mostrarPuntosRepuestos = !this.state.mostrarPuntosRepuestos;
    this.draw();
    const btn = document.querySelector('[data-action="toggle-puntos-repuestos"]');
    if (btn) {
      // 🆕 MEJORA VISUAL: Estilos más claros para ON/OFF
      if (this.state.mostrarPuntosRepuestos) {
        // Estado ON: Fondo azul brillante
        btn.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
        btn.style.color = 'white';
        btn.style.fontWeight = 'bold';
        btn.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.4)';
        btn.style.transform = 'scale(1.0)';
      } else {
        // Estado OFF: Gris oscuro con borde
        btn.style.background = 'linear-gradient(135deg, #4b5563 0%, #374151 100%)';
        btn.style.color = '#d1d5db';
        btn.style.fontWeight = 'normal';
        btn.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3), inset 0 0 0 2px rgba(239, 68, 68, 0.5)';
        btn.style.transform = 'scale(0.95)';
      }
      btn.style.transition = 'all 0.3s ease';
    }
    this.showToast(
      this.state.mostrarPuntosRepuestos 
        ? '📍 Todos los puntos visibles' 
        : '👁️ Solo marcador seleccionado', 
      'info'
    );
  },

  // 🆕 NUEVA FUNCIÓN: Sincronizar estado visual de botones con el estado interno
  syncButtonStates() {
    // Botón de puntos
    const btnPuntos = document.querySelector('[data-action="toggle-puntos-repuestos"]');
    if (btnPuntos) {
      if (this.state.mostrarPuntosRepuestos) {
        // Estado ON: Fondo azul brillante
        btnPuntos.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
        btnPuntos.style.color = 'white';
        btnPuntos.style.fontWeight = 'bold';
        btnPuntos.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.4)';
        btnPuntos.style.transform = 'scale(1.0)';
      } else {
        // Estado OFF: Gris oscuro con borde rojo
        btnPuntos.style.background = 'linear-gradient(135deg, #4b5563 0%, #374151 100%)';
        btnPuntos.style.color = '#d1d5db';
        btnPuntos.style.fontWeight = 'normal';
        btnPuntos.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3), inset 0 0 0 2px rgba(239, 68, 68, 0.5)';
        btnPuntos.style.transform = 'scale(0.95)';
      }
      btnPuntos.style.transition = 'all 0.3s ease';
    }
    
    // Botón de nombres de áreas
    const btnNombres = document.querySelector('[data-action="toggle-nombres-areas"]');
    if (btnNombres) {
      btnNombres.style.background = this.state.mostrarNombresAreas ? '#3b82f6' : '';
      btnNombres.style.color = this.state.mostrarNombresAreas ? 'white' : '';
    }
  },

  toggleMinimap() {
    this.state.showMinimap = !this.state.showMinimap;
    if (this.elements.minimapContainer) {
      if (this.state.showMinimap) {
        this.elements.minimapContainer.classList.remove('hidden');
        this.drawMinimap();
      } else {
        this.elements.minimapContainer.classList.add('hidden');
      }
    }
    this.showToast(this.state.showMinimap ? 'Minimap activado.' : 'Minimap desactivado.', 'info');
  },

  handleMinimapClick(event) {
    if (!this.state.currentImage || !this.elements.minimap) return;

    const minimap = this.elements.minimap;
    const rect = minimap.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;

    // Calcular escala del minimap (igual que en drawMinimap)
    const imgWidth = this.state.currentImage.width;
    const imgHeight = this.state.currentImage.height;
    const scaleX = minimap.width / imgWidth;
    const scaleY = minimap.height / imgHeight;
    const minimapScale = Math.min(scaleX, scaleY) * 0.95;

    const drawWidth = imgWidth * minimapScale;
    const drawHeight = imgHeight * minimapScale;
    const offsetX = (minimap.width - drawWidth) / 2;
    const offsetY = (minimap.height - drawHeight) / 2;

    // Convertir coordenadas de clic a coordenadas del mundo
    const worldX = (clickX - offsetX) / minimapScale;
    const worldY = (clickY - offsetY) / minimapScale;

    // Centrar el viewport en el punto clicado
    const mainCanvas = this.elements.canvas;
    this.state.offsetX = -worldX * this.state.scale + mainCanvas.width / 2;
    this.state.offsetY = -worldY * this.state.scale + mainCanvas.height / 2;

    this.draw();
  },

  toggleRulers() {
    this.state.showRulers = !this.state.showRulers;
    this.draw();
    this.showToast(this.state.showRulers ? 'Reglas activadas.' : 'Reglas desactivadas.', 'info');
  },

  // 🎯 ETAPA 3.1: Toggle modo selección múltiple
  toggleMultiSelect() {
    this.state.isMultiSelectMode = !this.state.isMultiSelectMode;
    
    const btn = document.getElementById('mapMultiSelectBtn');
    if (this.state.isMultiSelectMode) {
      btn.classList.add('map-btn--primary');
      btn.textContent = '🎯 Modo Activo';
      this.showHint('Modo selección múltiple: Click en áreas para seleccionar/deseleccionar. Ctrl+A para seleccionar todas.');
    } else {
      btn.classList.remove('map-btn--primary');
      btn.textContent = '🎯 Selección Múltiple';
      this.state.selectedAreaIds = []; // Limpiar selección
      this.updateSelectionBadge();
      this.hideHint();
    }
    
    this.draw();
    this.showToast(this.state.isMultiSelectMode ? '✅ Modo selección múltiple activado' : '❌ Modo selección múltiple desactivado', 'info');
  },

  // 🎯 ETAPA 3.1: Actualizar badge de selección
  updateSelectionBadge() {
    const badge = document.getElementById('mapSelectionBadge');
    if (!badge) return;
    
    if (this.state.selectedAreaIds.length > 0) {
      badge.textContent = `${this.state.selectedAreaIds.length} seleccionada${this.state.selectedAreaIds.length !== 1 ? 's' : ''}`;
      badge.style.display = 'block';
    } else {
      badge.style.display = 'none';
    }
  },

  // 🎯 ETAPA 3.1: Seleccionar/deseleccionar área
  toggleAreaSelection(areaId) {
    const index = this.state.selectedAreaIds.indexOf(areaId);
    if (index > -1) {
      this.state.selectedAreaIds.splice(index, 1); // Deseleccionar
    } else {
      this.state.selectedAreaIds.push(areaId); // Seleccionar
    }
    this.updateSelectionBadge();
    this.draw();
    console.log(`🎯 Áreas seleccionadas: ${this.state.selectedAreaIds.length}`);
  },

  // 🎯 ETAPA 3.1: Seleccionar todas las áreas
  selectAllAreas() {
    this.state.selectedAreaIds = this.state.areas.map(area => area.id);
    this.updateSelectionBadge();
    this.draw();
    this.showToast(`✅ ${this.state.selectedAreaIds.length} áreas seleccionadas`, 'success');
  },

  // 🎯 ETAPA 3.1: Deseleccionar todas las áreas
  deselectAllAreas() {
    this.state.selectedAreaIds = [];
    this.updateSelectionBadge();
    this.draw();
    this.showToast('❌ Selección limpiada', 'info');
  },

  // 🎯 ETAPA 3.1: Abrir modal de operaciones en lote
  openBatchOperationsModal() {
    if (this.state.selectedAreaIds.length === 0) {
      this.showToast('⚠️ No hay áreas seleccionadas', 'warning');
      return;
    }

    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) return;

    this.elements.modalTitle.textContent = `Operaciones en lote (${this.state.selectedAreaIds.length} áreas)`;

    // Generar opciones de categorías
    const categoryOptions = Object.entries(this.categories).map(([key, cat]) => 
      `<option value="${key}">${cat.icon} ${cat.name}</option>`
    ).join('');

    body.innerHTML = `
      <form id="batchOperationsForm" class="map-area-form">
        <p style="color: var(--text-secondary); margin-bottom: 16px;">
          Aplicar cambios a <strong>${this.state.selectedAreaIds.length}</strong> área(s) seleccionada(s):
        </p>

        <div class="form-group">
          <label>Cambiar categoría</label>
          <select name="batchCategory" id="batchCategory">
            <option value="">No cambiar</option>
            ${categoryOptions}
          </select>
        </div>

        <div class="form-group">
          <label>Cambiar color</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="checkbox" id="batchColorEnable" style="width: auto;">
            <input type="color" name="batchColor" id="batchColor" value="#3b82f6" disabled />
            <span id="batchColorHex" style="font-family: monospace; color: var(--text-secondary);">#3b82f6</span>
          </div>
        </div>

        <div class="form-group">
          <label>Cambiar opacidad</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="checkbox" id="batchOpacityEnable" style="width: auto;">
            <input type="range" name="batchOpacity" id="batchOpacity" min="10" max="90" value="35" disabled />
            <span id="batchOpacityValue" style="min-width: 40px; color: var(--text-secondary);">35%</span>
          </div>
        </div>

        <hr style="border: none; border-top: 1px solid var(--border-color); margin: 16px 0;">

        <div class="form-actions">
          <button type="button" class="map-btn map-btn--danger" onclick="mapController.batchDeleteAreas()">
            🗑️ Eliminar todas
          </button>
          <button type="button" class="map-btn map-btn--ghost" data-action="cancel">Cancelar</button>
          <button type="submit" class="map-btn map-btn--primary">Aplicar cambios</button>
        </div>
      </form>
    `;

    modal.classList.remove('hidden');

    // Event listeners para habilitar/deshabilitar inputs
    const colorCheckbox = document.getElementById('batchColorEnable');
    const colorInput = document.getElementById('batchColor');
    const colorHex = document.getElementById('batchColorHex');
    
    colorCheckbox.addEventListener('change', () => {
      colorInput.disabled = !colorCheckbox.checked;
    });
    
    colorInput.addEventListener('input', () => {
      colorHex.textContent = colorInput.value;
    });

    const opacityCheckbox = document.getElementById('batchOpacityEnable');
    const opacityInput = document.getElementById('batchOpacity');
    const opacityValue = document.getElementById('batchOpacityValue');
    
    opacityCheckbox.addEventListener('change', () => {
      opacityInput.disabled = !opacityCheckbox.checked;
    });
    
    opacityInput.addEventListener('input', () => {
      opacityValue.textContent = `${opacityInput.value}%`;
    });

    const cancelBtn = body.querySelector('[data-action="cancel"]');
    if (cancelBtn) cancelBtn.addEventListener('click', () => this.closeModal());

    const form = body.querySelector('#batchOperationsForm');
    if (form) {
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.applyBatchOperations(new FormData(form));
      });
    }
  },

  // 🎯 ETAPA 3.1: Aplicar operaciones en lote
  applyBatchOperations(formData) {
    const category = formData.get('batchCategory');
    const colorEnable = document.getElementById('batchColorEnable').checked;
    const color = formData.get('batchColor');
    const opacityEnable = document.getElementById('batchOpacityEnable').checked;
    const opacity = parseInt(formData.get('batchOpacity')) / 100;

    let changesCount = 0;

    this.state.areas.forEach(area => {
      if (this.state.selectedAreaIds.includes(area.id)) {
        if (category) {
          area.category = category;
          changesCount++;
        }
        if (colorEnable) {
          area.color = color;
          changesCount++;
        }
        if (opacityEnable) {
          area.opacity = opacity;
          changesCount++;
        }
      }
    });

    this.saveAreas();
    this.draw();
    this.renderAreasList();
    this.closeModal();
    this.showToast(`✅ Cambios aplicados a ${this.state.selectedAreaIds.length} área(s)`, 'success');
  },

  // 🎯 ETAPA 3.1: Eliminar áreas seleccionadas en lote
  batchDeleteAreas() {
    if (!confirm(`¿Eliminar ${this.state.selectedAreaIds.length} área(s) seleccionada(s)?\n\nEsta acción no se puede deshacer.`)) {
      return;
    }

    this.state.areas = this.state.areas.filter(area => !this.state.selectedAreaIds.includes(area.id));
    this.state.selectedAreaIds = [];
    
    this.updateSelectionBadge();
    this.saveAreas();
    this.draw();
    this.renderAreasList();
    this.closeModal();
    this.showToast('✅ Áreas eliminadas correctamente', 'success');
  },

  // 🎯 ETAPA 3.1: Manejar click en modo selección múltiple
  handleMultiSelectClick(event) {
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const worldX = (canvasX - this.state.offsetX) / this.state.scale;
    const worldY = (canvasY - this.state.offsetY) / this.state.scale;

    // Buscar área en el punto clicado
    const clickedArea = this.findAreaAtPoint(worldX, worldY);
    
    if (clickedArea) {
      this.toggleAreaSelection(clickedArea.id);
    }
    
    // Prevenir panning
    event.stopPropagation();
  },

  // 🎯 ETAPA 3.1: Encontrar área en un punto
  findAreaAtPoint(worldX, worldY) {
    // Buscar en orden inverso (las más recientes primero)
    for (let i = this.state.areas.length - 1; i >= 0; i--) {
      const area = this.state.areas[i];
      if (this.isPointInPolygon({ x: worldX, y: worldY }, area.points)) {
        return area;
      }
    }
    return null;
  },

  // 🎯 ETAPA 3.2: Toggle modo reshape (edición de puntos)
  toggleReshape() {
    this.state.isReshapeMode = !this.state.isReshapeMode;
    
    const btn = document.getElementById('mapReshapeBtn');
    if (this.state.isReshapeMode) {
      // Desactivar otros modos
      if (this.state.isMultiSelectMode) {
        this.toggleMultiSelect();
      }
      if (this.state.drawing) {
        this.cancelDrawing();
      }
      
      btn.classList.add('map-btn--primary');
      btn.innerHTML = '✏️ Modo Activo <span class="info-icon">ℹ️</span>';
      this.showHint('Modo Edición: Click en un área para editar puntos. Arrastra repuestos para reubicarlos. Click en bordes para agregar puntos, selecciona punto + Delete para eliminar.');
    } else {
      btn.classList.remove('map-btn--primary');
      btn.innerHTML = '✏️ Editar Ubicaciones <span class="info-icon">ℹ️</span>';
      this.exitReshapeMode();
      this.hideHint();
    }
    
    this.draw();
    this.showToast(this.state.isReshapeMode ? '✅ Modo edición activado - Puedes mover áreas y repuestos' : '❌ Modo edición desactivado', 'info');
  },

  // 🎯 ETAPA 3.2: Salir del modo reshape
  exitReshapeMode() {
    this.state.reshapeAreaId = null;
    this.state.reshapePoints = [];
    this.state.selectedPointIndex = null;
    this.state.isDraggingPoint = false;
    this.state.hoveredPointIndex = null;
    this.state.hoveredEdgeIndex = null;
  },

  // 🎯 ETAPA 3.2: Iniciar edición de un área
  startReshapingArea(areaId) {
    const area = this.state.areas.find(a => a.id === areaId);
    if (!area) return;
    
    this.state.reshapeAreaId = areaId;
    this.state.reshapePoints = JSON.parse(JSON.stringify(area.points)); // Copia profunda
    this.draw();
    this.showToast(`📝 Editando área: ${area.name}`, 'info');
  },

  // 🎯 ETAPA 3.2: Guardar cambios del reshape
  saveReshapeChanges() {
    if (!this.state.reshapeAreaId || this.state.reshapePoints.length < 3) {
      this.showToast('⚠️ El área debe tener mínimo 3 puntos', 'warning');
      return;
    }
    
    const area = this.state.areas.find(a => a.id === this.state.reshapeAreaId);
    if (area) {
      area.points = JSON.parse(JSON.stringify(this.state.reshapePoints));
      this.saveAreas();
      this.showToast('✅ Cambios guardados correctamente', 'success');
    }
    
    this.exitReshapeMode();
    this.draw();
  },

  // 🎯 ETAPA 3.2: Cancelar edición reshape
  cancelReshape() {
    this.exitReshapeMode();
    this.draw();
    this.showToast('❌ Edición cancelada', 'info');
  },

  // 🎯 ETAPA 3.2: Encontrar punto bajo el cursor
  findPointAtCursor(worldX, worldY, threshold = 10) {
    if (!this.state.reshapeAreaId) return -1;
    
    const screenThreshold = threshold / this.state.scale;
    
    for (let i = 0; i < this.state.reshapePoints.length; i++) {
      const point = this.state.reshapePoints[i];
      const dx = point.x - worldX;
      const dy = point.y - worldY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < screenThreshold) {
        return i;
      }
    }
    
    return -1;
  },

  // 🎯 ETAPA 3.2: Encontrar borde bajo el cursor (para agregar punto)
  findEdgeAtCursor(worldX, worldY, threshold = 15) {
    if (!this.state.reshapeAreaId) return -1;
    
    const screenThreshold = threshold / this.state.scale;
    const points = this.state.reshapePoints;
    
    for (let i = 0; i < points.length; i++) {
      const p1 = points[i];
      const p2 = points[(i + 1) % points.length];
      
      const distance = this.pointToLineDistance(worldX, worldY, p1.x, p1.y, p2.x, p2.y);
      
      if (distance < screenThreshold) {
        return i; // Retorna el índice del primer punto del borde
      }
    }
    
    return -1;
  },

  // 🎯 ETAPA 3.2: Calcular distancia de punto a línea
  pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    
    let xx, yy;
    
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  },

  // 🎯 ETAPA 3.2: Agregar punto en borde
  addPointToEdge(edgeIndex, worldX, worldY) {
    // Insertar el nuevo punto después del punto en edgeIndex
    this.state.reshapePoints.splice(edgeIndex + 1, 0, { x: worldX, y: worldY });
    this.draw();
    this.showToast('✅ Punto agregado', 'success');
  },

  // 🎯 ETAPA 3.2: Eliminar punto seleccionado
  deleteSelectedPoint() {
    if (this.state.selectedPointIndex === null) return;
    
    if (this.state.reshapePoints.length <= 3) {
      this.showToast('⚠️ El área debe tener mínimo 3 puntos', 'warning');
      return;
    }
    
    this.state.reshapePoints.splice(this.state.selectedPointIndex, 1);
    this.state.selectedPointIndex = null;
    this.draw();
    this.showToast('✅ Punto eliminado', 'success');
  },

  // 🎯 ETAPA 3.2: Manejar click en modo reshape
  handleReshapeClick(event) {
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const worldX = (canvasX - this.state.offsetX) / this.state.scale;
    const worldY = (canvasY - this.state.offsetY) / this.state.scale;
    
    // Si no hay área seleccionada, seleccionar una
    if (!this.state.reshapeAreaId) {
      const clickedArea = this.findAreaAtPoint(worldX, worldY);
      if (clickedArea) {
        this.startReshapingArea(clickedArea.id);
      }
      return;
    }
    
    // Verificar si se hizo click en un punto
    const pointIndex = this.findPointAtCursor(worldX, worldY);
    if (pointIndex !== -1) {
      this.state.selectedPointIndex = pointIndex;
      this.draw();
      return;
    }
    
    // Verificar si se hizo click en un borde (para agregar punto)
    const edgeIndex = this.findEdgeAtCursor(worldX, worldY);
    if (edgeIndex !== -1) {
      this.addPointToEdge(edgeIndex, worldX, worldY);
      return;
    }
    
    // Click fuera: deseleccionar punto
    this.state.selectedPointIndex = null;
    this.draw();
  },

  // 🎯 ETAPA 3.2: Manejar movimiento del mouse en reshape
  handleReshapeMouseMove(event) {
    if (!this.state.reshapeAreaId) return;
    
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const worldX = (canvasX - this.state.offsetX) / this.state.scale;
    const worldY = (canvasY - this.state.offsetY) / this.state.scale;
    
    // Si está arrastrando un punto
    if (this.state.isDraggingPoint && this.state.selectedPointIndex !== null) {
      this.state.reshapePoints[this.state.selectedPointIndex] = { x: worldX, y: worldY };
      this.draw();
      return;
    }
    
    // Actualizar punto/borde bajo el cursor
    const pointIndex = this.findPointAtCursor(worldX, worldY);
    const edgeIndex = pointIndex === -1 ? this.findEdgeAtCursor(worldX, worldY) : -1;
    
    if (this.state.hoveredPointIndex !== pointIndex || this.state.hoveredEdgeIndex !== edgeIndex) {
      this.state.hoveredPointIndex = pointIndex;
      this.state.hoveredEdgeIndex = edgeIndex;
      
      // Cambiar cursor
      const canvas = this.elements.canvas;
      if (pointIndex !== -1) {
        canvas.style.cursor = 'move';
      } else if (edgeIndex !== -1) {
        canvas.style.cursor = 'copy';
      } else {
        canvas.style.cursor = 'default';
      }
      
      this.draw();
    }
  },

  getCanvasCoordinates(event) {
    const canvas = this.elements.canvas;
    const rect = canvas.getBoundingClientRect();
    const cssScaleX = canvas.width / rect.width;
    const cssScaleY = canvas.height / rect.height;
    const canvasX = (event.clientX - rect.left) * cssScaleX;
    const canvasY = (event.clientY - rect.top) * cssScaleY;
    return { canvasX, canvasY };
  },

  getMapPoint(event) {
    const { canvasX, canvasY } = this.getCanvasCoordinates(event);
    const mapX = (canvasX - this.state.offsetX) / this.state.scale;
    const mapY = (canvasY - this.state.offsetY) / this.state.scale;
    return { mapX, mapY, canvasX, canvasY };
  },

  addPoint(event) {
    const { mapX, mapY } = this.getMapPoint(event);
    if (!Number.isFinite(mapX) || !Number.isFinite(mapY)) return;

    if (this.state.tempPoints.length >= 3) {
      const firstPoint = this.state.tempPoints[0];
      const distance = Math.hypot(firstPoint.x - mapX, firstPoint.y - mapY);
      if (distance <= 15) {
        this.finishDrawing();
        return;
      }
    }

    this.state.tempPoints.push({ x: mapX, y: mapY });
    this.draw();
  },

  updatePreviewPoint(event) {
    const { mapX, mapY } = this.getMapPoint(event);
    this.state.previewPoint = { x: mapX, y: mapY };
    this.scheduleRender();
  },

  finishDrawing() {
    if (this.state.tempPoints.length < 3) {
      this.showToast('Necesitas al menos 3 puntos para crear un Ã¡rea.', 'warning');
      return;
    }

    this.openAreaModal();
  },

  toggleDrawingMode() {
    if (!mapStorage.initialized || !this.state.currentMapId) {
      this.showToast('Selecciona un mapa antes de dibujar una zona.', 'info');
      return;
    }

    if (this.state.drawing) {
      this.cancelDrawing();
    } else {
      this.state.drawing = true;
      this.state.tempPoints = [];
      this.state.previewPoint = null;
      this.state.highlightAreaId = null;
      if (this.elements.drawBtn) {
        this.elements.drawBtn.textContent = 'Finalizar Ã¡rea';
        this.elements.drawBtn.classList.add('map-btn--primary');
      }
      this.showHint('Modo dibujo activo: haz clic para agregar puntos. Doble clic o clic derecho para cerrar.');
      this.elements.canvas.style.cursor = 'crosshair';
    }
  },

  cancelDrawing() {
    this.state.drawing = false;
    this.state.tempPoints = [];
    this.state.previewPoint = null;
    if (this.elements.drawBtn) {
      this.elements.drawBtn.textContent = 'Dibujar zona';
      this.elements.drawBtn.classList.remove('map-btn--primary');
    }
    this.hideHint();
    this.elements.canvas.style.cursor = 'grab';
    this.draw();
  },

  // 🆕 MODO AGREGAR MARCADOR CON BÚSQUEDA
  toggleModoAgregarMarcador() {
    if (!mapStorage.initialized || !this.state.currentMapId) {
      this.showToast('Selecciona un mapa primero', 'info');
      return;
    }

    const btn = document.getElementById('mapAddMarkerBtn');
    
    if (this.state.modoAgregarMarcadorActivo) {
      // Desactivar modo
      this.state.modoAgregarMarcadorActivo = false;
      if (btn) {
        btn.textContent = '📍 Agregar Marcador';
        btn.classList.remove('map-btn--danger');
        btn.classList.add('map-btn--success');
      }
      if (this.elements.canvas) {
        this.elements.canvas.style.cursor = 'grab';
      }
      this.hideHint();
      this.showToast('Modo agregar marcador desactivado', 'info');
    } else {
      // Activar modo
      this.state.modoAgregarMarcadorActivo = true;
      if (btn) {
        btn.textContent = '❌ Cancelar';
        btn.classList.remove('map-btn--success');
        btn.classList.add('map-btn--danger');
      }
      if (this.elements.canvas) {
        this.elements.canvas.style.cursor = 'crosshair';
      }
      this.showHint('Modo Agregar Marcador: Haz clic dentro de un área para colocar un marcador');
      this.showToast('✅ Haz clic en un área para agregar marcador', 'success');
    }
  },

  // 🆕 MODAL DE BÚSQUEDA DE REPUESTOS
  abrirModalBusquedaRepuesto(x, y, area) {
    const modalHTML = `
      <div id="modalBusquedaRepuesto" style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 10000;
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      ">
        <!-- Header -->
        <div style="
          padding: 16px 20px;
          border-bottom: 1px solid var(--border-color);
          display: flex;
          justify-content: space-between;
          align-items: center;
          background: var(--bg-secondary);
        ">
          <div>
            <h3 style="margin: 0; color: var(--text-primary); font-size: 1.1rem;">
              📍 Seleccionar Repuesto
            </h3>
            <p style="margin: 4px 0 0 0; font-size: 0.85rem; color: var(--text-muted);">
              Área: <strong>${area.name}</strong>
            </p>
          </div>
          <button onclick="mapController.cerrarModalBusquedaRepuesto()" style="
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 4px 8px;
            line-height: 1;
          ">×</button>
        </div>

        <!-- Buscador -->
        <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-color);">
          <input 
            type="text" 
            id="inputBusquedaRepuesto" 
            placeholder="🔍 Escribe para buscar repuesto..."
            style="
              width: 100%;
              padding: 12px 16px;
              border: 2px solid var(--border-color);
              border-radius: 8px;
              font-size: 1rem;
              background: var(--bg-tertiary);
              color: var(--text-primary);
              transition: border-color 0.2s;
            "
            autocomplete="off"
          />
          
          <!-- 🆕 Selector de Categoría -->
          <div style="margin-top: 12px;">
            <label style="display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 6px;">
              🏷️ Categoría (opcional):
            </label>
            <select 
              id="selectCategoriaMarker" 
              style="
                width: 100%;
                padding: 10px 14px;
                border: 2px solid var(--border-color);
                border-radius: 6px;
                font-size: 0.95rem;
                background: var(--bg-tertiary);
                color: var(--text-primary);
                cursor: pointer;
              "
            >
              <option value="Sin categoría">Sin categoría</option>
              <option value="Componentes">🔧 Componentes</option>
              <option value="Eléctrico">⚡ Eléctrico</option>
              <option value="Mecánico">⚙️ Mecánico</option>
              <option value="Hidráulico">💧 Hidráulico</option>
              <option value="Neumático">💨 Neumático</option>
              <option value="Estructura">🏗️ Estructura</option>
              <option value="Seguridad">🛡️ Seguridad</option>
              <option value="Instrumentación">📊 Instrumentación</option>
              <option value="Otro">📦 Otro</option>
            </select>
          </div>
          
          <div id="contadorResultados" style="
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--text-muted);
          "></div>
        </div>

        <!-- Lista de resultados -->
        <div id="listaResultadosRepuestos" style="
          flex: 1;
          overflow-y: auto;
          padding: 8px;
        "></div>

        <!-- Footer -->
        <div style="
          padding: 12px 20px;
          border-top: 1px solid var(--border-color);
          background: var(--bg-secondary);
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        ">
          <button onclick="mapController.cerrarModalBusquedaRepuesto()" style="
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.95rem;
          ">
            Cancelar
          </button>
        </div>
      </div>

      <!-- Overlay -->
      <div id="overlayBusquedaRepuesto" onclick="mapController.cerrarModalBusquedaRepuesto()" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
      "></div>
    `;

    // Eliminar modal previo si existe
    this.cerrarModalBusquedaRepuesto();

    // Agregar al DOM
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    // Guardar contexto
    this.state.modalBusqueda = { x, y, area };

    // Focus en el input y configurar búsqueda
    const input = document.getElementById('inputBusquedaRepuesto');
    if (input) {
      input.focus();
      input.addEventListener('input', (e) => {
        this.filtrarRepuestos(e.target.value);
      });
    }

    // Mostrar todos los repuestos inicialmente
    this.filtrarRepuestos('');
  },

  filtrarRepuestos(termino) {
    const lista = document.getElementById('listaResultadosRepuestos');
    const contador = document.getElementById('contadorResultados');
    if (!lista || !app || !app.repuestos) return;

    const terminoNorm = termino.toLowerCase().trim();
    
    let repuestosFiltrados = app.repuestos;
    if (terminoNorm) {
      repuestosFiltrados = app.repuestos.filter(r => {
        const nombre = (r.nombre || '').toLowerCase();
        const codigo = (r.codigo || '').toLowerCase();
        const area = (r.areaGeneral || r.area || '').toLowerCase();
        const sistema = (r.sistemaEquipo || r.equipo || '').toLowerCase();
        
        return nombre.includes(terminoNorm) || 
               codigo.includes(terminoNorm) ||
               area.includes(terminoNorm) ||
               sistema.includes(terminoNorm);
      });
    }

    // Actualizar contador
    if (contador) {
      contador.textContent = `${repuestosFiltrados.length} repuesto(s) encontrado(s)`;
    }

    // Renderizar lista
    if (repuestosFiltrados.length === 0) {
      lista.innerHTML = `
        <div style="
          padding: 40px 20px;
          text-align: center;
          color: var(--text-muted);
        ">
          <div style="font-size: 3rem; margin-bottom: 12px;">🔍</div>
          <p>No se encontraron repuestos</p>
        </div>
      `;
      return;
    }

    lista.innerHTML = repuestosFiltrados.map(r => `
      <div 
        onclick="mapController.seleccionarRepuestoParaMarcador('${r.id}')"
        style="
          padding: 12px 16px;
          margin-bottom: 8px;
          border: 1px solid var(--border-color);
          border-radius: 8px;
          background: var(--bg-tertiary);
          cursor: pointer;
          transition: all 0.2s;
        "
        onmouseover="this.style.background='var(--bg-hover)'; this.style.borderColor='var(--primary)';"
        onmouseout="this.style.background='var(--bg-tertiary)'; this.style.borderColor='var(--border-color)';"
      >
        <div style="display: flex; justify-content: space-between; align-items: start;">
          <div style="flex: 1;">
            <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">
              ${r.nombre || 'Sin nombre'}
            </div>
            <div style="font-size: 0.85rem; color: var(--text-muted);">
              ${r.codigo ? `Código: ${r.codigo}` : ''}
              ${r.areaGeneral ? ` • ${r.areaGeneral}` : ''}
              ${r.sistemaEquipo ? ` • ${r.sistemaEquipo}` : ''}
            </div>
          </div>
          <div style="
            padding: 4px 8px;
            background: var(--primary);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
          ">
            Seleccionar
          </div>
        </div>
      </div>
    `).join('');
  },

  async seleccionarRepuestoParaMarcador(repuestoId) {
    const repuesto = app.repuestos.find(r => r.id === repuestoId);
    if (!repuesto || !this.state.modalBusqueda) return;

    const { x, y, area } = this.state.modalBusqueda;
    const mapId = this.state.currentMapId;
    
    // 🆕 Obtener categoría seleccionada
    const selectCategoria = document.getElementById('selectCategoriaMarker');
    const categoria = selectCategoria ? selectCategoria.value : 'Sin categoría';

    console.log('🎯 Agregando marcador:', {
      repuesto: repuesto.nombre,
      repuestoId: repuesto.id,
      coordenadas: { x, y },
      area: area.name,
      areaId: area.id,
      mapId: mapId,
      categoria: categoria // 🆕 Log de categoría
    });

    try {
      // Inicializar array de ubicaciones si no existe
      if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) {
        repuesto.ubicaciones = [];
        console.log('  → Inicializando array de ubicaciones');
      }

      console.log(`  → Ubicaciones actuales: ${repuesto.ubicaciones.length}`);
      repuesto.ubicaciones.forEach((ub, idx) => {
        console.log(`    [${idx}] mapId: ${ub.mapId}, areaId: ${ub.areaId}, pos: (${ub.markerX}, ${ub.markerY})`);
      });

      // 🆕 MEJORADO: Solo verificar duplicados si es en la MISMA POSICIÓN (no solo misma área)
      // Permitir múltiples marcadores del mismo repuesto en la misma área pero en posiciones diferentes
      const TOLERANCE = 5; // Tolerancia de 5 píxeles para considerar "misma posición"
      const yaExisteEnMismaPosicion = repuesto.ubicaciones.some(ub => {
        const mismoMapa = String(ub.mapId) === String(mapId);
        const mismaArea = String(ub.areaId) === String(area.id);
        const mismaPosicion = Math.abs(ub.markerX - x) < TOLERANCE && Math.abs(ub.markerY - y) < TOLERANCE;
        return mismoMapa && mismaArea && mismaPosicion;
      });

      if (yaExisteEnMismaPosicion) {
        console.log('  ⚠️ Ya existe un marcador en esta posición exacta');
        this.showToast('⚠️ Ya hay un marcador en esta posición', 'warning');
        this.cerrarModalBusquedaRepuesto();
        return;
      }

      // Agregar nueva ubicación (ahora permite múltiples marcadores del mismo repuesto en la misma área)
      console.log('  → Agregando nueva ubicación');
      repuesto.ubicaciones.push({
        mapId: mapId,
        areaId: area.id,
        areaName: area.name, // 🆕 Guardar nombre del área padre
        markerX: x,
        markerY: y,
        categoria: categoria // 🆕 Categoría jerárquica
      });
      console.log(`  → Total ubicaciones ahora: ${repuesto.ubicaciones.length}`);
      
      // Contar cuántos marcadores de este repuesto hay en esta área
      const marcadoresEnArea = repuesto.ubicaciones.filter(ub => 
        String(ub.mapId) === String(mapId) && String(ub.areaId) === String(area.id)
      ).length;
      
      if (marcadoresEnArea > 1) {
        this.showToast(`✅ "${repuesto.nombre}" agregado (${marcadoresEnArea} en "${area.name}")`, 'success');
      } else {
        this.showToast(`✅ "${repuesto.nombre}" agregado a "${area.name}"`, 'success');
      }

      // Guardar cambios
      console.log('  → Guardando cambios...');
      await app.saveData();
      console.log('  → ✅ Guardado completado');

      // Cerrar modal y redibujar
      this.cerrarModalBusquedaRepuesto();
      this.draw();

      console.log(`✅ Marcador agregado: ${repuesto.nombre} en (${x}, ${y})`);

    } catch (error) {
      console.error('❌ Error agregando marcador:', error);
      this.showToast('❌ Error al agregar marcador', 'error');
    }
  },

  cerrarModalBusquedaRepuesto() {
    const modal = document.getElementById('modalBusquedaRepuesto');
    const overlay = document.getElementById('overlayBusquedaRepuesto');
    
    if (modal) modal.remove();
    if (overlay) overlay.remove();
    
    this.state.modalBusqueda = null;
  },

  openAreaModal() {
    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) return;

    this.elements.modalTitle.textContent = 'Definir nueva Ã¡rea';

    const jerarquia = app?.opcionesJerarquia || {};
    const buildDatalist = (id, values) => {
      if (!Array.isArray(values) || !values.length) return '';
      return `<datalist id="${id}">${values.map(v => `<option value="${this.escapeHtml(v)}"></option>`).join('')}</datalist>`;
    };

    // Construir opciones de categorías con iconos
    const categoryOptions = Object.entries(this.categories).map(([key, cat]) => 
      `<option value="${key}">${cat.icon} ${cat.name}</option>`
    ).join('');

    body.innerHTML = `
      <form id="mapAreaForm" class="map-area-form">
        <div class="form-group">
          <label>📂 Categoría</label>
          <select name="category" id="areaCategorySelect" style="font-size: 1rem; padding: 8px;">
            ${categoryOptions}
          </select>
        </div>
        <div class="form-group">
          <label>Nombre del Ã¡rea</label>
          <input type="text" name="areaName" required placeholder="Ej: Planta Principal" />
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Color</label>
            <input type="color" name="areaColor" id="areaColorInput" value="#3b82f6" />
          </div>
          <div class="form-group">
            <label>Opacidad</label>
            <input type="range" name="areaOpacity" min="10" max="90" value="35" />
          </div>
        </div>
        
        <!-- 🎨 NUEVO: Controles para posicionar el nombre en el canvas -->
        <div class="form-group" style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <span style="font-size: 1.1rem;">📍</span>
            <span>Posición del nombre en el mapa</span>
          </label>
          <div class="form-row" style="gap: 12px;">
            <div class="form-group" style="flex: 1;">
              <label style="font-size: 0.85rem; color: var(--text-secondary);">Desplazar horizontalmente (X)</label>
              <input type="number" name="labelOffsetX" value="0" step="10" placeholder="0" 
                     style="text-align: center;" title="Valores positivos mueven a la derecha, negativos a la izquierda" />
              <small style="color: var(--text-muted); font-size: 0.75rem;">← Izq (-)  |  Der (+) →</small>
            </div>
            <div class="form-group" style="flex: 1;">
              <label style="font-size: 0.85rem; color: var(--text-secondary);">Desplazar verticalmente (Y)</label>
              <input type="number" name="labelOffsetY" value="0" step="10" placeholder="0" 
                     style="text-align: center;" title="Valores positivos mueven hacia abajo, negativos hacia arriba" />
              <small style="color: var(--text-muted); font-size: 0.75rem;">↑ Arriba (-)  |  Abajo (+) ↓</small>
            </div>
          </div>
          <small style="display: block; margin-top: 8px; color: var(--text-muted); font-size: 0.8rem;">
            💡 Ajusta estos valores si el nombre se monta sobre otra área (puedes editarlo después)
          </small>
        </div>
        
        <div class="form-group">
          <label>Nivel 1 – Área general</label>
          <input type="text" name="nivel1" list="nivel1List" placeholder="Ej: Planta Principal" />
          ${buildDatalist('nivel1List', jerarquia.areaGeneral)}
        </div>
        <div class="form-group">
          <label>Nivel 2 – Sub-área</label>
          <input type="text" name="nivel2" list="nivel2List" placeholder="Ej: Línea de Eviscerado" />
          ${buildDatalist('nivel2List', jerarquia.subArea)}
        </div>
        <div class="form-group">
          <label>Nivel 3 – Sistema / Equipo</label>
          <input type="text" name="nivel3" list="nivel3List" placeholder="Ej: Grader Baader" />
          ${buildDatalist('nivel3List', jerarquia.sistemaEquipo)}
        </div>
        <div class="form-group">
          <label>Nivel 4 – Sub-sistema</label>
          <input type="text" name="nivel4" list="nivel4List" placeholder="Ej: Cinta Zeta" />
          ${buildDatalist('nivel4List', jerarquia.subSistema)}
        </div>
        <div class="form-group">
          <label>Nivel 5 – Sección</label>
          <input type="text" name="nivel5" list="nivel5List" placeholder="Ej: Módulo 1" />
          ${buildDatalist('nivel5List', jerarquia.seccion)}
        </div>
        <div class="form-group">
          <label>Equipos / máquinas (uno por línea)</label>
          <textarea name="equipos" rows="4" placeholder="Ej:\nMotor principal\nBanda transportadora"></textarea>
        </div>
        <div class="form-actions">
          <button type="button" class="map-btn map-btn--ghost" data-action="cancel">Cancelar</button>
          <button type="submit" class="map-btn map-btn--primary">Guardar Ã¡rea</button>
        </div>
      </form>
    `;

    modal.classList.remove('hidden');

    const form = body.querySelector('#mapAreaForm');
    const cancelBtn = body.querySelector('[data-action="cancel"]');
    if (cancelBtn) cancelBtn.addEventListener('click', () => {
      this.closeModal();
      this.cancelDrawing();
    });

    // Event listener para cambiar color sugerido al seleccionar categoría
    const categorySelect = body.querySelector('#areaCategorySelect');
    const colorInput = body.querySelector('#areaColorInput');
    if (categorySelect && colorInput) {
      categorySelect.addEventListener('change', (e) => {
        const selectedCategory = e.target.value;
        if (this.categories[selectedCategory]) {
          colorInput.value = this.categories[selectedCategory].color;
          console.log(`🎨 Color sugerido para categoría "${selectedCategory}": ${this.categories[selectedCategory].color}`);
        }
      });
    }

    if (form) {
      form.addEventListener('submit', (event) => {
        event.preventDefault();
        this.saveAreaFromModal(new FormData(form));
      });
    }
  },

  closeModal() {
    const modal = this.elements.modal;
    if (modal) {
      modal.classList.add('hidden');
    }
    this.elements.modalBody.innerHTML = '';
    this.elements.modalTitle.textContent = '';
  },

  async saveAreaFromModal(formData) {
    const name = (formData.get('areaName') || '').toString().trim();
    if (!name) {
      this.showToast('Asigna un nombre a el Ã¡rea.', 'warning');
      return;
    }

    const color = (formData.get('areaColor') || '#3b82f6').toString();
    const opacityValue = parseInt(formData.get('areaOpacity'), 10);
    const opacity = Number.isFinite(opacityValue) ? opacityValue / 100 : 0.35;
    
    // 📂 NUEVO: Obtener categoría seleccionada (por defecto 'area')
    const category = (formData.get('category') || 'area').toString().trim();

    // 🏷️ NUEVO: Obtener offsets de posición del nombre
    const labelOffsetX = parseInt(formData.get('labelOffsetX'), 10) || 0;
    const labelOffsetY = parseInt(formData.get('labelOffsetY'), 10) || 0;

    const jerarquia = {
      nivel1: (formData.get('nivel1') || '').toString().trim() || null,
      nivel2: (formData.get('nivel2') || '').toString().trim() || null,
      nivel3: (formData.get('nivel3') || '').toString().trim() || null,
      nivel4: (formData.get('nivel4') || '').toString().trim() || null,
      nivel5: (formData.get('nivel5') || '').toString().trim() || null
    };

    const equiposRaw = (formData.get('equipos') || '').toString();
    const equipos = equiposRaw
      .split(/\r?\n/)
      .map(line => line.trim())
      .filter(Boolean);

    const area = {
      id: Date.now(),
      mapId: this.state.currentMapId,
      name,
      color,
      opacity,
      category, // 📂 NUEVO: Guardar categoría
      labelOffsetX, // 🏷️ NUEVO: Offset horizontal del nombre
      labelOffsetY, // 🏷️ NUEVO: Offset vertical del nombre
      parentId: null, // 🌳 ETAPA 4: ID del área padre (null = nivel raíz)
      children: [], // 🌳 ETAPA 4: Array de IDs de áreas hijas
      points: [...this.state.tempPoints],
      jerarquia,
      equipos,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      const areas = [...(mapStorage.areas || []), area];
      await mapStorage.saveAreas(areas, { action: 'create', mapId: area.mapId, areaId: area.id, detail: area.name });
      this.state.areas = mapStorage.getAreasByMap(area.mapId);
      this.renderAreaList(this.state.areas);
      this.state.highlightAreaId = area.id;
      this.closeModal();
      this.cancelDrawing();
      this.draw();
      this.showToast('Ãrea guardada correctamente.', 'success');
      this.updateMetaBadge();

      if (typeof app?.aprenderNuevaOpcion === 'function') {
        Object.entries(jerarquia).forEach(([nivel, valor]) => {
          if (valor) {
            app.aprenderNuevaOpcion(nivel, valor);
          }
        });
      }
    } catch (error) {
      console.error('Error guardando la Área:', error);
      this.showToast('No se pudo guardar el Ã¡rea. Revisa la consola.', 'error');
    }
  },

  focusArea(areaId) {
    const area = this.state.areas.find(z => z.id == areaId);
    if (!area || !Array.isArray(area.points) || area.points.length < 1) return;

    this.state.highlightAreaId = area.id;

    const xs = area.points.map(p => p.x);
    const ys = area.points.map(p => p.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    const areaWidth = Math.max(1, maxX - minX);
    const areaHeight = Math.max(1, maxY - minY);
    const canvas = this.elements.canvas;

    const scaleX = (canvas.width * 0.6) / areaWidth;
    const scaleY = (canvas.height * 0.6) / areaHeight;
    const targetScale = Math.min(scaleX, scaleY, this.state.maxScale);

    this.state.scale = Math.max(this.state.minScale, targetScale);
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    this.state.offsetX = canvas.width / 2 - centerX * this.state.scale;
    this.state.offsetY = canvas.height / 2 - centerY * this.state.scale;

    this.draw();
  },

  updateMetaBadge() {
    const badge = this.elements.metaBadge;
    if (!badge) return;
    if (!this.state.currentMap) {
      badge.textContent = 'Sin mapa';
      return;
    }
    const map = this.state.currentMap;
    const areasCount = this.state.areas.length;
    const dimensions = map.width && map.height ? `${map.width} × ${map.height}px` : 'Dimensiones pendientes';
    badge.textContent = `${map.name} × ${dimensions} │ ${areasCount} Ã¡rea(s)`;
  },

  updateZoomBadge() {
    const badge = this.elements.zoomBadge;
    if (!badge) return;
    badge.textContent = `${Math.round(this.state.scale * 100)}%`;
  },

  calculateCentroid(points) {
    if (!Array.isArray(points) || points.length === 0) return null;
    const sum = points.reduce((acc, point) => {
      acc.x += point.x;
      acc.y += point.y;
      return acc;
    }, { x: 0, y: 0 });
    return {
      x: sum.x / points.length,
      y: sum.y / points.length
    };
  },

  // 🗺️ ETAPA 5: Métodos para vinculación Repuesto ↔ Mapa
  
  highlightArea(areaId) {
    console.log('🎯 Resaltando área:', areaId);
    this.state.highlightAreaId = areaId;
    this.draw();
  },

  // 🆕 Hacer parpadear un área para llamar la atención
  flashArea(areaId, times = 3) {
    console.log(`✨ Haciendo parpadear área ${areaId} (${times} veces)`);
    let count = 0;
    const interval = setInterval(() => {
      this.state.highlightAreaId = count % 2 === 0 ? areaId : null;
      this.draw();
      count++;
      
      if (count >= times * 2) {
        clearInterval(interval);
        this.state.highlightAreaId = areaId; // Dejar resaltada al final
        this.draw();
      }
    }, 300); // Parpadear cada 300ms
  },

  zoomToArea(areaId) {
    console.log('🔍 Haciendo zoom al área:', areaId);
    const area = this.state.areas.find(a => String(a.id) === String(areaId));
    
    if (!area || !area.points || area.points.length === 0) {
      console.warn('⚠️ Área no encontrada o sin puntos');
      return;
    }

    // Calcular el bounding box del área
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;

    area.points.forEach(point => {
      if (point.x < minX) minX = point.x;
      if (point.x > maxX) maxX = point.x;
      if (point.y < minY) minY = point.y;
      if (point.y > maxY) maxY = point.y;
    });

    // Calcular el centro del área
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    // Calcular el tamaño del área
    const areaWidth = maxX - minX;
    const areaHeight = maxY - minY;

    // Calcular el zoom óptimo (con un margen del 20%)
    const canvas = this.elements.canvas;
    if (!canvas) return;

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    const scaleX = (canvasWidth * 0.6) / areaWidth;
    const scaleY = (canvasHeight * 0.6) / areaHeight;
    const targetScale = Math.min(scaleX, scaleY, this.state.maxScale);

    // Aplicar zoom y centrado con animación suave
    this.animateZoomTo(centerX, centerY, targetScale);
  },

  animateZoomTo(targetX, targetY, targetScale, duration = 500) {
    const canvas = this.elements.canvas;
    if (!canvas) return;

    const startScale = this.state.scale;
    const startOffsetX = this.state.offsetX;
    const startOffsetY = this.state.offsetY;

    // Calcular el offset final para centrar el punto
    const finalOffsetX = canvas.width / 2 - targetX * targetScale;
    const finalOffsetY = canvas.height / 2 - targetY * targetScale;

    const startTime = performance.now();

    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Easing function (ease-in-out)
      const eased = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      // Interpolar valores
      this.state.scale = startScale + (targetScale - startScale) * eased;
      this.state.offsetX = startOffsetX + (finalOffsetX - startOffsetX) * eased;
      this.state.offsetY = startOffsetY + (finalOffsetY - startOffsetY) * eased;

      this.draw();
      this.updateZoomBadge();

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    };

    requestAnimationFrame(animate);
  },

  pulseArea(areaId, pulses = 3) {
    console.log('💫 Animando pulsación del área:', areaId);
    let count = 0;
    const interval = setInterval(() => {
      this.state.highlightAreaId = count % 2 === 0 ? areaId : null;
      this.draw();
      count++;
      
      if (count >= pulses * 2) {
        clearInterval(interval);
        this.state.highlightAreaId = areaId; // Dejar resaltada al final
        this.draw();
      }
    }, 300);
  },

  loadMap(mapId) {
    console.log('📂 Cargando mapa:', mapId);
    const maps = mapStorage.maps || [];
    const map = maps.find(m => String(m.id) === String(mapId));
    
    if (!map) {
      console.warn('⚠️ Mapa no encontrado:', mapId);
      return;
    }

    this.state.currentMapId = map.id;
    this.state.currentMap = map;
    
    // Cargar imagen del mapa
    if (map.imagePath) {
      this.loadMapImageFromStorage(map.imagePath);
    }

    // Cargar áreas del mapa
    this.loadAreasForMap(map.id);
    
    this.updateMetaBadge();
    this.draw();
  },

  async loadMapImageFromStorage(imagePath) {
    try {
      const blob = await fsManager.readFile(imagePath);
      if (!blob) {
        console.warn('⚠️ No se pudo cargar la imagen del mapa');
        return;
      }

      const url = URL.createObjectURL(blob);
      const img = new Image();
      
      img.onload = () => {
        this.state.currentImage = img;
        this.state.currentImageUrl = url;
        this.configureCanvasForImage(img, { keepViewport: false }); // 🔧 FIX: Configurar canvas con imagen escalada
        this.draw();
      };

      img.onerror = () => {
        console.error('❌ Error cargando imagen del mapa');
      };

      img.src = url;
    } catch (error) {
      console.error('❌ Error leyendo imagen:', error);
    }
  },

  loadAreasForMap(mapId) {
    const allAreas = mapStorage.areas || [];
    this.state.areas = allAreas.filter(area => String(area.mapId) === String(mapId));
    this.renderAreaList(this.state.areas);
    console.log(`📍 ${this.state.areas.length} áreas cargadas para el mapa`);
  },

  // 🎯 NUEVO: Activar modo para colocar marcador de repuesto
  activarModoMarcador(repuestoId, mapId, areaId, modoEdicion = false) {
    this.state.modoMarcador = true;
    this.state.marcadorPendiente = {
      repuestoId,
      mapId,
      areaId
    };
    
    // Cambiar cursor
    if (this.elements.canvas) {
      this.elements.canvas.style.cursor = 'crosshair';
    }
    
    // Mostrar instrucción según modo
    const mensaje = modoEdicion 
      ? '✏️ Haz clic en el área para cambiar la posición del marcador'
      : '� Haz clic en el área resaltada para colocar el marcador';
    
    this.showToast(mensaje, 'info', 5000);
    
    console.log(`🎯 Modo marcador activado para repuesto: ${repuestoId} (edición: ${modoEdicion})`);
  },

  // 🎯 NUEVO: Colocar marcador en el mapa
  async colocarMarcador(x, y) {
    if (!this.state.modoMarcador || !this.state.marcadorPendiente) return;
    
    const { repuestoId, mapId, areaId } = this.state.marcadorPendiente;
    
    console.log('📍 Colocando marcador en:', { x, y });
    console.log('   Área objetivo:', areaId);
    console.log('   Áreas disponibles:', this.state.areas.length);
    
    // 🎯 NUEVA LÓGICA: Buscar áreas cercanas al click (radio aumentado a 300px)
    const areasEncontradas = this.buscarAreasCercanas(x, y, 300);
    
    console.log('🔍 Áreas encontradas cerca del click:', areasEncontradas);
    
    // Si no hay áreas cercanas, buscar específicamente el área asignada
    if (areasEncontradas.length === 0) {
      const areaAsignada = this.state.areas.find(a => String(a.id) === String(areaId));
      console.log('   Buscando área asignada:', areaAsignada?.name);
      
      if (areaAsignada) {
        // Calcular distancia al área asignada
        const distancia = this.distanciaPuntoAArea(x, y, areaAsignada);
        console.log('   Distancia al área asignada:', distancia, 'px');
        
        // Si está dentro o relativamente cerca (hasta 500px), aceptarlo
        if (distancia <= 500) {
          areasEncontradas.push({ area: areaAsignada, distancia, dentro: this.puntoEnArea(x, y, areaAsignada) });
          console.log('   ✅ Área asignada incluida (distancia aceptable)');
        }
      }
    }
    
    // Si TODAVÍA no hay áreas, mostrar error con más info
    if (areasEncontradas.length === 0) {
      const areaAsignada = this.state.areas.find(a => String(a.id) === String(areaId));
      const distancia = areaAsignada ? Math.round(this.distanciaPuntoAArea(x, y, areaAsignada)) : 'N/A';
      this.showToast(`⚠️ Click muy lejos del área "${areaAsignada?.name || 'desconocida'}" (${distancia}px). Haz zoom y acércate más al área resaltada.`, 'warning', 5000);
      return;
    }
    
    // Si hay exactamente 1 área, usarla directamente
    if (areasEncontradas.length === 1) {
      await this.confirmarMarcador(x, y, areasEncontradas[0].area, repuestoId, mapId);
      return;
    }
    
    // Si hay múltiples áreas, mostrar menú de selección
    this.mostrarMenuSeleccionArea(x, y, areasEncontradas, repuestoId, mapId);
  },

  // 🎯 NUEVO: Buscar áreas cercanas a un punto
  buscarAreasCercanas(x, y, radio = 100) {
    const areasEncontradas = [];
    
    for (const area of this.state.areas) {
      if (!area.points || area.points.length < 3) continue;
      
      // 1. Verificar si está dentro del área (prioridad máxima)
      if (this.puntoEnArea(x, y, area)) {
        areasEncontradas.push({ area, distancia: 0, dentro: true });
        continue;
      }
      
      // 2. Calcular distancia al borde del área
      const distancia = this.distanciaPuntoAArea(x, y, area);
      
      if (distancia <= radio) {
        areasEncontradas.push({ area, distancia, dentro: false });
      }
    }
    
    // Ordenar por distancia (primero las que contienen el punto, luego por cercanía)
    areasEncontradas.sort((a, b) => {
      if (a.dentro && !b.dentro) return -1;
      if (!a.dentro && b.dentro) return 1;
      return a.distancia - b.distancia;
    });
    
    return areasEncontradas;
  },

  // 🎯 NUEVO: Calcular distancia de un punto al borde de un área
  distanciaPuntoAArea(x, y, area) {
    let distanciaMin = Infinity;
    
    for (let i = 0; i < area.points.length; i++) {
      const p1 = area.points[i];
      const p2 = area.points[(i + 1) % area.points.length];
      
      const distancia = this.distanciaPuntoASegmento(x, y, p1.x, p1.y, p2.x, p2.y);
      distanciaMin = Math.min(distanciaMin, distancia);
    }
    
    return distanciaMin;
  },

  // 🎯 NUEVO: Calcular distancia de un punto a un segmento de línea
  distanciaPuntoASegmento(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  },

  // 🎯 NUEVO: Mostrar menú contextual para seleccionar área
  mostrarMenuSeleccionArea(x, y, areasEncontradas, repuestoId, mapId) {
    // Eliminar menú previo si existe
    const menuPrevio = document.getElementById('areaSelectionMenu');
    if (menuPrevio) menuPrevio.remove();
    
    // Convertir coordenadas del mapa a coordenadas de pantalla
    const canvas = this.elements.canvas;
    const rect = canvas.getBoundingClientRect();
    const screenX = x * this.state.scale + this.state.offsetX + rect.left;
    const screenY = y * this.state.scale + this.state.offsetY + rect.top;
    
    // Crear menú
    const menu = document.createElement('div');
    menu.id = 'areaSelectionMenu';
    menu.style.cssText = `
      position: fixed;
      left: ${screenX}px;
      top: ${screenY}px;
      background: rgba(15, 23, 42, 0.98);
      border: 2px solid #3b82f6;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      min-width: 250px;
      max-width: 350px;
      animation: fadeInScale 0.2s ease-out;
    `;
    
    // Título
    const titulo = document.createElement('div');
    titulo.textContent = '📍 Selecciona el área';
    titulo.style.cssText = `
      color: #60a5fa;
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      border-bottom: 1px solid rgba(59, 130, 246, 0.3);
      padding-bottom: 8px;
    `;
    menu.appendChild(titulo);
    
    // Lista de áreas
    areasEncontradas.forEach(({ area, distancia, dentro }) => {
      const boton = document.createElement('button');
      const icono = dentro ? '✓' : '→';
      const distanciaTexto = dentro ? 'Click dentro' : `${Math.round(distancia)}px`;
      
      boton.textContent = `${icono} ${area.name}`;
      boton.style.cssText = `
        display: block;
        width: 100%;
        padding: 10px 12px;
        margin: 4px 0;
        background: ${dentro ? 'rgba(16, 185, 129, 0.2)' : 'rgba(59, 130, 246, 0.1)'};
        border: 1px solid ${dentro ? '#10b981' : '#3b82f6'};
        border-radius: 8px;
        color: ${dentro ? '#10b981' : '#60a5fa'};
        cursor: pointer;
        text-align: left;
        font-size: 13px;
        transition: all 0.2s;
        position: relative;
      `;
      
      // Badge de distancia
      const badge = document.createElement('span');
      badge.textContent = distanciaTexto;
      badge.style.cssText = `
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 11px;
        opacity: 0.7;
      `;
      boton.appendChild(badge);
      
      boton.onmouseover = () => {
        boton.style.background = dentro ? 'rgba(16, 185, 129, 0.3)' : 'rgba(59, 130, 246, 0.2)';
        boton.style.transform = 'translateX(4px)';
      };
      boton.onmouseout = () => {
        boton.style.background = dentro ? 'rgba(16, 185, 129, 0.2)' : 'rgba(59, 130, 246, 0.1)';
        boton.style.transform = 'translateX(0)';
      };
      
      boton.onclick = async () => {
        menu.remove();
        await this.confirmarMarcador(x, y, area, repuestoId, mapId);
      };
      
      menu.appendChild(boton);
    });
    
    // Botón cancelar
    const btnCancelar = document.createElement('button');
    btnCancelar.textContent = '✕ Cancelar';
    btnCancelar.style.cssText = `
      display: block;
      width: 100%;
      padding: 8px;
      margin-top: 8px;
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid #ef4444;
      border-radius: 8px;
      color: #f87171;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    `;
    btnCancelar.onmouseover = () => {
      btnCancelar.style.background = 'rgba(239, 68, 68, 0.2)';
    };
    btnCancelar.onmouseout = () => {
      btnCancelar.style.background = 'rgba(239, 68, 68, 0.1)';
    };
    btnCancelar.onclick = () => menu.remove();
    menu.appendChild(btnCancelar);
    
    document.body.appendChild(menu);
    
    // Cerrar al hacer click fuera
    setTimeout(() => {
      const cerrarMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', cerrarMenu);
        }
      };
      document.addEventListener('click', cerrarMenu);
    }, 100);
  },

  // 🎯 NUEVO: Confirmar y guardar marcador en área seleccionada
  async confirmarMarcador(x, y, area, repuestoId, mapId) {
    console.log('✅ Área seleccionada:', area.name);
    console.log('📍 Coordenadas del marcador:', { x, y });
    
    try {
      const repuesto = app.repuestos.find(r => String(r.id) === String(repuestoId));
      if (!repuesto) {
        this.showToast('❌ Repuesto no encontrado', 'error');
        return;
      }
      
      // 🆕 MODO EDICIÓN: Actualizar ubicación existente
      if (window._editandoUbicacion && window._editandoUbicacion.modoEdicion) {
        const { indice } = window._editandoUbicacion;
        
        // Asegurar que existe el array de ubicaciones
        if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) {
          repuesto.ubicaciones = [];
        }
        
        // Si estamos editando pero el array está vacío (migración de formato antiguo)
        if (repuesto.ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
          repuesto.ubicaciones = [{
            mapId: repuesto.mapId,
            areaId: repuesto.areaId,
            markerX: repuesto.markerX,
            markerY: repuesto.markerY
          }];
          delete repuesto.mapId;
          delete repuesto.areaId;
          delete repuesto.markerX;
          delete repuesto.markerY;
        }
        
        // Actualizar ubicación específica
        if (repuesto.ubicaciones[indice]) {
          repuesto.ubicaciones[indice].mapId = mapId;
          repuesto.ubicaciones[indice].areaId = area.id;
          repuesto.ubicaciones[indice].markerX = x;
          repuesto.ubicaciones[indice].markerY = y;
          
          console.log('✏️ Ubicación actualizada en índice:', indice);
          this.showToast(`✅ Ubicación de "${repuesto.nombre}" actualizada en "${area.name}"`, 'success');
        }
        
        // Limpiar modo edición
        delete window._editandoUbicacion;
      } 
      // 🆕 MODO AGREGAR: Crear nueva ubicación
      else {
        // Inicializar array de ubicaciones si no existe
        if (!repuesto.ubicaciones || !Array.isArray(repuesto.ubicaciones)) {
          repuesto.ubicaciones = [];
        }
        
        // Si hay datos en formato antiguo, migrarlos primero
        if (repuesto.mapId && repuesto.areaId && repuesto.ubicaciones.length === 0) {
          repuesto.ubicaciones.push({
            mapId: repuesto.mapId,
            areaId: repuesto.areaId,
            markerX: repuesto.markerX,
            markerY: repuesto.markerY
          });
          delete repuesto.mapId;
          delete repuesto.areaId;
          delete repuesto.markerX;
          delete repuesto.markerY;
        }
        
        // 🔍 VERIFICAR SI YA EXISTE una ubicación en este mapa/área (prevenir duplicados)
        const yaExiste = repuesto.ubicaciones.some(ub => 
          String(ub.mapId) === String(mapId) && String(ub.areaId) === String(area.id)
        );
        
        if (yaExiste) {
          console.warn('⚠️ Ya existe una ubicación en este mapa/área. Actualizando posición...');
          // Actualizar la existente en lugar de agregar duplicado
          const ubicacionExistente = repuesto.ubicaciones.find(ub =>
            String(ub.mapId) === String(mapId) && String(ub.areaId) === String(area.id)
          );
          if (ubicacionExistente) {
            ubicacionExistente.markerX = x;
            ubicacionExistente.markerY = y;
            this.showToast(`✅ Ubicación actualizada en "${area.name}"`, 'success');
          }
        } else {
          // Agregar nueva ubicación (sin duplicado)
          repuesto.ubicaciones.push({
            mapId: mapId,
            areaId: area.id,
            markerX: x,
            markerY: y
          });
          
          console.log('📍 Nueva ubicación agregada. Total ubicaciones:', repuesto.ubicaciones.length);
          this.showToast(`✅ "${repuesto.nombre}" ubicado en "${area.name}"`, 'success');
        }
      }
      
      // Guardar cambios
      await app.saveData();
      
      // Desactivar modo marcador
      this.state.modoMarcador = false;
      this.state.marcadorPendiente = null;
      
      if (this.elements.canvas) {
        this.elements.canvas.style.cursor = 'grab';
      }
      
      // Redibujar con el nuevo marcador
      this.draw();
      
      console.log('✅ Marcador guardado exitosamente');
    } catch (error) {
      console.error('❌ Error guardando marcador:', error);
      this.showToast('❌ Error al guardar la ubicación', 'error');
    }
  },

  // 🎯 NUEVO: Verificar si un punto está dentro de un área
  puntoEnArea(x, y, area) {
    if (!area || !area.points || area.points.length < 3) return false;
    
    // Algoritmo Ray Casting para determinar si el punto está dentro del polígono
    let inside = false;
    for (let i = 0, j = area.points.length - 1; i < area.points.length; j = i++) {
      const xi = area.points[i].x, yi = area.points[i].y;
      const xj = area.points[j].x, yj = area.points[j].y;
      
      const intersect = ((yi > y) !== (yj > y)) && 
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    
    return inside;
  },

  // 🎯 NUEVO: Mostrar marcador en el canvas
  showMarker(x, y, label) {
    // Esta función se llamará desde el draw() para mostrar el marcador
    this.state.currentMarker = { x, y, label };
    this.draw();
  },

  // 🆕 NUEVA FUNCIÓN: Mostrar múltiples ubicaciones en el mapa
  async mostrarMultiplesUbicaciones(ubicaciones, repuesto) {
    if (!ubicaciones || ubicaciones.length === 0) return;
    
    console.log(`🗺️ Mostrando ${ubicaciones.length} ubicaciones de "${repuesto.nombre}"`);
    
    // Agrupar ubicaciones por mapa
    const ubicacionesPorMapa = {};
    ubicaciones.forEach(ub => {
      if (!ubicacionesPorMapa[ub.mapId]) {
        ubicacionesPorMapa[ub.mapId] = [];
      }
      ubicacionesPorMapa[ub.mapId].push(ub);
    });
    
    // Si hay ubicaciones en múltiples mapas, preguntar cuál mostrar
    const mapIds = Object.keys(ubicacionesPorMapa);
    
    if (mapIds.length > 1) {
      // Mostrar modal de selección de mapa
      let mapaSeleccionado = null;
      
      const mapasHTML = mapIds.map(mapId => {
        const mapa = mapStorage.maps.find(m => m.id === parseInt(mapId));
        const count = ubicacionesPorMapa[mapId].length;
        return `<option value="${mapId}">${mapa ? mapa.name : 'Mapa desconocido'} (${count} ubicaciones)</option>`;
      }).join('');
      
      // Usar el primer mapa por defecto
      mapaSeleccionado = parseInt(mapIds[0]);
    } else {
      mapaSeleccionado = parseInt(mapIds[0]);
    }
    
    // Cargar el mapa seleccionado
    await this.loadMap(mapaSeleccionado);
    
    const ubicacionesEnMapa = ubicacionesPorMapa[mapaSeleccionado];
    
    // Esperar a que se cargue el mapa
    setTimeout(() => {
      // 🆕 MEJORADO: Calcular zoom proporcional según número de ubicaciones
      if (ubicacionesEnMapa.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        ubicacionesEnMapa.forEach(ub => {
          if (ub.markerX && ub.markerY) {
            minX = Math.min(minX, ub.markerX);
            minY = Math.min(minY, ub.markerY);
            maxX = Math.max(maxX, ub.markerX);
            maxY = Math.max(maxY, ub.markerY);
          }
        });
        
        if (minX === Infinity) return;
        
        const canvas = this.elements.canvas;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX;
        const height = maxY - minY;
        
        let targetScale, padding;
        
        // 🎯 ZOOM PROPORCIONAL según cantidad de ubicaciones
        if (ubicacionesEnMapa.length === 1) {
          // UNA ubicación: Zoom más cercano (mostrar área con detalle)
          if (ubicacionesEnMapa[0].areaId) {
            // Guardar ubicaciones resaltadas ANTES de hacer zoom
            this.state.ubicacionesResaltadas = ubicacionesEnMapa.map(ub => ({
              x: ub.markerX,
              y: ub.markerY,
              repuesto: repuesto.nombre,
              descripcion: ub.descripcion
            }));
            
            this.zoomToArea(ubicacionesEnMapa[0].areaId);
            
            // Redibujar para mostrar marcadores resaltados
            setTimeout(() => {
              this.draw();
            }, 100);
            
            return; // zoomToArea ya maneja el zoom
          } else {
            // Si no hay área, zoom fijo cercano
            targetScale = 1.5;
            this.state.scale = targetScale;
            this.state.offsetX = canvas.width / 2 - centerX * targetScale;
            this.state.offsetY = canvas.height / 2 - centerY * targetScale;
          }
        } else if (ubicacionesEnMapa.length === 2) {
          // DOS ubicaciones: Zoom moderado con padding generoso
          padding = Math.max(width, height) * 0.8; // 80% de padding
          const scaleX = canvas.width / (width + padding);
          const scaleY = canvas.height / (height + padding);
          targetScale = Math.min(scaleX, scaleY, 1.2); // Máximo 1.2x para 2 puntos
          
          this.state.scale = Math.max(0.2, targetScale);
          this.state.offsetX = canvas.width / 2 - centerX * this.state.scale;
          this.state.offsetY = canvas.height / 2 - centerY * this.state.scale;
          
          console.log(`🔍 Zoom aplicado (2 ubicaciones): escala ${this.state.scale.toFixed(2)}x`);
        } else {
          // TRES O MÁS ubicaciones: Zoom ajustado para ver todas
          // Padding proporcional: menos padding para más puntos
          const paddingFactor = Math.max(0.3, 1 - (ubicacionesEnMapa.length * 0.05)); // De 30% a 100%
          padding = Math.max(width, height) * paddingFactor;
          
          const scaleX = canvas.width / (width + padding);
          const scaleY = canvas.height / (height + padding);
          targetScale = Math.min(scaleX, scaleY, 1.0); // Máximo 1.0x para múltiples
          
          this.state.scale = Math.max(0.1, targetScale);
          this.state.offsetX = canvas.width / 2 - centerX * this.state.scale;
          this.state.offsetY = canvas.height / 2 - centerY * this.state.scale;
          
          console.log(`🔍 Zoom aplicado (${ubicacionesEnMapa.length} ubicaciones): escala ${this.state.scale.toFixed(2)}x`);
        }
      }
      
      // Resaltar áreas con animación pulsante
      const areasIds = [...new Set(ubicacionesEnMapa.map(ub => ub.areaId))];
      areasIds.forEach(areaId => {
        if (this.flashArea) {
          this.flashArea(areaId, 2); // Parpadear 2 veces
        } else if (this.highlightArea) {
          this.highlightArea(areaId);
        }
      });
      
      // Guardar temporalmente las ubicaciones resaltadas
      this.state.ubicacionesResaltadas = ubicacionesEnMapa.map(ub => ({
        x: ub.markerX,
        y: ub.markerY,
        repuesto: repuesto.nombre,
        descripcion: ub.descripcion
      }));
      
      this.draw();
      
      app.showToast(`✅ ${ubicacionesEnMapa.length} ubicaciones resaltadas en el mapa`, 'success');
    }, 500);
  },

  // 🆕 NUEVA FUNCIÓN: Detectar click en un marcador de repuesto
  detectarClickEnMarcador(mapX, mapY) {
    if (!app || !app.repuestos) return null;
    
    console.log(`🔍 Detectando click en (${mapX.toFixed(0)}, ${mapY.toFixed(0)}) en mapa ${this.state.currentMapId}`);
    
    // Buscar todos los marcadores en el mapa actual
    for (const repuesto of app.repuestos) {
      // Formato NUEVO: array de ubicaciones
      if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
        for (let i = 0; i < repuesto.ubicaciones.length; i++) {
          const ub = repuesto.ubicaciones[i];
          if (String(ub.mapId) === String(this.state.currentMapId) && ub.markerX && ub.markerY) {
            // Calcular distancia al marcador
            const distancia = Math.sqrt(
              Math.pow(mapX - ub.markerX, 2) + 
              Math.pow(mapY - ub.markerY, 2)
            );
            
            // 🆕 Radio de detección MEJORADO: Más grande cuando hay zoom alejado
            // Sin zoom (scale=1): 60px, Con zoom medio (scale=0.5): 120px, Muy alejado (scale=0.2): 300px
            const radioDeteccion = Math.max(40, Math.min(300, 60 / this.state.scale));
            
            // console.log(`  📍 Marcador ${repuesto.nombre}[${i}]: distancia ${distancia.toFixed(0)}px, radio ${radioDeteccion.toFixed(0)}px, scale ${this.state.scale.toFixed(2)}`);
            
            if (distancia <= radioDeteccion) {
              console.log(`  ✅ CLICK DETECTADO en ${repuesto.nombre}[${i}]`);
              return {
                repuesto: repuesto,
                ubicacionIndex: i,
                ubicacion: ub,
                x: ub.markerX,
                y: ub.markerY
              };
            }
          }
        }
      }
      
      // Formato ANTIGUO: propiedades directas
      if (repuesto.mapId && String(repuesto.mapId) === String(this.state.currentMapId) && repuesto.markerX && repuesto.markerY) {
        const distancia = Math.sqrt(
          Math.pow(mapX - repuesto.markerX, 2) + 
          Math.pow(mapY - repuesto.markerY, 2)
        );
        
        const radioDeteccion = Math.max(40, Math.min(300, 60 / this.state.scale));
        
        if (distancia <= radioDeteccion) {
          console.log(`  ✅ CLICK DETECTADO en ${repuesto.nombre} (formato antiguo)`);
          return {
            repuesto: repuesto,
            ubicacionIndex: 0,
            ubicacion: {
              mapId: repuesto.mapId,
              areaId: repuesto.areaId,
              markerX: repuesto.markerX,
              markerY: repuesto.markerY,
              descripcion: repuesto.ubicacionDescripcion
            },
            x: repuesto.markerX,
            y: repuesto.markerY
          };
        }
      }
    }
    
    console.log('  ❌ No se detectó click en ningún marcador');
    return null;
  },

  // 🆕 NUEVA FUNCIÓN: Mostrar menú contextual al hacer click en un marcador
  mostrarMenuMarcador(marcadorInfo, screenX, screenY) {
    console.log('📍 Click en marcador:', marcadorInfo.repuesto.nombre);
    
    // Eliminar menú previo si existe
    const menuPrevio = document.getElementById('marcadorContextMenu');
    if (menuPrevio) menuPrevio.remove();
    
    const { repuesto, ubicacionIndex, ubicacion } = marcadorInfo;
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'Ubicación';
    
    // Verificar si hay imagen
    const tieneImagen = (repuesto.imagenes && repuesto.imagenes.length > 0) || repuesto.imagen;
    
    // Crear menú contextual
    const menuHTML = `
      <div id="marcadorContextMenu" style="
        position: fixed;
        left: ${screenX}px;
        top: ${screenY}px;
        background: var(--bg-primary);
        border: 2px solid var(--primary);
        border-radius: 8px;
        padding: 8px 0;
        min-width: 220px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        z-index: 10000;
        animation: fadeInScale 0.2s ease;
      ">
        <div style="
          padding: 8px 12px;
          font-weight: 600;
          color: var(--primary);
          border-bottom: 1px solid var(--border-color);
          font-size: 0.85rem;
        ">
          📍 ${repuesto.nombre}
        </div>
        <div style="
          padding: 6px 12px;
          font-size: 0.75rem;
          color: var(--text-secondary);
          border-bottom: 1px solid var(--border-color);
        ">
          ${areaNombre}
          ${ubicacion.descripcion ? `<br><em>"${ubicacion.descripcion}"</em>` : ''}
        </div>
        <button onclick="mapController.verMarcadorEnMapa('${repuesto.id}', ${ubicacionIndex})" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--text-primary);
          font-size: 0.85rem;
          transition: all 0.2s;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          👁️ Ver en Mapa
        </button>
        <button onclick="mapController.moverMarcador('${repuesto.id}', ${ubicacionIndex})" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--text-primary);
          font-size: 0.85rem;
          transition: all 0.2s;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          ✏️ Mover Marcador
        </button>
        ${tieneImagen ? `
        <button onclick="mapController.abrirModalImagenZoom('${repuesto.id}'); document.getElementById('marcadorContextMenu').remove();" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--text-primary);
          font-size: 0.85rem;
          transition: all 0.2s;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          🖼️ Ver Imagen
        </button>
        ` : ''}
        <button onclick="app.editarDescripcionUbicacion('${repuesto.id}', ${ubicacionIndex}); document.getElementById('marcadorContextMenu').remove();" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--text-primary);
          font-size: 0.85rem;
          transition: all 0.2s;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          💬 Editar Descripción
        </button>
        <button onclick="app.irATarjeta('${repuesto.id}'); document.getElementById('marcadorContextMenu').remove();" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--text-primary);
          font-size: 0.85rem;
          transition: all 0.2s;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          📦 Ver Repuesto
        </button>
        <button onclick="app.eliminarUbicacionRepuesto('${repuesto.id}', ${ubicacionIndex}); document.getElementById('marcadorContextMenu').remove();" style="
          width: 100%;
          padding: 8px 12px;
          background: none;
          border: none;
          text-align: left;
          cursor: pointer;
          color: var(--danger);
          font-size: 0.85rem;
          border-top: 1px solid var(--border-color);
          transition: all 0.2s;
          margin-top: 4px;
        " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
          🗑️ Eliminar Ubicación
        </button>
        <button onclick="document.getElementById('marcadorContextMenu').remove()" style="
          width: 100%;
          padding: 6px 12px;
          background: none;
          border: none;
          text-align: center;
          cursor: pointer;
          color: var(--text-muted);
          font-size: 0.75rem;
          border-top: 1px solid var(--border-color);
          margin-top: 4px;
        ">
          Cerrar
        </button>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', menuHTML);
    
    // Cerrar menú al hacer click fuera
    setTimeout(() => {
      const cerrarMenu = (e) => {
        const menu = document.getElementById('marcadorContextMenu');
        if (menu && !menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', cerrarMenu);
        }
      };
      document.addEventListener('click', cerrarMenu);
    }, 100);
  },

  // 🆕 NUEVA FUNCIÓN: Ver marcador en mapa (sin modal de edición)
  async verMarcadorEnMapa(repuestoId, ubicacionIndex) {
    const repuesto = app.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    // Cerrar menú contextual y tarjeta fija
    const menu = document.getElementById('marcadorContextMenu');
    if (menu) menu.remove();
    this.cerrarTarjetaFija();
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    const ubicacion = ubicaciones[ubicacionIndex];
    if (!ubicacion) return;
    
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'Área desconocida';
    
    // 🆕 FILTRAR: Mostrar solo los puntos de este repuesto
    this.state.repuestoFiltrado = repuestoId;
    
    // Mostrar toast informativo
    this.showToast(`� Filtrando "${repuesto.nombre}" - ${ubicaciones.length} ubicación(es). Doble click afuera para limpiar filtro.`, 'info', 3000);
    
    // Cargar mapa y hacer zoom
    await this.loadMap(ubicacion.mapId);
    
    setTimeout(() => {
      // Hacer zoom al área con el marcador
      this.zoomToArea(ubicacion.areaId);
      
      setTimeout(() => {
        // 🆕 Resaltar TODOS los marcadores de este repuesto en el mapa actual
        const marcadoresEnMapa = ubicaciones.filter(ub => 
          String(ub.mapId) === String(this.state.currentMapId) && ub.markerX && ub.markerY
        );
        
        this.state.ubicacionesResaltadas = marcadoresEnMapa.map(ub => ({
          x: ub.markerX,
          y: ub.markerY,
          repuesto: repuesto.nombre,
          descripcion: ub.descripcion || 'Ubicación del repuesto'
        }));
        
        console.log(`🔵 Resaltando ${this.state.ubicacionesResaltadas.length} ubicaciones de "${repuesto.nombre}"`);
        
        this.draw();
      }, 800);
    }, 500);
  },

  // 🆕 NUEVA FUNCIÓN: Abrir modal con zoom directo desde URL de imagen
  abrirModalImagenZoomDirecto(urlImagen, nombreRepuesto) {
    console.log('🖼️ Abriendo modal de imagen:', urlImagen);
    
    if (!urlImagen) {
      this.showToast('❌ No hay imagen para mostrar', 'error');
      return;
    }
    
    // Cerrar tarjeta fija si existe
    this.cerrarTarjetaFija();
    
    // Crear modal con imagen
    const modalHTML = `
      <div id="modalImagenZoom" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        z-index: 20000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease;
      " onclick="if(event.target.id === 'modalImagenZoom') mapController.cerrarModalImagenZoom()">
        <!-- Header -->
        <div style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          padding: 16px 24px;
          background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
          display: flex;
          justify-content: space-between;
          align-items: center;
          z-index: 2;
        ">
          <div style="
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          ">
            🖼️ ${nombreRepuesto || 'Imagen'}
          </div>
          <button onclick="mapController.cerrarModalImagenZoom(); event.stopPropagation();" style="
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            padding: 8px 16px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
            ✕ Cerrar
          </button>
        </div>
        
        <!-- Indicador de Zoom (solo lectura) -->
        <div style="
          position: absolute;
          bottom: 24px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          border: 2px solid rgba(255, 255, 255, 0.2);
          border-radius: 12px;
          padding: 12px 24px;
          z-index: 2;
          pointer-events: none;
        ">
          <span id="zoomImagenLabel" style="
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
          ">🔍 100% (usa el scroll para zoom)</span>
        </div>
        
        <!-- Container de imagen con scroll -->
        <div id="imagenZoomContainer" style="
          flex: 1;
          width: 100%;
          height: 100%;
          overflow: auto;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 80px 24px 120px;
          cursor: grab;
        ">
          <img id="imagenZoomable" src="${urlImagen}" style="
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease;
            user-select: none;
            -webkit-user-drag: none;
          " draggable="false" onclick="event.stopPropagation()">
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Inicializar estado de zoom
    this.state.imagenZoom = {
      scale: 1.0,
      offsetX: 0,
      offsetY: 0,
      isDragging: false,
      startX: 0,
      startY: 0
    };
    
    // Configurar eventos
    const img = document.getElementById('imagenZoomable');
    const container = document.getElementById('imagenZoomContainer');
    
    // Arrastre para pan
    img.addEventListener('mousedown', (e) => {
      if (this.state.imagenZoom.scale > 1.0) {
        e.preventDefault();
        e.stopPropagation();
        this.state.imagenZoom.isDragging = true;
        this.state.imagenZoom.startX = e.clientX - this.state.imagenZoom.offsetX;
        this.state.imagenZoom.startY = e.clientY - this.state.imagenZoom.offsetY;
        container.style.cursor = 'grabbing';
      }
    });
    
    container.addEventListener('mousemove', (e) => {
      if (this.state.imagenZoom.isDragging) {
        this.state.imagenZoom.offsetX = e.clientX - this.state.imagenZoom.startX;
        this.state.imagenZoom.offsetY = e.clientY - this.state.imagenZoom.startY;
        this.actualizarTransformImagen();
      }
    });
    
    container.addEventListener('mouseup', () => {
      this.state.imagenZoom.isDragging = false;
      if (this.state.imagenZoom.scale > 1.0) {
        container.style.cursor = 'grab';
      }
    });
    
    container.addEventListener('mouseleave', () => {
      this.state.imagenZoom.isDragging = false;
      if (this.state.imagenZoom.scale > 1.0) {
        container.style.cursor = 'grab';
      }
    });
    
    // Zoom con rueda del mouse
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      this.ajustarZoomImagen(delta);
    }, { passive: false });
    
    // Cerrar con ESC
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        this.cerrarModalImagenZoom();
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  },

  // 🆕 FUNCIÓN ORIGINAL: Abrir modal con imagen ampliada y zoom (desde FileSystem)
  async abrirModalImagenZoom(repuestoId) {
    const repuesto = app.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    // Cerrar tarjeta fija si existe
    this.cerrarTarjetaFija();
    
    // Obtener ruta de la imagen
    let imagePath = null;
    if (repuesto.imagenes && repuesto.imagenes.length > 0) {
      imagePath = repuesto.imagenes[0].path;
    } else if (repuesto.imagen) {
      imagePath = repuesto.imagen;
    }
    
    if (!imagePath) {
      this.showToast('❌ Este repuesto no tiene imagen', 'error');
      return;
    }
    
    // Verificar si el archivo existe
    let fileHandle = null;
    try {
      fileHandle = await app.dirHandle.getFileHandle(imagePath);
    } catch (error) {
      this.showToast('❌ No se encontró la imagen', 'error');
      return;
    }
    
    // Crear modal con imagen
    const modalHTML = `
      <div id="modalImagenZoom" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        z-index: 20000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease;
      ">
        <!-- Header -->
        <div style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          padding: 16px 24px;
          background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
          display: flex;
          justify-content: space-between;
          align-items: center;
          z-index: 2;
        ">
          <div style="
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          ">
            🖼️ ${repuesto.nombre}
          </div>
          <button onclick="mapController.cerrarModalImagenZoom()" style="
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            padding: 8px 16px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
            ✕ Cerrar
          </button>
        </div>
        
        <!-- Indicador de Zoom (solo lectura) -->
        <div style="
          position: absolute;
          bottom: 24px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          border: 2px solid rgba(255, 255, 255, 0.2);
          border-radius: 12px;
          padding: 12px 24px;
          z-index: 2;
          pointer-events: none;
        ">
          <span id="zoomImagenLabel" style="
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
          ">🔍 100% (usa el scroll para zoom)</span>
        </div>
        
        <!-- Container de imagen con scroll -->
        <div id="imagenZoomContainer" style="
          flex: 1;
          width: 100%;
          height: 100%;
          overflow: auto;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 80px 24px 120px;
          cursor: grab;
        ">
          <img id="imagenZoomable" src="" style="
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease;
            user-select: none;
            -webkit-user-drag: none;
          " draggable="false">
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Cargar imagen
    try {
      const file = await fileHandle.getFile();
      const url = URL.createObjectURL(file);
      const img = document.getElementById('imagenZoomable');
      img.src = url;
      
      // Inicializar estado de zoom
      this.state.imagenZoom = {
        scale: 1.0,
        offsetX: 0,
        offsetY: 0,
        isDragging: false,
        startX: 0,
        startY: 0
      };
      
      // Configurar eventos de arrastre para pan
      const container = document.getElementById('imagenZoomContainer');
      
      img.addEventListener('mousedown', (e) => {
        if (this.state.imagenZoom.scale > 1.0) {
          e.preventDefault();
          this.state.imagenZoom.isDragging = true;
          this.state.imagenZoom.startX = e.clientX - this.state.imagenZoom.offsetX;
          this.state.imagenZoom.startY = e.clientY - this.state.imagenZoom.offsetY;
          container.style.cursor = 'grabbing';
        }
      });
      
      container.addEventListener('mousemove', (e) => {
        if (this.state.imagenZoom.isDragging) {
          this.state.imagenZoom.offsetX = e.clientX - this.state.imagenZoom.startX;
          this.state.imagenZoom.offsetY = e.clientY - this.state.imagenZoom.startY;
          this.actualizarTransformImagen();
        }
      });
      
      container.addEventListener('mouseup', () => {
        this.state.imagenZoom.isDragging = false;
        if (this.state.imagenZoom.scale > 1.0) {
          container.style.cursor = 'grab';
        }
      });
      
      container.addEventListener('mouseleave', () => {
        this.state.imagenZoom.isDragging = false;
        if (this.state.imagenZoom.scale > 1.0) {
          container.style.cursor = 'grab';
        }
      });
      
      // Zoom con rueda del mouse
      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        this.ajustarZoomImagen(delta);
      }, { passive: false });
      
      // Cerrar con ESC
      const handleEsc = (e) => {
        if (e.key === 'Escape') {
          this.cerrarModalImagenZoom();
          document.removeEventListener('keydown', handleEsc);
        }
      };
      document.addEventListener('keydown', handleEsc);
      
    } catch (error) {
      console.error('Error cargando imagen:', error);
      this.showToast('❌ Error al cargar la imagen', 'error');
      this.cerrarModalImagenZoom();
    }
  },

  ajustarZoomImagen(delta) {
    if (!this.state.imagenZoom) return;
    
    this.state.imagenZoom.scale = Math.max(0.5, Math.min(5.0, this.state.imagenZoom.scale + delta));
    
    // Actualizar cursor
    const container = document.getElementById('imagenZoomContainer');
    if (this.state.imagenZoom.scale > 1.0) {
      container.style.cursor = 'grab';
    } else {
      container.style.cursor = 'default';
      this.state.imagenZoom.offsetX = 0;
      this.state.imagenZoom.offsetY = 0;
    }
    
    this.actualizarTransformImagen();
  },

  resetearZoomImagen() {
    if (!this.state.imagenZoom) return;
    
    this.state.imagenZoom.scale = 1.0;
    this.state.imagenZoom.offsetX = 0;
    this.state.imagenZoom.offsetY = 0;
    
    const container = document.getElementById('imagenZoomContainer');
    container.style.cursor = 'default';
    
    this.actualizarTransformImagen();
  },

  actualizarTransformImagen() {
    const img = document.getElementById('imagenZoomable');
    const label = document.getElementById('zoomImagenLabel');
    
    if (img) {
      img.style.transform = `scale(${this.state.imagenZoom.scale}) translate(${this.state.imagenZoom.offsetX / this.state.imagenZoom.scale}px, ${this.state.imagenZoom.offsetY / this.state.imagenZoom.scale}px)`;
    }
    
    if (label) {
      const porcentaje = Math.round(this.state.imagenZoom.scale * 100);
      label.textContent = `🔍 ${porcentaje}%${porcentaje === 100 ? ' (usa el scroll para zoom)' : ''}`;
    }
  },

  cerrarModalImagenZoom() {
    const modal = document.getElementById('modalImagenZoom');
    if (modal) {
      // Liberar URL de objeto
      const img = document.getElementById('imagenZoomable');
      if (img && img.src.startsWith('blob:')) {
        URL.revokeObjectURL(img.src);
      }
      modal.remove();
    }
    this.state.imagenZoom = null;
  },

  // 🆕 NUEVA FUNCIÓN: Mostrar tarjeta hover simplificada al pasar sobre un repuesto
  mostrarTarjetaHoverRepuesto(marcadorInfo, screenX, screenY) {
    const { repuesto, ubicacion } = marcadorInfo;
    
    // Si hay una tarjeta fija, no mostrar hover
    if (document.getElementById('tarjetaHoverRepuesto')?.dataset.fija === 'true') {
      return;
    }
    
    // Evitar recrear la tarjeta constantemente
    let tarjeta = document.getElementById('tarjetaHoverRepuesto');
    if (tarjeta && tarjeta.dataset.repuestoId === String(repuesto.id)) {
      // Ya existe y es para el mismo repuesto, solo actualizar posición
      tarjeta.style.left = (screenX + 20) + 'px';
      tarjeta.style.top = (screenY - 10) + 'px';
      return;
    }
    
    // Eliminar tarjeta anterior si existe
    if (tarjeta) tarjeta.remove();
    
    this.crearTarjetaRepuesto(repuesto, ubicacion, screenX, screenY, false);
  },

  // 🆕 NUEVA FUNCIÓN: Fijar tarjeta hover al hacer click
  fijarTarjetaHoverRepuesto(marcadorInfo, screenX, screenY) {
    const { repuesto, ubicacion, ubicacionIndex } = marcadorInfo;
    
    // Eliminar tarjeta anterior (hover o fija)
    const tarjetaAnterior = document.getElementById('tarjetaHoverRepuesto');
    if (tarjetaAnterior) tarjetaAnterior.remove();
    
    this.crearTarjetaRepuesto(repuesto, ubicacion, screenX, screenY, true, ubicacionIndex);
  },

  // 🆕 NUEVA FUNCIÓN: Crear tarjeta de repuesto (compartida entre hover y fija)
  crearTarjetaRepuesto(repuesto, ubicacion, screenX, screenY, esFija = false, ubicacionIndex = 0) {
    // Obtener información del repuesto
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'Área desconocida';
    const cantidad = repuesto.cantidad || 0;
    const minimo = repuesto.minimo || 0;
    const optimo = repuesto.optimo || 0;
    
    // 🆕 Calcular escala de texto según el zoom del mapa
    // Zoom 1.0 = 100%, Zoom 2.0 = 80%, Zoom 3.0 = 70%, etc.
    const zoom = this.state.zoom || 1.0;
    const factorEscala = Math.max(0.6, 1.0 / Math.sqrt(zoom)); // Mínimo 60%, máximo 100%
    
    const fontSize = {
      titulo: (1.0 * factorEscala).toFixed(2) + 'rem',
      subtitulo: (0.8 * factorEscala).toFixed(2) + 'rem',
      codigo: (0.75 * factorEscala).toFixed(2) + 'rem',
      label: (0.7 * factorEscala).toFixed(2) + 'rem',
      stock: (1.1 * factorEscala).toFixed(2) + 'rem',
      stockDetalle: (0.95 * factorEscala).toFixed(2) + 'rem',
      boton: (0.8 * factorEscala).toFixed(2) + 'rem'
    };
    
    const anchoTarjeta = Math.round(300 * factorEscala);
    const padding = Math.round(14 * factorEscala);
    
    // Determinar estado de stock
    let estadoStock = '';
    let colorStock = '';
    if (cantidad === 0) {
      estadoStock = 'SIN STOCK';
      colorStock = '#ef4444';
    } else if (cantidad < minimo) {
      estadoStock = 'BAJO';
      colorStock = '#f59e0b';
    } else if (cantidad >= optimo) {
      estadoStock = 'ÓPTIMO';
      colorStock = '#22c55e';
    } else {
      estadoStock = 'NORMAL';
      colorStock = '#3b82f6';
    }
    
    // Crear galería de imágenes si existen
    let imagenesHTML = '';
    if (repuesto.multimedia && repuesto.multimedia.length > 0) {
      // Filtrar solo imágenes y eliminar duplicados por URL
      const todasImagenes = repuesto.multimedia.filter(m => m.type === 'image');
      
      // Eliminar duplicados usando un Set con las URLs
      const urlsUnicas = new Set();
      const imagenes = todasImagenes.filter(img => {
        const url = img.url || '';
        if (url && !urlsUnicas.has(url)) {
          urlsUnicas.add(url);
          return true;
        }
        return false;
      }).slice(0, 5); // Máximo 5 imágenes únicas
      
      console.log(`🖼️ Repuesto "${repuesto.nombre}": ${todasImagenes.length} imágenes totales → ${imagenes.length} únicas`);
      
      if (imagenes.length > 0) {
        const alturaImagen = Math.round(140 * factorEscala);
        
        // 🎠 CARRUSEL DE IMÁGENES
        imagenesHTML = `
          <div id="carruselContainer" style="position: relative; margin-bottom: ${Math.round(12 * factorEscala)}px;">
            <!-- Imágenes del carrusel -->
            <div id="carruselImagenes" style="
              width: 100%;
              height: ${alturaImagen}px;
              position: relative;
              overflow: hidden;
              border-radius: ${Math.round(6 * factorEscala)}px;
              border: 1px solid rgba(255,255,255,0.1);
            ">
              ${imagenes.map((img, idx) => {
                // 🆕 Resolver ruta de imagen correctamente
                let urlImagen = img.url || '';
                
                // 🔧 FIX: Las imágenes están en INVENTARIO_STORAGE/imagenes/
                if (urlImagen.startsWith('./imagenes/')) {
                  urlImagen = 'INVENTARIO_STORAGE/imagenes/' + urlImagen.substring(11);
                } else if (urlImagen.startsWith('imagenes/')) {
                  urlImagen = 'INVENTARIO_STORAGE/' + urlImagen;
                }
                
                console.log('🖼️ Intentando cargar imagen:', urlImagen);
                
                return `
                  <div class="carrusel-item" data-index="${idx}" 
                    onclick="mapController.abrirModalImagenZoomDirecto('${urlImagen.replace(/'/g, "\\'")}', '${repuesto.nombre.replace(/'/g, "\\'")}'); event.stopPropagation();"
                    style="
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: url('${urlImagen}') center/cover no-repeat, linear-gradient(135deg, rgba(59,130,246,0.1) 0%, rgba(37,99,235,0.1) 100%);
                    opacity: ${idx === 0 ? '1' : '0'};
                    transition: opacity 0.3s ease-in-out;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: zoom-in;
                  ">
                    ${!urlImagen ? '<div style="font-size: 3rem; opacity: 0.3;">📷</div>' : ''}
                    ${urlImagen ? '<div style="position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.6); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; pointer-events: none;">🔍 Click para ampliar</div>' : ''}
                  </div>
                `;
              }).join('')}
            </div>
            
            ${imagenes.length > 1 ? `
              <!-- Flechas de navegación -->
              <button onclick="mapController.anteriorImagenCarrusel(event)" style="
                position: absolute;
                left: ${Math.round(8 * factorEscala)}px;
                top: 50%;
                transform: translateY(-50%);
                background: rgba(0,0,0,0.7);
                color: white;
                border: none;
                border-radius: 50%;
                width: ${Math.round(32 * factorEscala)}px;
                height: ${Math.round(32 * factorEscala)}px;
                cursor: pointer;
                font-size: ${Math.round(18 * factorEscala)}px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10;
                transition: all 0.2s;
              " onmouseenter="this.style.background='rgba(0,0,0,0.9)'" onmouseleave="this.style.background='rgba(0,0,0,0.7)'">
                ◀
              </button>
              <button onclick="mapController.siguienteImagenCarrusel(event)" style="
                position: absolute;
                right: ${Math.round(8 * factorEscala)}px;
                top: 50%;
                transform: translateY(-50%);
                background: rgba(0,0,0,0.7);
                color: white;
                border: none;
                border-radius: 50%;
                width: ${Math.round(32 * factorEscala)}px;
                height: ${Math.round(32 * factorEscala)}px;
                cursor: pointer;
                font-size: ${Math.round(18 * factorEscala)}px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10;
                transition: all 0.2s;
              " onmouseenter="this.style.background='rgba(0,0,0,0.9)'" onmouseleave="this.style.background='rgba(0,0,0,0.7)'">
                ▶
              </button>
              
              <!-- Indicadores (dots) -->
              <div style="
                position: absolute;
                bottom: ${Math.round(8 * factorEscala)}px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: ${Math.round(6 * factorEscala)}px;
                z-index: 10;
              ">
                ${imagenes.map((_, idx) => `
                  <div class="carrusel-dot" data-index="${idx}" style="
                    width: ${Math.round(8 * factorEscala)}px;
                    height: ${Math.round(8 * factorEscala)}px;
                    border-radius: 50%;
                    background: ${idx === 0 ? 'white' : 'rgba(255,255,255,0.4)'};
                    cursor: pointer;
                    transition: background 0.3s;
                  " onclick="mapController.irAImagenCarrusel(${idx}, event)"></div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        `;
      }
    }
    
    // Botones solo si es tarjeta fija
    let botonesHTML = '';
    if (esFija) {
      const btnPadding = `${Math.round(8 * factorEscala)}px ${Math.round(12 * factorEscala)}px`;
      const btnBorderRadius = Math.round(6 * factorEscala) + 'px';
      const btnGap = Math.round(6 * factorEscala) + 'px';
      
      botonesHTML = `
        <div style="
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          gap: ${btnGap};
          margin-top: ${Math.round(12 * factorEscala)}px;
          padding-top: ${Math.round(12 * factorEscala)}px;
          border-top: 1px solid rgba(255,255,255,0.1);
        ">
          <button onclick="mapController.verMarcadorEnMapa('${repuesto.id}', ${ubicacionIndex}); event.stopPropagation();" style="
            padding: ${btnPadding};
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: ${btnBorderRadius};
            font-size: ${fontSize.boton};
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.transform='translateY(-2px)'" onmouseleave="this.style.transform='translateY(0)'">
            👁️ Ver
          </button>
          <button onclick="mapController.openEditMarkerModal('${repuesto.id}', ${ubicacionIndex}); event.stopPropagation();" style="
            padding: ${btnPadding};
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
            border: none;
            border-radius: ${btnBorderRadius};
            font-size: ${fontSize.boton};
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.transform='translateY(-2px)'" onmouseleave="this.style.transform='translateY(0)'">
            E Datos
          </button>
          <button onclick="mapController.moverMarcador('${repuesto.id}', ${ubicacionIndex}); event.stopPropagation();" style="
            padding: ${btnPadding};
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            border-radius: ${btnBorderRadius};
            font-size: ${fontSize.boton};
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.transform='translateY(-2px)'" onmouseleave="this.style.transform='translateY(0)'">
            ✏️ Mover
          </button>
        </div>
        <div style="
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: ${btnGap};
          margin-top: ${btnGap};
        ">
          <button onclick="mapController.irATarjetaDesdeMapa('${repuesto.id}'); event.stopPropagation();" style="
            padding: ${btnPadding};
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: ${btnBorderRadius};
            font-size: ${fontSize.boton};
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.background='rgba(255,255,255,0.15)'" onmouseleave="this.style.background='rgba(255,255,255,0.1)'">
            📦 Tarjeta
          </button>
          <button onclick="app.eliminarUbicacionRepuesto('${repuesto.id}', ${ubicacionIndex}); mapController.cerrarTarjetaFija(); event.stopPropagation();" style="
            padding: ${btnPadding};
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
            border-radius: ${btnBorderRadius};
            font-size: ${fontSize.boton};
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.background='rgba(239, 68, 68, 0.3)'" onmouseleave="this.style.background='rgba(239, 68, 68, 0.2)'">
            🗑️ Eliminar
          </button>
        </div>
      `;
    }
    
    const tarjetaHTML = `
      <div id="tarjetaHoverRepuesto" 
           data-repuesto-id="${repuesto.id}" 
           data-fija="${esFija}"
           style="
        position: fixed;
        left: ${screenX + 20}px;
        top: ${screenY - 10}px;
        background: rgba(15, 23, 42, 0.98);
        color: white;
        border-radius: ${Math.round(12 * factorEscala)}px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.1);
        z-index: 99999;
        width: ${anchoTarjeta}px;
        backdrop-filter: blur(20px);
        animation: fadeInCard 0.2s ease-out;
        ${esFija ? 'pointer-events: auto; cursor: default;' : 'pointer-events: none;'}
      ">
        <style>
          @keyframes fadeInCard {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
          }
        </style>
        
        <div style="padding: ${padding}px;">
          ${imagenesHTML}
          
          <!-- Título -->
          <div style="font-weight: 700; font-size: ${fontSize.titulo}; margin-bottom: ${Math.round(8 * factorEscala)}px; line-height: 1.3;">
            ${repuesto.nombre}
          </div>
          
          <!-- Códigos -->
          ${repuesto.codigoSAP || repuesto.codigoFabrica ? `
            <div style="font-size: ${fontSize.codigo}; opacity: 0.7; margin-bottom: ${Math.round(10 * factorEscala)}px; font-family: 'Courier New', monospace;">
              ${repuesto.codigoSAP ? `SAP: ${repuesto.codigoSAP}` : ''}
              ${repuesto.codigoSAP && repuesto.codigoFabrica ? ' | ' : ''}
              ${repuesto.codigoFabrica ? `FAB: ${repuesto.codigoFabrica}` : ''}
            </div>
          ` : ''}
          
          <!-- Stock -->
          <div style="
            display: flex;
            gap: ${Math.round(8 * factorEscala)}px;
            margin-bottom: ${Math.round(10 * factorEscala)}px;
            padding: ${Math.round(8 * factorEscala)}px ${Math.round(10 * factorEscala)}px;
            background: rgba(255,255,255,0.05);
            border-radius: ${Math.round(6 * factorEscala)}px;
            border-left: ${Math.round(3 * factorEscala)}px solid ${colorStock};
          ">
            <div style="flex: 1;">
              <div style="font-size: ${fontSize.label}; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px;">Stock</div>
              <div style="font-size: ${fontSize.stock}; font-weight: 700; color: ${colorStock};">${cantidad}</div>
            </div>
            <div style="flex: 1;">
              <div style="font-size: ${fontSize.label}; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px;">Mín</div>
              <div style="font-size: ${fontSize.stockDetalle}; font-weight: 600;">${minimo}</div>
            </div>
            <div style="flex: 1;">
              <div style="font-size: ${fontSize.label}; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px;">Ópt</div>
              <div style="font-size: ${fontSize.stockDetalle}; font-weight: 600;">${optimo}</div>
            </div>
          </div>
          
          <!-- Estado -->
          <div style="
            display: inline-block;
            padding: ${Math.round(4 * factorEscala)}px ${Math.round(10 * factorEscala)}px;
            background: ${colorStock}22;
            border: 1px solid ${colorStock};
            border-radius: ${Math.round(6 * factorEscala)}px;
            font-size: ${fontSize.label};
            font-weight: 700;
            color: ${colorStock};
            letter-spacing: 0.5px;
            margin-bottom: ${Math.round(8 * factorEscala)}px;
          ">
            ${estadoStock}
          </div>
          
          <!-- Ubicación -->
          <div style="
            font-size: ${fontSize.subtitulo};
            opacity: 0.8;
            padding-top: ${Math.round(8 * factorEscala)}px;
            border-top: 1px solid rgba(255,255,255,0.1);
          ">
            📍 ${areaNombre}
          </div>
          
          ${botonesHTML}
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', tarjetaHTML);
    
    // Si es fija, agregar event listener para cerrar al hacer click fuera
    if (esFija) {
      // 🔧 MEJORA: Delay más largo para asegurar que el click se procese
      setTimeout(() => {
        const cerrarAlClickFuera = (e) => {
          const tarjeta = document.getElementById('tarjetaHoverRepuesto');
          // Verificar si el click fue en un marcador del canvas
          const canvas = document.getElementById('mapCanvas');
          const esClickEnCanvas = canvas && canvas.contains(e.target);
          
          if (tarjeta && !tarjeta.contains(e.target)) {
            // Si es click en canvas, verificar si es en un marcador
            if (esClickEnCanvas) {
              // Dejar que el mousedown del canvas maneje esto
              return;
            }
            
            tarjeta.remove();
            document.removeEventListener('click', cerrarAlClickFuera);
          }
        };
        document.addEventListener('click', cerrarAlClickFuera);
      }, 200); // Aumentado de 100 a 200ms
    }
  },

  // 🆕 NUEVA FUNCIÓN: Ocultar tarjeta hover (solo si NO es fija)
  ocultarTarjetaHoverRepuesto() {
    const tarjeta = document.getElementById('tarjetaHoverRepuesto');
    if (tarjeta && tarjeta.dataset.fija !== 'true') {
      tarjeta.remove();
    }
  },

  // 🆕 NUEVA FUNCIÓN: Cerrar tarjeta fija manualmente
  cerrarTarjetaFija() {
    const tarjeta = document.getElementById('tarjetaHoverRepuesto');
    if (tarjeta && tarjeta.dataset.fija === 'true') {
      tarjeta.remove();
    }
  },

  // 🎠 FUNCIONES DEL CARRUSEL DE IMÁGENES
  siguienteImagenCarrusel(event) {
    event.stopPropagation();
    const items = document.querySelectorAll('.carrusel-item');
    if (items.length <= 1) return;
    
    let currentIndex = 0;
    items.forEach((item, idx) => {
      if (item.style.opacity === '1') currentIndex = idx;
    });
    
    const nextIndex = (currentIndex + 1) % items.length;
    this.mostrarImagenCarrusel(nextIndex);
  },

  anteriorImagenCarrusel(event) {
    event.stopPropagation();
    const items = document.querySelectorAll('.carrusel-item');
    if (items.length <= 1) return;
    
    let currentIndex = 0;
    items.forEach((item, idx) => {
      if (item.style.opacity === '1') currentIndex = idx;
    });
    
    const prevIndex = (currentIndex - 1 + items.length) % items.length;
    this.mostrarImagenCarrusel(prevIndex);
  },

  irAImagenCarrusel(index, event) {
    event.stopPropagation();
    this.mostrarImagenCarrusel(index);
  },

  mostrarImagenCarrusel(index) {
    const items = document.querySelectorAll('.carrusel-item');
    const dots = document.querySelectorAll('.carrusel-dot');
    
    items.forEach((item, idx) => {
      item.style.opacity = idx === index ? '1' : '0';
    });
    
    dots.forEach((dot, idx) => {
      dot.style.background = idx === index ? 'white' : 'rgba(255,255,255,0.4)';
    });
  },

  // 🆕 FUNCIÓN: Ir a tarjeta desde el mapa (cierra modal y navega)
  irATarjetaDesdeMapa(repuestoId) {
    console.log('📦 Navegando a tarjeta desde mapa:', repuestoId);
    
    // 1. Cerrar modal del mapa
    this.cerrarTarjetaFija();
    
    // 2. Cambiar a tab de inventario
    if (typeof app !== 'undefined' && app.irATarjeta) {
      // Pequeño delay para que el cierre del modal se complete
      setTimeout(() => {
        app.irATarjeta(repuestoId);
      }, 100);
    }
  },

  // 🆕 NUEVA FUNCIÓN: Activar modo mover marcador
  // 🆕 REDISEÑADO: Nueva función para mover marcador con modal de arrastre
  async moverMarcador(repuestoId, ubicacionIndex) {
    const repuesto = app.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    // Cerrar menú contextual
    const menu = document.getElementById('marcadorContextMenu');
    if (menu) menu.remove();
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
      repuesto.ubicaciones = ubicaciones;
      delete repuesto.mapId;
      delete repuesto.areaId;
      delete repuesto.markerX;
      delete repuesto.markerY;
      delete repuesto.ubicacionDescripcion;
    }
    
    const ubicacion = ubicaciones[ubicacionIndex];
    if (!ubicacion) return;
    
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const mapa = mapStorage.maps.find(m => m.id === ubicacion.mapId);
    const areaNombre = area ? area.name : 'Área desconocida';
    const mapaNombre = mapa ? mapa.name : 'Mapa desconocido';
    
    // Cerrar modal de ubicaciones si está abierto
    const modalUbicaciones = document.getElementById('modalSeleccionUbicacion');
    if (modalUbicaciones) modalUbicaciones.remove();
    
    // Cambiar a tab de mapa
    app.switchTab('mapa');
    
    // Mostrar toast de carga
    this.showToast('🗺️ Cargando mapa...', 'info', 1500);
    
    // Cargar mapa y hacer zoom
    setTimeout(async () => {
      // Cargar el mapa
      await this.loadMap(ubicacion.mapId);
      
      setTimeout(() => {
        // Hacer zoom al área con el marcador
        this.zoomToArea(ubicacion.areaId);
        
        setTimeout(() => {
          // Resaltar el marcador actual
          this.state.ubicacionesResaltadas = [{
            x: ubicacion.markerX,
            y: ubicacion.markerY,
            repuesto: repuesto.nombre,
            descripcion: ubicacion.descripcion
          }];
          
          this.draw();
          
          // Mostrar modal flotante con instrucciones
          this.mostrarModalMoverPin(repuesto, ubicacion, ubicacionIndex, areaNombre, mapaNombre);
        }, 800);
      }, 500);
    }, 300);
  },
  
  // 🆕 NUEVA FUNCIÓN: Modal flotante para mover pin
  mostrarModalMoverPin(repuesto, ubicacion, ubicacionIndex, areaNombre, mapaNombre) {
    console.log('🔍 mostrarModalMoverPin llamado:', { repuesto, ubicacion, ubicacionIndex, areaNombre, mapaNombre });
    
    // Guardar información del pin a mover
    this.state.pinAMover = {
      repuestoId: repuesto.id,
      ubicacionIndex: ubicacionIndex,
      ubicacionOriginal: { ...ubicacion },
      editando: false  // Inicia en false, se activa al hacer click en "Mover Pin"
    };
    
    console.log('✅ Estado pinAMover inicializado:', this.state.pinAMover);
    
    const modalHTML = `
      <div id="modalMoverPin" style="
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(30, 41, 59, 0.95);
        color: white;
        padding: 16px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.1);
        z-index: 10000;
        width: 320px;
        backdrop-filter: blur(20px);
        animation: fadeInRight 0.3s ease-out;
        cursor: move;
      " onmousedown="mapController.iniciarArrastreModal(event)">
        <style>
          @keyframes fadeInRight {
            from {
              transform: translateX(100px);
              opacity: 0;
            }
            to {
              transform: translateX(0);
              opacity: 1;
            }
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
          }
          #modalMoverPin:hover {
            background: rgba(30, 41, 59, 0.98);
          }
        </style>
        
        <!-- Título compacto con drag handle -->
        <div style="
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 14px;
          padding-bottom: 12px;
          border-bottom: 1px solid rgba(255,255,255,0.1);
        ">
          <div style="
            font-size: 1.4rem;
            animation: pulse 2s infinite;
          ">📍</div>
          <div style="flex: 1;">
            <div style="font-size: 0.95rem; font-weight: 700; margin-bottom: 2px;">
              Mover Pin
            </div>
            <div style="font-size: 0.75rem; opacity: 0.7;">
              ${repuesto.nombre.length > 25 ? repuesto.nombre.substring(0, 25) + '...' : repuesto.nombre}
            </div>
          </div>
          <button onclick="event.stopPropagation(); mapController.cancelarMoverPin()" style="
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
            line-height: 1;
            padding: 0;
          " onmouseenter="this.style.background='rgba(255,60,60,0.8)'" onmouseleave="this.style.background='rgba(255,255,255,0.1)'">
            ×
          </button>
        </div>
        
        <!-- Info compacta -->
        <div style="
          background: rgba(255,255,255,0.08);
          padding: 10px 12px;
          border-radius: 8px;
          margin-bottom: 14px;
          border-left: 3px solid #3b82f6;
          font-size: 0.85rem;
        ">
          <div style="opacity: 0.7; margin-bottom: 4px; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">
            Ubicación Actual
          </div>
          <div style="display: flex; flex-direction: column; gap: 3px;">
            <div>🗺️ ${mapaNombre.length > 30 ? mapaNombre.substring(0, 30) + '...' : mapaNombre}</div>
            <div>📍 ${areaNombre.length > 30 ? areaNombre.substring(0, 30) + '...' : areaNombre}</div>
          </div>
        </div>
        
        <!-- Botones compactos -->
        <div id="botonesIniciales" style="display: flex; gap: 8px;">
          <button id="btnIniciarMoverPin" onclick="event.stopPropagation(); mapController.iniciarEdicionPin()" style="
            flex: 1;
            padding: 10px 16px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
          " onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(59, 130, 246, 0.4)'" 
             onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(59, 130, 246, 0.3)'">
            📍 Mover
          </button>
          <button onclick="event.stopPropagation(); mapController.cancelarMoverPin()" style="
            padding: 10px 16px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.background='rgba(255,255,255,0.15)'" onmouseleave="this.style.background='rgba(255,255,255,0.1)'">
            ✕
          </button>
        </div>
        
        <!-- Botones durante edición (ocultos inicialmente) -->
        <div id="botonesEdicion" style="display: none; gap: 8px;">
          <button id="btnGuardarNuevaPosicion" onclick="event.stopPropagation(); mapController.guardarNuevaPosicionPin()" style="
            flex: 1;
            padding: 10px 16px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 8px rgba(34, 197, 94, 0.3);
          " onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(34, 197, 94, 0.4)'" 
             onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(34, 197, 94, 0.3)'">
            💾 Guardar
          </button>
          <button onclick="event.stopPropagation(); mapController.cancelarMoverPin()" style="
            padding: 10px 16px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
          " onmouseenter="this.style.background='rgba(255,255,255,0.15)'" onmouseleave="this.style.background='rgba(255,255,255,0.1)'">
            ✕
          </button>
        </div>
        
        <!-- 💡 Ayuda del círculo pulsante -->
        <div style="
          margin-top: 12px;
          padding: 8px 12px;
          background: rgba(59, 130, 246, 0.15);
          border-left: 3px solid #3b82f6;
          border-radius: 6px;
          font-size: 0.8rem;
          line-height: 1.4;
        ">
          <strong style="color: #60a5fa;">💡 Círculo azul pulsante:</strong>
          <div style="opacity: 0.9; margin-top: 4px;">
            Indica la ubicación actual del repuesto en el mapa. Al activar "Mover", el pin se volverá naranja y podrás arrastrarlo.
          </div>
        </div>
      </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
  },
  
  // 🆕 NUEVA FUNCIÓN: Iniciar arrastre del modal
  iniciarArrastreModal(event) {
    // Solo permitir arrastre si se hace click en el área del título/fondo, no en botones
    if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
      return; // No arrastrar si se clickeó un botón
    }
    
    const modal = document.getElementById('modalMoverPin');
    if (!modal) return;
    
    // Guardar estado inicial
    this.state.arrastreModal = {
      activo: true,
      inicioX: event.clientX,
      inicioY: event.clientY,
      modalX: modal.offsetLeft,
      modalY: modal.offsetTop
    };
    
    modal.style.cursor = 'grabbing';
    
    // Agregar listeners temporales
    const moverModal = (e) => {
      if (!this.state.arrastreModal || !this.state.arrastreModal.activo) return;
      
      const deltaX = e.clientX - this.state.arrastreModal.inicioX;
      const deltaY = e.clientY - this.state.arrastreModal.inicioY;
      
      const nuevaX = this.state.arrastreModal.modalX + deltaX;
      const nuevaY = this.state.arrastreModal.modalY + deltaY;
      
      // Limitar a los bordes de la ventana
      const maxX = window.innerWidth - modal.offsetWidth;
      const maxY = window.innerHeight - modal.offsetHeight;
      
      modal.style.left = Math.max(0, Math.min(nuevaX, maxX)) + 'px';
      modal.style.top = Math.max(0, Math.min(nuevaY, maxY)) + 'px';
      modal.style.right = 'auto'; // Desactivar posicionamiento por right
    };
    
    const soltarModal = () => {
      if (modal) modal.style.cursor = 'move';
      this.state.arrastreModal = null;
      document.removeEventListener('mousemove', moverModal);
      document.removeEventListener('mouseup', soltarModal);
    };
    
    document.addEventListener('mousemove', moverModal);
    document.addEventListener('mouseup', soltarModal);
  },
  
  // 🆕 NUEVA FUNCIÓN: Iniciar modo edición del pin (pin naranja)
  iniciarEdicionPin() {
    console.log('🎯 Iniciando modo edición de pin...');
    
    if (!this.state.pinAMover) {
      console.error('❌ No hay pin para mover');
      return;
    }
    
    // Activar modo edición
    this.state.pinAMover.editando = true;
    
    // Cambiar UI del modal
    const botonesIniciales = document.getElementById('botonesIniciales');
    const botonesEdicion = document.getElementById('botonesEdicion');
    
    if (botonesIniciales) botonesIniciales.style.display = 'none';
    if (botonesEdicion) botonesEdicion.style.display = 'flex';
    
    // Toast de instrucción
    this.showToast('🎯 Arrastra el pin naranja a su nueva ubicación', 'info', 4000);
    
    // Redibujar para mostrar el pin en naranja
    this.draw();
  },
  
  // 🆕 NUEVA FUNCIÓN: Cancelar modo mover pin
  cancelarMoverPin() {
    console.log('❌ Cancelando modo mover pin...');
    
    // Limpiar estado
    this.state.pinAMover = null;
    this.state.ubicacionesResaltadas = null;
    
    // Cerrar modal
    const modal = document.getElementById('modalMoverPin');
    if (modal) modal.remove();
    
    // Redibujar
    this.draw();
    
    this.showToast('❌ Movimiento de pin cancelado', 'info');
  },
  
  // 🆕 NUEVA FUNCIÓN: Guardar nueva posición del pin
  async guardarNuevaPosicionPin() {
    console.log('💾 Guardando nueva posición del pin...');
    
    if (!this.state.pinAMover) {
      console.error('❌ No hay pin para guardar');
      return;
    }
    
    const { repuestoId, ubicacionIndex } = this.state.pinAMover;
    
    const repuesto = app.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) {
      console.error('❌ Repuesto no encontrado');
      return;
    }
    
    // Obtener la nueva posición desde ubicacionesResaltadas (es donde se arrastra el pin)
    if (!this.state.ubicacionesResaltadas || this.state.ubicacionesResaltadas.length === 0) {
      this.showToast('⚠️ Debes mover el pin primero', 'warning');
      return;
    }
    
    const nuevaPosicion = this.state.ubicacionesResaltadas[0];
    
    // Buscar área cercana
    const areasCercanas = this.buscarAreasCercanas(nuevaPosicion.x, nuevaPosicion.y, 300);
    
    if (areasCercanas.length === 0) {
      this.showToast('⚠️ El pin debe estar dentro de un área', 'warning');
      return;
    }
    
    const area = areasCercanas[0].area;
    
    console.log('✅ Área encontrada:', area.name);
    console.log('📍 Nueva posición:', { x: nuevaPosicion.x, y: nuevaPosicion.y });
    
    // Actualizar ubicación
    if (repuesto.ubicaciones && repuesto.ubicaciones[ubicacionIndex]) {
      repuesto.ubicaciones[ubicacionIndex].markerX = nuevaPosicion.x;
      repuesto.ubicaciones[ubicacionIndex].markerY = nuevaPosicion.y;
      repuesto.ubicaciones[ubicacionIndex].areaId = area.id;
    }
    
    // Guardar cambios
    try {
      await app.saveData();
      
      this.showToast(`✅ Pin movido exitosamente a "${area.name}"`, 'success');
      
      // Limpiar estado
      this.state.pinAMover = null;
      this.state.ubicacionesResaltadas = null;
      
      // Cerrar modal
      const modal = document.getElementById('modalMoverPin');
      if (modal) modal.remove();
      
      // Redibujar
      this.draw();
    } catch (error) {
      console.error('Error guardando nueva posición:', error);
      this.showToast('❌ Error al guardar la nueva posición', 'error');
    }
  },

  openNewMapModal() {
    if (!mapStorage.initialized) {
      this.showToast('Conecta la carpeta antes de crear un mapa.', 'info');
      return;
    }

    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) return;

    this.elements.modalTitle.textContent = 'Nuevo mapa';
    body.innerHTML = `
      <form id="mapCreateForm" class="map-area-form">
        <div class="form-group">
          <label>Nombre del mapa</label>
          <input type="text" name="mapName" required placeholder="Ej: Planta principal" />
        </div>
        <div class="form-group">
          <label>Imagen del mapa</label>
          <input type="file" name="mapImage" accept="image/*" required />
          <small style="color: var(--text-secondary); font-size: 0.75rem;">Se recomienda usar imágenes en alta resolución (PNG, JPG o WEBP).</small>
        </div>
        <div class="form-actions">
          <button type="button" class="map-btn map-btn--ghost" data-action="cancel">Cancelar</button>
          <button type="submit" class="map-btn map-btn--primary">Guardar mapa</button>
        </div>
      </form>
    `;

    modal.classList.remove('hidden');

    const form = body.querySelector('#mapCreateForm');
    const cancelBtn = body.querySelector('[data-action="cancel"]');

    if (cancelBtn) cancelBtn.addEventListener('click', () => this.closeModal());
    if (form) {
      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        await this.createMapFromForm(formData);
      });
    }
  },

  async createMapFromForm(formData) {
    const name = (formData.get('mapName') || '').toString().trim();
    const file = formData.get('mapImage');
    if (!name) {
      this.showToast('Asigna un nombre al mapa.', 'warning');
      return;
    }
    if (!(file instanceof File)) {
      this.showToast('Selecciona una imagen para el mapa.', 'warning');
      return;
    }

    try {
      await mapStorage.ensureStructure();
      const timestamp = Date.now();
      const extension = (file.name.split('.').pop() || 'png').toLowerCase();
      const safeExtension = extension.length <= 5 ? extension : 'png';
      const fileName = `map_${timestamp}.${safeExtension}`;
      let mapDir = mapStorage.mapImagesDir;
      if (!mapDir) {
        mapDir = await mapStorage.rootHandle.getDirectoryHandle('imagenes', { create: true });
        mapDir = await mapDir.getDirectoryHandle('mapas', { create: true });
        mapStorage.mapImagesDir = mapDir;
      }

      const fileHandle = await mapDir.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(file);
      await writable.close();

      const dimensions = await this.getImageDimensions(file);

      const mapRecord = {
        id: timestamp,
        name,
        imagePath: `${mapStorage.mapImagesPath.join('/')}/${fileName}`,
        width: dimensions.width,
        height: dimensions.height,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      const updatedMaps = [...(mapStorage.maps || []), mapRecord];
      await mapStorage.saveMaps(updatedMaps, { action: 'create', mapId: mapRecord.id, detail: mapRecord.name });

      this.closeModal();
      await this.loadData();
      await this.selectMap(mapRecord.id);
      this.showToast('Mapa creado correctamente.', 'success');
    } catch (error) {
      console.error('Error creando mapa:', error);
      this.showToast('No se pudo crear el mapa. Revisa la consola.', 'error');
    }
  },

  async getImageDimensions(file) {
    return new Promise((resolve) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
        URL.revokeObjectURL(url);
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        resolve({ width: 0, height: 0 });
      };
      img.src = url;
    });
  },

  // 🆕 EDITAR MAPA
  async openEditMapModal(mapId) {
    const numericId = typeof mapId === 'string' ? parseInt(mapId, 10) : mapId;
    const map = mapStorage.getMapById(numericId);
    
    if (!map) {
      this.showToast('Mapa no encontrado.', 'warning');
      return;
    }

    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) return;

    this.elements.modalTitle.textContent = 'Editar mapa';
    body.innerHTML = `
      <form id="mapEditForm" class="map-area-form">
        <div class="form-group">
          <label>Nombre del mapa</label>
          <input type="text" name="mapName" required placeholder="Ej: Planta principal" value="${this.escapeHtml(map.name)}" />
        </div>
        <div class="form-group">
          <label>Imagen del mapa (opcional - dejar vacío para mantener actual)</label>
          <input type="file" name="mapImage" accept="image/*" />
          <small style="color: var(--text-secondary); font-size: 0.75rem;">
            Imagen actual: ${map.width} × ${map.height}px
          </small>
        </div>
        <div class="form-actions">
          <button type="button" class="map-btn map-btn--ghost" data-action="cancel">Cancelar</button>
          <button type="submit" class="map-btn map-btn--primary">Guardar cambios</button>
        </div>
      </form>
    `;

    modal.classList.remove('hidden');

    const form = body.querySelector('#mapEditForm');
    const cancelBtn = body.querySelector('[data-action="cancel"]');

    if (cancelBtn) cancelBtn.addEventListener('click', () => this.closeModal());
    if (form) {
      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        await this.updateMapFromForm(numericId, formData);
      });
    }
  },

  // 🆕 ACTUALIZAR MAPA
  async updateMapFromForm(mapId, formData) {
    const name = (formData.get('mapName') || '').toString().trim();
    const file = formData.get('mapImage');
    
    if (!name) {
      this.showToast('Asigna un nombre al mapa.', 'warning');
      return;
    }

    const map = mapStorage.getMapById(mapId);
    if (!map) {
      this.showToast('Mapa no encontrado.', 'warning');
      return;
    }

    try {
      let updatedMap = { ...map, name, updatedAt: new Date().toISOString() };

      // Si hay nueva imagen, actualizar
      if (file && file instanceof File && file.size > 0) {
        await mapStorage.ensureStructure();
        const timestamp = Date.now();
        const extension = (file.name.split('.').pop() || 'png').toLowerCase();
        const safeExtension = extension.length <= 5 ? extension : 'png';
        const fileName = `map_${timestamp}.${safeExtension}`;
        
        let mapDir = mapStorage.mapImagesDir;
        if (!mapDir) {
          mapDir = await mapStorage.rootHandle.getDirectoryHandle('imagenes', { create: true });
          mapDir = await mapDir.getDirectoryHandle('mapas', { create: true });
          mapStorage.mapImagesDir = mapDir;
        }

        const fileHandle = await mapDir.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(file);
        await writable.close();

        const dimensions = await this.getImageDimensions(file);
        
        updatedMap.imagePath = `${mapStorage.mapImagesPath.join('/')}/${fileName}`;
        updatedMap.width = dimensions.width;
        updatedMap.height = dimensions.height;
      }

      const updatedMaps = mapStorage.maps.map(m => m.id === mapId ? updatedMap : m);
      await mapStorage.saveMaps(updatedMaps, { action: 'update', mapId, detail: name });

      this.closeModal();
      await this.loadData({ force: true });
      await this.selectMap(mapId);
      this.showToast('Mapa actualizado correctamente.', 'success');
    } catch (error) {
      console.error('Error actualizando mapa:', error);
      this.showToast('No se pudo actualizar el mapa. Revisa la consola.', 'error');
    }
  },

  // 🆕 ELIMINAR MAPA
  async deleteMap(mapId) {
    const numericId = typeof mapId === 'string' ? parseInt(mapId, 10) : mapId;
    const map = mapStorage.getMapById(numericId);
    
    if (!map) {
      this.showToast('Mapa no encontrado.', 'warning');
      return;
    }

    // Contar zonas asociadas
    const areasCount = (mapStorage.areas || []).filter(z => z.mapId === numericId).length;
    const confirmMessage = areasCount > 0
      ? `¿Eliminar "${map.name}"? Esto también eliminará ${areasCount} Ã¡rea(s) asociada(s). Esta acción no se puede deshacer.`
      : `¿Eliminar "${map.name}"? Esta acción no se puede deshacer.`;

    if (!confirm(confirmMessage)) {
      return;
    }

    try {
      // Eliminar Ã¡reas asociadas
      if (areasCount > 0) {
        const updatedAreas = (mapStorage.areas || []).filter(z => z.mapId !== numericId);
        await mapStorage.saveAreas(updatedAreas, { action: 'delete-cascade', mapId: numericId, detail: `${areasCount} Ã¡reas eliminadas` });
      }

      // Eliminar mapa
      const updatedMaps = (mapStorage.maps || []).filter(m => m.id !== numericId);
      await mapStorage.saveMaps(updatedMaps, { action: 'delete', mapId: numericId, detail: map.name });

      // Limpiar estado actual si era el mapa activo
      if (this.state.currentMapId === numericId) {
        this.state.currentMapId = null;
        this.state.currentMap = null;
        this.state.areas = [];
        this.cleanupImage();
      }

      await this.loadData({ force: true });
      this.showToast(`Mapa "${map.name}" eliminado correctamente.`, 'success');
    } catch (error) {
      console.error('Error eliminando mapa:', error);
      this.showToast('No se pudo eliminar el mapa. Revisa la consola.', 'error');
    }
  },

  async startEditAreaPoints(areaId) {
    console.log('🎨 Iniciando edición de Área:', areaId);
    
    // Convertir a número si es string
    const numericId = typeof areaId === 'string' ? parseInt(areaId, 10) : areaId;
    
    // Validar ID
    if (isNaN(numericId)) {
      console.error('❌ ID de Ã¡rea inválido:', areaId);
      this.showToast('Error: ID de Ã¡rea inválido.', 'error');
      return;
    }
    
    console.log('🔍 Buscando zona ID:', numericId, 'en:', this.state.areas.map(z => ({ id: z.id, name: z.name })));
    
    // Buscar zona
    const area = this.state.areas.find(z => z.id === numericId);
    if (!area || !area.points || area.points.length === 0) {
      console.error('❌ Ãrea no encontrada o sin puntos. Área:', area);
      this.showToast('No se puede editar esta Ã¡rea.', 'error');
      return;
    }

    console.log('✅ Ãrea encontrada:', area.name, 'con', area.points.length, 'puntos');

    // Cancelar modo de dibujo si estaba activo
    if (this.state.drawing) {
      this.cancelDrawing();
    }

    // Activar modo de edición
    this.state.editingAreaId = numericId;
    this.state.editingPoints = JSON.parse(JSON.stringify(area.points)); // Copia profunda
    this.state.selectedPointIndex = null;
    this.state.highlightAreaId = numericId;
    this.state.isDraggingPoint = false;

    console.log('🎯 Estado de edición configurado. Puntos editables:', this.state.editingPoints.length);

    // Actualizar UI
    this.elements.drawBtn?.classList.remove('map-btn--active');
    this.renderAreaList(this.state.areas);
    this.showEditPointButtons(area.name); // Mostrar botones
    this.draw();
    
    this.showToast(`✏️ Arrastra cualquier punto para ajustar la forma de "${area.name}"`, 'info', 4000);
  },

  showEditPointButtons(areaName) {
    // Crear contenedor de botones si no existe
    let buttonContainer = document.getElementById('editPointButtons');
    if (!buttonContainer) {
      buttonContainer = document.createElement('div');
      buttonContainer.id = 'editPointButtons';
      buttonContainer.style.cssText = `
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        display: flex;
        gap: 12px;
        padding: 16px 24px;
        background: rgba(15, 23, 42, 0.95);
        border: 2px solid #f59e0b;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
      `;
      document.body.appendChild(buttonContainer);
    }

    buttonContainer.innerHTML = `
      <div style="display: flex; align-items: center; gap: 12px; color: white; font-size: 0.9rem; font-weight: 500;">
        <span style="padding-right: 12px; border-right: 1px solid rgba(255, 255, 255, 0.2);">
          ✏️ Editando: ${this.escapeHtml(areaName)}
        </span>
        <button id="saveEditPoints" style="
          padding: 10px 20px;
          background: #22c55e;
          color: white;
          border: none;
          border-radius: 8px;
          font-weight: 600;
          font-size: 0.9rem;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
        " onmouseover="this.style.background='#16a34a'; this.style.transform='translateY(-2px)'" 
           onmouseout="this.style.background='#22c55e'; this.style.transform='translateY(0)'">
          💾 Guardar cambios
        </button>
        <button id="cancelEditPoints" style="
          padding: 10px 20px;
          background: #ef4444;
          color: white;
          border: none;
          border-radius: 8px;
          font-weight: 600;
          font-size: 0.9rem;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        " onmouseover="this.style.background='#dc2626'; this.style.transform='translateY(-2px)'" 
           onmouseout="this.style.background='#ef4444'; this.style.transform='translateY(0)'">
          ❌ Cancelar
        </button>
      </div>
    `;

    // Event listeners
    document.getElementById('saveEditPoints').addEventListener('click', () => {
      this.saveEditedAreaPoints();
    });

    document.getElementById('cancelEditPoints').addEventListener('click', () => {
      this.exitEditZonePoints();
      this.showToast('Edición cancelada', 'info');
    });
  },

  hideEditPointButtons() {
    const buttonContainer = document.getElementById('editPointButtons');
    if (buttonContainer) {
      buttonContainer.remove();
    }
  },

  exitEditZonePoints() {
    console.log('🚪 Saliendo del modo edición');
    this.hideEditPointButtons(); // Ocultar botones
    this.state.editingAreaId = null;
    this.state.editingPoints = [];
    this.state.selectedPointIndex = null;
    this.state.isDraggingPoint = false;
    this.elements.canvas.style.cursor = 'default';
    this.draw();
  },

  async saveEditedAreaPoints() {
    if (!this.state.editingAreaId || this.state.editingPoints.length === 0) {
      console.log('❌ No hay zona en edición o no hay puntos');
      return;
    }

    const numericId = this.state.editingAreaId;
    console.log('💾 Guardando zona ID:', numericId);
    console.log('📍 Puntos editados:', this.state.editingPoints.length);
    console.log(' Puntos:', JSON.stringify(this.state.editingPoints));
    
    // Recargar zonas desde storage para asegurar que tenemos la última versión
    if (!mapStorage.initialized) {
      console.error('❌ MapStorage no inicializado');
      this.showToast('Error: Sistema de almacenamiento no disponible.', 'error');
      return;
    }
    
    // Asegurarse de que mapStorage.areas está actualizado
    console.log('🗂️ Total Ã¡reas en mapStorage:', mapStorage.areas.length);
    console.log('🗂️ Zonas:', mapStorage.areas.map(z => ({ id: z.id, name: z.name })));
    
    const area = mapStorage.areas.find(z => z.id === numericId);
    
    if (!area) {
      console.error('❌ Ãrea no encontrada en storage. Buscando ID:', numericId);
      console.error('❌ IDs disponibles:', mapStorage.areas.map(z => z.id));
      this.showToast('Error: Ãrea no encontrada.', 'error');
      this.exitEditZonePoints();
      return;
    }

    console.log('✅ Ãrea encontrada:', area.name, 'Puntos originales:', area.points?.length);
    console.log('📍 mapId de la Área:', area.mapId);
    console.log('📍 currentMapId:', this.state.currentMapId);

    try {
      // Actualizar los puntos de la zona
      const updatedArea = {
        ...area,
        points: [...this.state.editingPoints], // Copia limpia
        updatedAt: new Date().toISOString()
      };

      console.log('🔄 Ãrea actualizada:', updatedArea.name, 'Nuevos puntos:', updatedArea.points.length);
      console.log('🔄 updatedArea.mapId:', updatedArea.mapId);

      // Actualizar en el array global
      mapStorage.areas = mapStorage.areas.map(z => z.id === numericId ? updatedArea : z);
      
      console.log('💾 Guardando en filesystem...');
      await mapStorage.saveAreas(mapStorage.areas, {
        action: 'update',
        mapId: this.state.currentMapId,
        areaId: numericId,
        detail: `Editados ${this.state.editingPoints.length} puntos de "${area.name}"`
      });
      console.log('✅ Guardado exitoso');

      // Recargar zonas del mapa actual
      console.log('🔍 Recargando zonas para mapId:', this.state.currentMapId);
      console.log('🔍 Zonas totales en storage:', mapStorage.areas.length);
      console.log('🔍 Detalle zonas:', mapStorage.areas.map(z => ({ id: z.id, name: z.name, mapId: z.mapId })));
      
      this.state.areas = mapStorage.getAreasByMap(this.state.currentMapId);
      console.log('📋 Zonas recargadas del mapa actual:', this.state.areas.length);
      
      this.exitEditZonePoints();
      this.renderAreaList(this.state.areas);
      this.draw();
      
      this.showToast(`✅ Forma de "${area.name}" actualizada correctamente.`, 'success');
    } catch (error) {
      console.error('❌ Error guardando puntos editados:', error);
      this.showToast('No se pudo guardar los cambios. Revisa la consola.', 'error');
    }
  },

  async openEditAreaMetadataModal(areaId) {
    console.log('🔧 openEditAreaMetadataModal llamado con areaId:', areaId);
    
    // Este método abre el modal para editar nombre, color, jerarquía, etc.
    const numericId = typeof areaId === 'string' ? parseInt(areaId, 10) : areaId;
    console.log('🔧 numericId:', numericId);
    
    // Buscar en las Ã¡reas del mapa actual
    const area = this.state.areas.find(z => z.id === numericId);
    if (!area) {
      console.error('❌ Ãrea no encontrada. ID buscado:', areaId, 'Zonas disponibles:', this.state.areas.map(z => ({ id: z.id, name: z.name })));
      this.showToast('No se encontró la zona especificada.', 'error');
      return;
    }

    console.log('✅ Ãrea encontrada:', area.name);

    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) {
      console.error('❌ Modal o body no encontrado. modal:', modal, 'body:', body);
      return;
    }

    console.log('✅ Elementos modal encontrados');

    this.elements.modalTitle.textContent = 'editar Ã¡rea';

    const jerarquia = area.jerarquia || {};
    const equiposText = Array.isArray(area.equipos) ? area.equipos.join('\n') : '';
    
    const appJerarquia = app?.opcionesJerarquia || {};
    const buildDatalist = (id, values) => {
      if (!Array.isArray(values) || !values.length) return '';
      return `<datalist id="${id}">${values.map(v => `<option value="${this.escapeHtml(v)}"></option>`).join('')}</datalist>`;
    };

    // 🗺️ Generar opciones de categorías dinámicamente desde mapController.categories
    const categoryOptions = Object.entries(this.categories).map(([key, cat]) => {
      const selected = (area.category || 'area') === key ? 'selected' : '';
      return `<option value="${key}" ${selected}>${cat.icon} ${cat.name} - ${cat.description}</option>`;
    }).join('');

    body.innerHTML = `
      <form id="editAreaForm" class="map-area-form">
        <div class="form-group">
          <label>Nombre del Ã¡rea</label>
          <input type="text" name="areaName" required placeholder="Ej: Planta Principal" value="${this.escapeHtml(area.name || '')}" />
        </div>
        
        <!-- 📂 NUEVO: Selector de categoría (dinámico) -->
        <div class="form-group" style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <span style="font-size: 1.1rem;">📂</span>
            <span>Categoría del área</span>
          </label>
          <select name="category" id="editCategorySelect" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.95rem;">
            ${categoryOptions}
          </select>
          <small style="display: block; margin-top: 8px; color: var(--text-muted); font-size: 0.8rem;">
            💡 La categoría determina el icono y color sugerido del área. <a href="#" onclick="event.preventDefault(); app.switchTab('configuracion'); app.closeModal();" style="color: var(--info); text-decoration: underline;">Gestionar categorías</a>
          </small>
        </div>
        
        <div class="form-row">
          <div class="form-group">
            <label>Color</label>
            <input type="color" name="areaColor" value="${area.color || '#3b82f6'}" />
          </div>
          <div class="form-group">
            <label>Opacidad</label>
            <input type="range" name="areaOpacity" min="10" max="90" value="${Math.round((area.opacity || 0.35) * 100)}" />
          </div>
        </div>
        
        <!-- 🎨 NUEVO: Controles para posicionar el nombre en el canvas -->
        <div class="form-group" style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <span style="font-size: 1.1rem;">📍</span>
            <span>Posición del nombre en el mapa</span>
          </label>
          <div class="form-row" style="gap: 12px;">
            <div class="form-group" style="flex: 1;">
              <label style="font-size: 0.85rem; color: var(--text-secondary);">Desplazar horizontalmente (X)</label>
              <input type="number" name="labelOffsetX" value="${area.labelOffsetX || 0}" step="10" placeholder="0" 
                     style="text-align: center;" title="Valores positivos mueven a la derecha, negativos a la izquierda" />
              <small style="color: var(--text-muted); font-size: 0.75rem;">← Izq (-)  |  Der (+) →</small>
            </div>
            <div class="form-group" style="flex: 1;">
              <label style="font-size: 0.85rem; color: var(--text-secondary);">Desplazar verticalmente (Y)</label>
              <input type="number" name="labelOffsetY" value="${area.labelOffsetY || 0}" step="10" placeholder="0" 
                     style="text-align: center;" title="Valores positivos mueven hacia abajo, negativos hacia arriba" />
              <small style="color: var(--text-muted); font-size: 0.75rem;">↑ Arriba (-)  |  Abajo (+) ↓</small>
            </div>
          </div>
          <small style="display: block; margin-top: 8px; color: var(--text-muted); font-size: 0.8rem;">
            💡 Usa estos valores para evitar que los nombres se monten unos sobre otros
          </small>
        </div>
        
        <div class="form-group">
          <label>Planta</label>
          <input type="text" name="planta" list="plantaList" placeholder="Ej: Planta Principal" value="${this.escapeHtml(jerarquia.planta || '')}" />
          ${buildDatalist('plantaList', appJerarquia.planta || [])}
        </div>
        <div class="form-group">
          <label>Area General</label>
          <input type="text" name="areaGeneral" list="areaGeneralList" placeholder="Ej: Filete" value="${this.escapeHtml(jerarquia.areaGeneral || '')}" />
          ${buildDatalist('areaGeneralList', appJerarquia.areaGeneral)}
        </div>
        <div class="form-group">
          <label>Sub-area</label>
          <input type="text" name="subArea" list="subAreaList" placeholder="Ej: Cinta Curva Filete" value="${this.escapeHtml(jerarquia.subArea || '')}" />
          ${buildDatalist('subAreaList', appJerarquia.subArea)}
        </div>
        <div class="form-group">
          <label>Sistema / Equipo</label>
          <input type="text" name="sistemaEquipo" list="sistemaEquipoList" placeholder="Ej: Grader Baader" value="${this.escapeHtml(jerarquia.sistemaEquipo || '')}" />
          ${buildDatalist('sistemaEquipoList', appJerarquia.sistemaEquipo)}
        </div>
        <div class="form-group">
          <label>Sub-sistema</label>
          <input type="text" name="subSistema" list="subSistemaList" placeholder="Ej: Motor Principal" value="${this.escapeHtml(jerarquia.subSistema || '')}" />
          ${buildDatalist('subSistemaList', appJerarquia.subSistema)}
        </div>
        <div class="form-group">
          <label>Seccion</label>
          <input type="text" name="seccion" list="seccionList" placeholder="Ej: Modulo 1" value="${this.escapeHtml(jerarquia.seccion || '')}" />
          ${buildDatalist('seccionList', appJerarquia.seccion)}
        </div>
        <div class="form-group">
          <label>Equipos / maquinas (uno por linea)</label>
          <textarea name="equipos" rows="4" placeholder="Ej:\nMotor principal\nBanda transportadora">${this.escapeHtml(equiposText)}</textarea>
        </div>
        <div class="form-actions">
          <button type="button" class="map-btn map-btn--ghost" id="cancelEditAreaBtn">Cancelar</button>
          <button type="submit" class="map-btn map-btn--primary">Guardar cambios</button>
        </div>
      </form>
    `;

    console.log('✅ HTML del formulario generado, mostrando modal...');
    
    modal.classList.remove('hidden');

    console.log('✅ Modal visible, agregando event listeners...');

    // 📂 NUEVO: Event listener para cambiar color al seleccionar categoría
    const categorySelect = document.getElementById('editCategorySelect');
    const colorInput = document.querySelector('input[name="areaColor"]');
    if (categorySelect && colorInput) {
      categorySelect.addEventListener('change', (e) => {
        const selectedCategory = e.target.value;
        const categoryData = this.categories[selectedCategory];
        if (categoryData && categoryData.color) {
          colorInput.value = categoryData.color;
        }
      });
    }

    // Event listener para cancelar
    const cancelBtn = document.getElementById('cancelEditAreaBtn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        this.closeModal();
      });
    }

    // Event listener para submit
    const form = document.getElementById('editAreaForm');
    if (form) {
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        await this.updateAreaFromForm(areaId, new FormData(e.target));
      });
    }
  },

  async updateAreaFromForm(areaId, formData) {
    try {
      // Convertir a número si es string
      const numericId = typeof areaId === 'string' ? parseInt(areaId, 10) : areaId;
      
      const name = formData.get('areaName')?.trim();
      if (!name) {
        this.showToast('El Nombre del Ã¡rea es obligatorio.', 'error');
        return;
      }

      const color = formData.get('areaColor') || '#3b82f6';
      const opacity = parseFloat(formData.get('areaOpacity')) / 100 || 0.35; // Convertir de 0-100 a 0-1
      
      // 📂 NUEVO: Obtener categoría seleccionada
      const category = (formData.get('category') || 'area').toString().trim();
      
      // 🏷️ NUEVO: Obtener offsets de posición del nombre
      const labelOffsetX = parseInt(formData.get('labelOffsetX'), 10) || 0;
      const labelOffsetY = parseInt(formData.get('labelOffsetY'), 10) || 0;
      
      // 🌳 Construir jerarquía con los nombres correctos
      const jerarquia = {};
      const planta = formData.get('planta')?.trim();
      const areaGeneral = formData.get('areaGeneral')?.trim();
      const subArea = formData.get('subArea')?.trim();
      const sistemaEquipo = formData.get('sistemaEquipo')?.trim();
      const subSistema = formData.get('subSistema')?.trim();
      const seccion = formData.get('seccion')?.trim();
      
      if (planta) jerarquia.planta = planta;
      if (areaGeneral) jerarquia.areaGeneral = areaGeneral;
      if (subArea) jerarquia.subArea = subArea;
      if (sistemaEquipo) jerarquia.sistemaEquipo = sistemaEquipo;
      if (subSistema) jerarquia.subSistema = subSistema;
      if (seccion) jerarquia.seccion = seccion;

      const equiposText = formData.get('equipos')?.trim() || '';
      const equipos = equiposText.split('\n').map(e => e.trim()).filter(Boolean);

      // Buscar la zona en el array global de mapStorage
      const area = mapStorage.areas.find(z => z.id === numericId);
      if (!area) {
        console.error('Ãrea no encontrada en mapStorage. ID buscado:', areaId, 'Zonas en mapStorage:', mapStorage.areas.map(z => ({ id: z.id, name: z.name })));
        this.showToast('No se encontró la zona especificada.', 'error');
        return;
      }

      const updatedArea = {
        ...area,
        name,
        color,
        opacity,
        category, // 📂 NUEVO: Categoría actualizada
        labelOffsetX, // 🏷️ NUEVO: Offset horizontal del nombre
        labelOffsetY, // 🏷️ NUEVO: Offset vertical del nombre
        jerarquia,
        equipos,
        updatedAt: new Date().toISOString()
      };

      // Actualizar en el array global
      mapStorage.areas = mapStorage.areas.map(z => z.id === numericId ? updatedArea : z);
      
      // Guardar con metadata para el log
      await mapStorage.saveAreas(mapStorage.areas, {
        action: 'update',
        mapId: this.state.currentMapId,
        areaId: numericId,
        detail: `Actualizada zona "${name}"`
      });

      // Recargar y actualizar UI
      this.state.areas = mapStorage.getAreasByMap(this.state.currentMapId);
      this.renderAreaList(this.state.areas);
      this.draw();
      this.closeModal();
      this.showToast(`✅ Zona "${name}" actualizada correctamente.`, 'success');
    } catch (error) {
      console.error('❌ Error actualizando Área:', error);
      this.showToast('No se pudo actualizar el Ã¡rea. Revisa la consola.', 'error');
    }
  },

  async deleteArea(areaId) {
    // Convertir a número si es string
    const numericId = typeof areaId === 'string' ? parseInt(areaId, 10) : areaId;
    
    // Validar que sea un número válido
    if (isNaN(numericId) || numericId === null || numericId === undefined) {
      console.error('ID de Ã¡rea inválido:', zoneId, 'tipo:', typeof areaId);
      this.showToast('Error: ID de Ã¡rea inválido.', 'error');
      return;
    }
    
    console.log('🗑️ Intentando Eliminar Ã¡rea con ID:', numericId);
    console.log('Zonas actuales en mapStorage:', mapStorage.areas.map(z => ({ id: z.id, name: z.name })));
    
    // Buscar en las Ã¡reas del mapa actual
    const area = this.state.areas.find(z => z.id === numericId);
    if (!area) {
      console.error('Ãrea no encontrada. ID buscado:', numericId, 'Zonas disponibles:', this.state.areas.map(z => ({ id: z.id, name: z.name })));
      this.showToast('No se encontró la zona especificada.', 'error');
      return;
    }

    const confirmed = confirm(`¿Eliminar la zona "${area.name}"?\n\nEsta acción no se puede deshacer.`);
    if (!confirmed) return;

    try {
      // Guardar cantidad antes de eliminar
      const beforeCount = mapStorage.areas.length;
      
      // Eliminar del array global usando el ID numérico
      mapStorage.areas = mapStorage.areas.filter(z => {
        const keep = z.id !== numericId;
        if (!keep) {
          console.log('🗑️ Eliminando Área:', z.id, z.name);
        }
        return keep;
      });
      
      const afterCount = mapStorage.areas.length;
      console.log(`Zonas antes: ${beforeCount}, después: ${afterCount}, eliminadas: ${beforeCount - afterCount}`);
      
      await mapStorage.saveAreas();

      // Recargar zonas del mapa actual
      this.state.areas = mapStorage.getAreasByMap(this.state.currentMapId);
      
      // Limpiar highlight si era esta Ã¡rea
      if (this.state.highlightAreaId === numericId) {
        this.state.highlightAreaId = null;
      }

      this.renderAreaList(this.state.areas);
      this.drawCanvas();
      this.showToast(`Zona "${area.name}" eliminada correctamente.`, 'success');
    } catch (error) {
      console.error('Error eliminando Área:', error);
      this.showToast('No se pudo eliminar el Ã¡rea. Revisa la consola.', 'error');
    }
  },

  async refreshLog() {
    const events = mapStorage.initialized ? await mapStorage.readLog(30) : [];
    this.renderLog(events);
  },

  renderLog(events) {
    const { logList } = this.elements;
    if (!logList) return;

    if (!Array.isArray(events) || !events.length) {
      logList.innerHTML = `<div style="color: var(--text-secondary); padding: 12px;">Sin eventos registrados.</div>`;
      return;
    }

    // Obtener filtros
    const filterAction = document.getElementById('mapLogFilterAction')?.value || 'all';
    const filterScope = document.getElementById('mapLogFilterScope')?.value || 'all';

    // Filtrar eventos
    const filteredEvents = events.filter(event => {
      const matchAction = filterAction === 'all' || event.action === filterAction;
      const matchScope = filterScope === 'all' || event.scope === filterScope;
      return matchAction && matchScope;
    });

    if (!filteredEvents.length) {
      logList.innerHTML = `<div style="color: var(--text-secondary); padding: 12px;">No hay eventos que coincidan con los filtros.</div>`;
      return;
    }

    logList.innerHTML = filteredEvents.map(event => {
      const timestamp = event.timestamp ? new Date(event.timestamp).toLocaleString('es-CL', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }) : '';
      
      const scope = event.scope || 'maps';
      const action = event.action || 'update';
      const detail = event.detail ? ` │ ${this.escapeHtml(event.detail)}` : '';
      
      // Color-coding por acción
      let actionColor = '#64748b'; // Gris por defecto
      let actionIcon = '🔄';
      let actionText = 'Actualizado';
      
      if (action === 'create') {
        actionColor = '#10b981'; // Verde
        actionIcon = '✅';
        actionText = 'Creado';
      } else if (action === 'update') {
        actionColor = '#3b82f6'; // Azul
        actionIcon = '🔄';
        actionText = 'Actualizado';
      } else if (action === 'delete') {
        actionColor = '#ef4444'; // Rojo
        actionIcon = '❌';
        actionText = 'Eliminado';
      }
      
      const scopeIcon = scope === 'maps' ? '🗺️' : '📍';
      const scopeText = scope === 'maps' ? 'Mapa' : 'Zona';
      
      // Agregar atributos para hacer clickable
      const clickable = event.mapId || event.zoneId;
      const cursorStyle = clickable ? 'cursor: pointer;' : '';
      const hoverStyle = clickable ? 'transition: all 0.2s; &:hover { background: rgba(59, 130, 246, 0.1); }' : '';
      
      return `
        <div class="map-log-entry" 
             data-map-id="${event.mapId || ''}" 
             data-area-id="${event.zoneId || ''}"
             style="padding: 10px 12px; border-left: 3px solid ${actionColor}; margin-bottom: 6px; border-radius: 4px; background: var(--surface-color); ${cursorStyle} ${hoverStyle}">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <time style="font-size: 0.75rem; color: var(--text-secondary);">${timestamp}</time>
            <span style="font-size: 0.75rem; padding: 2px 6px; border-radius: 3px; background: ${actionColor}20; color: ${actionColor}; font-weight: 500;">
              ${actionIcon} ${actionText}
            </span>
          </div>
          <div style="font-size: 0.85rem; color: var(--text-primary);">
            ${scopeIcon} <strong>${scopeText}</strong>${detail}
          </div>
        </div>
      `;
    }).join('');

    // Agregar event listeners para entradas clickables
    Array.from(logList.querySelectorAll('.map-log-entry')).forEach(entry => {
      const mapId = entry.getAttribute('data-map-id');
      const areaId = entry.getAttribute('data-area-id');
      
      if (mapId || areaId) {
        entry.addEventListener('click', () => {
          if (zoneId && mapId) {
            // Si tiene zoneId, ir a ese mapa y enfocar la zona
            this.selectMap(parseInt(mapId, 10));
            setTimeout(() => {
              this.focusArea(parseInt(zoneId, 10));
            }, 300);
          } else if (mapId) {
            // Solo mapId, ir al mapa
            this.selectMap(parseInt(mapId, 10));
          }
        });
      }
    });
  },

  showHistorialHelp() {
    const modal = this.elements.modal;
    const body = this.elements.modalBody;
    if (!modal || !body) return;

    this.elements.modalTitle.textContent = '❓ ¿Qué es el Historial?';

    body.innerHTML = `
      <div style="padding: 16px; line-height: 1.6;">
        <h3 style="margin: 0 0 16px 0; color: var(--text-primary); font-size: 1.1rem;">📋 Registro de actividades</h3>
        <p style="margin: 0 0 16px 0; color: var(--text-secondary);">
          El historial registra automáticamente todas las acciones que realizas en mapas y zonas, 
          creando un registro de auditoría completo con marca de tiempo.
        </p>

        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary); font-size: 0.95rem;">🎯 ¿Qué se registra?</h4>
        <ul style="margin: 0 0 16px 0; padding-left: 24px; color: var(--text-secondary);">
          <li style="margin-bottom: 6px;">✅ <strong style="color: #10b981;">Creación</strong>: Cuando creas un nuevo mapa o zona</li>
          <li style="margin-bottom: 6px;">🔄 <strong style="color: #3b82f6;">Actualización</strong>: Cuando editas datos o formas</li>
          <li style="margin-bottom: 6px;">❌ <strong style="color: #ef4444;">Eliminación</strong>: Cuando borras mapas o zonas</li>
        </ul>

        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary); font-size: 0.95rem;">🔍 Filtros disponibles</h4>
        <p style="margin: 0 0 8px 0; color: var(--text-secondary);">
          Usa los selectores para filtrar eventos por:
        </p>
        <ul style="margin: 0 0 16px 0; padding-left: 24px; color: var(--text-secondary);">
          <li style="margin-bottom: 6px;"><strong>Tipo de acción:</strong> Creadas, Actualizadas o Eliminadas</li>
          <li style="margin-bottom: 6px;"><strong>Ámbito:</strong> Solo Mapas o Solo Zonas</li>
        </ul>

        <h4 style="margin: 16px 0 8px 0; color: var(--text-primary); font-size: 0.95rem;">🖱️ Navegación rápida</h4>
        <p style="margin: 0 0 16px 0; color: var(--text-secondary);">
          Haz <strong>click en cualquier entrada</strong> del historial para saltar directamente al mapa o zona correspondiente.
        </p>

        <div style="margin-top: 24px; padding: 12px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid #3b82f6;">
          <p style="margin: 0; color: var(--text-primary); font-size: 0.85rem;">
            <strong>💡 Tip:</strong> El historial se guarda en archivo <code>mapas-history.log</code> dentro de la carpeta de logs para mantener un registro permanente.
          </p>
        </div>

        <div style="margin-top: 20px; display: flex; justify-content: flex-end;">
          <button type="button" id="closeHistorialHelpBtn" class="map-btn map-btn--primary">Entendido</button>
        </div>
      </div>
    `;

    modal.classList.remove('hidden');

    // Event listener para cerrar
    const closeBtn = document.getElementById('closeHistorialHelpBtn');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        this.closeModal();
      });
    }
  },

  showHint(text) {
    const hint = this.elements.hint;
    if (!hint) return;
    hint.textContent = text;
    hint.classList.remove('hidden');
  },

  hideHint() {
    const hint = this.elements.hint;
    if (!hint) return;
    hint.classList.add('hidden');
  },

  escapeHtml(text) {
    return text
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  },

  hexToRgba(hex, alpha = 0.35) {
    let normalized = hex.replace('#', '').trim();
    if (normalized.length === 3) {
      normalized = normalized.split('').map(char => char + char).join('');
    }
    const bigint = parseInt(normalized, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  },

  showToast(message, type = 'info') {
    if (typeof app?.showToast === 'function') {
      app.showToast(message, type);
    } else {
      console.log(`[${type}] ${message}`);
    }
  }
};

console.log('🗺️ MapController definido');

/* FIN MAP CONTROLLER */

// ============================================
// 🔽 SISTEMA DE ACORDEÓN PARA CONFIGURACIÓN
// ============================================
function toggleConfigSection(sectionId) {
  const content = document.getElementById(sectionId + '-content');
  const icon = document.getElementById(sectionId + '-icon');
  
  if (!content || !icon) return;
  
  const isCollapsed = content.style.display === 'none';
  
  if (isCollapsed) {
    content.style.display = 'block';
    icon.textContent = '▼';
  } else {
    content.style.display = 'none';
    icon.textContent = '▶';
  }
  
  // Guardar estado en localStorage
  localStorage.setItem('config-' + sectionId, isCollapsed ? 'open' : 'closed');
}

function initConfigSections() {
  // Lista de secciones con estado por defecto colapsado
  const sections = [
    'storage-config',
    'export-config',
    'backup-config',
    'jerarquia-config',
    'listas-config',
    'herramientas-config'
  ];
  
  sections.forEach(sectionId => {
    const content = document.getElementById(sectionId + '-content');
    const icon = document.getElementById(sectionId + '-icon');
    
    if (!content || !icon) return;
    
    // Leer estado guardado o usar 'closed' por defecto
    const savedState = localStorage.getItem('config-' + sectionId) || 'closed';
    
    if (savedState === 'closed') {
      content.style.display = 'none';
      icon.textContent = '▶';
    } else {
      content.style.display = 'block';
      icon.textContent = '▼';
    }
  });
}

class InventarioCompleto {
  constructor() {
    this.repuestos = [];
    this.conteoData = {};
    this.conteoActivo = false;
    this.currentView = 'cards';
    this.currentTab = 'inventario';
    this.mapTool = 'select';
    this.mapObjects = [];
    this.mapImage = null;
    this.currentMultimedia = [];
    this.currentDocuments = [];
    this.currentEditingId = null;
    this.currentPage = 1;
    this.itemsPerPage = 'auto'; // Modo automático responsive por defecto
    this.itemsPerPageManual = 21; // Valor manual cuando no es auto
    this.viewMode = localStorage.getItem('viewMode') || 'auto'; // 'auto', 'mobile', 'desktop'
    this.isEdge = this.detectEdge(); // Detectar si es Microsoft Edge
    this.isEdgeIOS = false; // Se setea en detectEdge() si es Edge iOS
    this.filteredRepuestos = [];
    this.showPrecio = false;
    this.autocompleteData = { codProv: [], tipo: [], area: [], equipo: [] };
    this.lightboxMedias = [];
    this.lightboxIndex = 0;
    this.canvas = null;
    this.ctx = null;
    this.listSortField = 'codSAP';
    this.listSortOrder = 'asc';
    this.columnWidths = ['50px', '0.9fr', '1.5fr', '160px', '220px'];
    
    // 🔄 CONTROL DE VERSIÓN DE UBICACIONES
    // true = usa renderUbicacionesCascada() (NUEVA versión con selects en cascada)
    // false = usa renderUbicaciones() (versión ORIGINAL con inputs + datalist)
    this.usarVersionCascada = true; // 👈 CAMBIAR A false PARA VOLVER A LA VERSIÓN ORIGINAL
    
    this.sistemaPorEquipo = {
      'Grader': [
        'Pocket 1', 'Pocket 2', 'Pocket 3', 'Pocket 4',
        'Cinta Z', 'Cinta Aceleración 1', 'Cinta Aceleración 2', 'Cinta Larga',
        'Sistema Hidráulico', 'Sistema Neumático', 'Panel Eléctrico Principal',
        'Tablero Control', 'Motor Principal', 'Otro'
      ],
      'Compresor': [
        'Motor Principal', 'Tanque Almacenamiento', 'Válvulas Control',
        'Sistema Refrigeración', 'Panel Control', 'Filtros Aire', 'Otro'
      ],
      'Bomba': [
        'Motor Eléctrico', 'Impulsor', 'Carcasa', 'Sellos Mecánicos',
        'Rodamientos', 'Base y Acople', 'Válvulas', 'Otro'
      ],
      'Transportador': [
        'Banda/Cadena', 'Motor Tracción', 'Rodillos', 'Tensor',
        'Estructura Soporte', 'Sistema Guías', 'Otro'
      ],
      'default': [
        'Motor', 'Transmisión', 'Sistema Eléctrico', 'Sistema Hidráulico',
        'Sistema Neumático', 'Estructura', 'Controles', 'Otro'
      ]
    };
    
    this.customSistemas = this.loadCustomSistemas();
    
    this.plantaBase = 'Aquachile Antarfood Chonchi';
    
    // ===============================================
    // 🆕 NUEVA ESTRUCTURA JERÁRQUICA ANIDADA
    // ===============================================
    // Estructura en árbol para jerarquía real
    this.jerarquiaAnidada = null; // Se carga desde localStorage o se inicializa
    this.loadJerarquiaAnidada(); // Cargar o crear estructura
    
    // ===============================================
    // 🧪 MÉTODO HELPER PARA ALTERNAR VERSIONES (DEBUG)
    // ===============================================
    window.toggleVersionUbicaciones = () => {
      this.usarVersionCascada = !this.usarVersionCascada;
      console.log(`🔄 Versión de ubicaciones cambiada a: ${this.usarVersionCascada ? 'CASCADA (nueva)' : 'ORIGINAL (inputs)'}`);
      
      // Re-renderizar si hay modal abierto
      const modal = document.getElementById('repuestoModal');
      if (modal && modal.classList.contains('show')) {
        if (this.usarVersionCascada) {
          this.renderUbicacionesCascada();
        } else {
          this.renderUbicaciones();
        }
        console.log('✅ Modal re-renderizado con nueva versión');
      }
    };
    
    // ===============================================
    // CONFIGURACIÓN DE ORGANIZACIÓN DE IMÁGENES
    // ===============================================
    this.nivelJerarquiaImagenes = parseInt(localStorage.getItem('nivelJerarquiaImagenes')) || 1;
    // 1 = Solo Área General
    // 2 = Área + Sistema/Equipo
    // 3 = Jerarquía Completa (Área > Subárea > Sistema)
    
    this.renombrarImagenesAutomaticamente = localStorage.getItem('renombrarImagenesAuto') !== 'false'; // true por defecto
    this.eliminarImagenAntiguaAlMover = localStorage.getItem('eliminarImagenAntigua') === 'true'; // false por defecto
    this.longitudMaximaNombreArchivo = 100; // Máximo caracteres para nombres de archivo
    
    // Opciones predefinidas por defecto (solo se usan si no hay nada guardado)
    this.opcionesJerarquiaPredefinidas = {
      'areaGeneral': [
        'Planta Principal',
        'Acopio',
        'Planta Yal',
        'Estanques Agua',
        'Estanque Inox',
        'Entretecho',
        'Bodega General',
        'Zona Externa',
        'Área de Mantención',
        'GENERAL'
      ],
      'subArea': [
        'Zona Norte',
        'Zona Sur',
        'Piso 1',
        'Piso 2',
        'Sector A',
        'Sector B',
        'Pasillo Central',
        'Línea 1',
        'Línea 2'
      ],
      'sistemaEquipo': [
        'Grader Marel',
        'Compresor Atlas Copco',
        'Cinta Transportadora 1',
        'Cinta Transportadora 2',
        'Bomba Principal',
        'Sistema Hidráulico',
        'Panel Eléctrico Central',
        'Grader',
        'Compresor 01',
        'Compresor 02'
      ],
      'subSistema': [
        'Motor Principal',
        'Sistema de Lubricación',
        'Tablero de Control',
        'Pocket 1',
        'Pocket 2',
        'Pocket 3',
        'Pocket 4',
        'Cinta Z',
        'Cinta Aceleración 1',
        'Cinta Aceleración 2',
        'Panel Eléctrico'
      ],
      'seccion': [
        'Panel Eléctrico',
        'Controles',
        'Sistema Hidráulico',
        'Sistema Neumático',
        'Zona de Corte',
        'Sistema de Refrigeración',
        'Válvulas Control'
      ]
      // Nota: 'detalle' no tiene opciones predefinidas porque es texto libre
    };
    
    // Cargar opciones desde localStorage (o inicializar con predefinidas)
    this.opcionesJerarquia = {};
    this.loadOpcionesPersonalizadas();
    
    this.jerarquiaNiveles = [
      { id: 'planta', nombre: 'Empresa', requerido: true, visible: true },
      { id: 'areaGeneral', nombre: 'Área General', requerido: true, visible: true },
      { id: 'subArea', nombre: 'Sub-Área', requerido: false, visible: false },
      { id: 'sistemaEquipo', nombre: 'Sistema/Equipo', requerido: false, visible: true },
      { id: 'subSistema', nombre: 'Sub-Sistema', requerido: false, visible: false },
      { id: 'seccion', nombre: 'Sección', requerido: false, visible: false },
      { id: 'detalle', nombre: 'Detalle/Ubicación', requerido: false, visible: false }
    ];
    
    this.isMobile = this.detectMobile();
    this.hasFileSystemAPI = this.checkFileSystemAPI();
    this.storageMode = this.hasFileSystemAPI ? 'filesystem' : 'indexeddb';
    
    // Referencia al FileSystemManager global
    this.fsManager = fsManager;
    console.log(`🔧 fsManager asignado:`, this.fsManager ? '✅ OK' : '❌ UNDEFINED');
    console.log(`🔧 fsManager.rootFolder:`, this.fsManager?.rootFolder ? '✅ OK' : '❌ NO CONECTADO');
    
    console.log(`📱 Dispositivo: ${this.isMobile ? 'Móvil' : 'PC'}`);
    console.log(`💾 Modo de almacenamiento: ${this.storageMode.toUpperCase()}`);
    console.log(`📁 File System API: ${this.hasFileSystemAPI ? '✅ Disponible' : '❌ No disponible'}`);
  }
  
  // NUEVO: Detectar si es dispositivo móvil
  detectMobile() {
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobileUA = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const isSmallScreen = window.innerWidth < 768;
    
    return isMobileUA || (isTouchDevice && isSmallScreen);
  }
  
  // NUEVO: Verificar disponibilidad de File System Access API
  checkFileSystemAPI() {
    return 'showDirectoryPicker' in window;
  }

  // Detectar si el navegador es Microsoft Edge
  detectEdge() {
    const userAgent = navigator.userAgent.toLowerCase();
    const isEdgeChromium = userAgent.includes('edg/'); // Edge Chromium (PC y móvil)
    const isEdgeLegacy = userAgent.includes('edge/'); // Edge Legacy (ya no se usa)
    const isIOS = /iphone|ipad|ipod/.test(userAgent);
    
    // ✅ ACEPTAR Edge iOS también (aunque use WebKit)
    // El usuario ya está usando Edge, no tiene sentido pedirle que lo descargue
    if (isEdgeChromium && isIOS) {
      console.log('📱 Edge en iOS detectado - Modo móvil con IndexedDB');
      this.isEdgeIOS = true; // Flag especial para Edge iOS
      return true; // ✅ SÍ es Edge (aunque limitado)
    }
    
    this.isEdgeIOS = false;
    return isEdgeChromium || isEdgeLegacy;
  }

  // Mostrar advertencia si no es Edge
  showBrowserWarning() {
    // PRIORIDAD 1: Mostrar banner de móvil simplificado si no hay FileSystem
    if (this.isMobile && !this.hasFileSystemAPI) {
      console.log('📱 Modo Móvil Simplificado detectado');
      this.showMobileSimplifiedBanner();
      return;
    }
    
    if (this.isEdge) {
      // Si es Edge iOS, mostrar mensaje informativo suave
      if (this.isEdgeIOS) {
        console.log('📱 Microsoft Edge iOS detectado - Modo móvil activo');
        this.showEdgeIOSInfo();
        return;
      }
      
      console.log('✅ Microsoft Edge detectado - Experiencia optimizada');
      return;
    }

    const browserName = this.getBrowserName();
    const userAgent = navigator.userAgent.toLowerCase();
    const isIOS = /iphone|ipad|ipod/.test(userAgent);
    const isEdgeIOS = userAgent.includes('edg/') && isIOS;
    const isMobile = this.isMobile;
    const storageMode = this.storageMode;
    
    console.warn('⚠️ Navegador no optimizado:', browserName);

    // Mensaje específico según plataforma y navegador
    let warningMessage = '';
    
    if (isEdgeIOS) {
      warningMessage = 'Edge en iOS usa WebKit (motor de Safari) por restricciones de Apple. La app funciona en <strong>modo móvil con IndexedDB</strong> (límite ~50-100MB). Para almacenamiento ilimitado, usa Edge en <strong>Windows</strong> o <strong>Android</strong>.';
    } else if (isMobile && storageMode === 'indexeddb') {
      warningMessage = 'Estás usando <strong>modo móvil con IndexedDB</strong> (límite ~50-100MB para imágenes). Para almacenamiento ilimitado con File System API, usa <strong>Microsoft Edge en Windows/Android</strong>.';
    } else {
      warningMessage = 'Esta aplicación está optimizada exclusivamente para <strong>Microsoft Edge</strong> en <strong>Windows</strong> y <strong>Android</strong>. Algunas funciones pueden no funcionar correctamente.';
    }

    // Crear banner de advertencia
    const banner = document.createElement('div');
    banner.id = 'browser-warning-banner';
    banner.innerHTML = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 99999;
        background: linear-gradient(135deg, var(--danger), #b91c1c);
        color: white;
        padding: 16px 20px;
        box-shadow: var(--shadow-lg);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        animation: slideDown 0.5s ease-out;
        flex-wrap: wrap;
      ">
        <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 250px;">
          <span style="font-size: 2rem;">⚠️</span>
          <div>
            <div style="font-weight: 700; font-size: 1rem; margin-bottom: 4px;">
              Navegador No Optimizado: ${browserName}
            </div>
            <div style="font-size: 0.85rem; opacity: 0.95; line-height: 1.4;">
              ${warningMessage}
            </div>
          </div>
        </div>
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
          <a href="https://www.microsoft.com/edge" target="_blank" 
             style="
               padding: 10px 20px;
               background: var(--primary);
               color: white;
               border-radius: 6px;
               text-decoration: none;
               font-weight: 600;
               white-space: nowrap;
               box-shadow: var(--shadow-md);
               transition: all 0.3s ease;
             "
             onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='var(--shadow-lg)'"
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='var(--shadow-md)'">
            🌐 Descargar Edge
          </a>
          <button onclick="document.getElementById('browser-warning-banner').style.display='none'" 
                  style="
                    padding: 10px 16px;
                    background: rgba(255,255,255,0.2);
                    color: white;
                    border: 1px solid rgba(255,255,255,0.4);
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 600;
                    white-space: nowrap;
                    transition: all 0.2s ease;
                  "
                  onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                  onmouseout="this.style.background='rgba(255,255,255,0.2)'">
            ✕ Cerrar
          </button>
        </div>
      </div>
      <style>
        @keyframes slideDown {
          from {
            transform: translateY(-100%);
            opacity: 0;
          }
          to {
            transform: translateY(0);
            opacity: 1;
          }
        }
        @media (max-width: 768px) {
          #browser-warning-banner > div {
            flex-direction: column !important;
            text-align: center;
          }
          #browser-warning-banner a,
          #browser-warning-banner button {
            width: 100%;
          }
        }
      </style>
    `;

    document.body.insertBefore(banner, document.body.firstChild);

    // Ajustar padding del body para que no se solape el contenido
    document.body.style.paddingTop = '120px';
  }
  
  // Mostrar info amigable para Edge iOS (sin alarmar al usuario)
  showEdgeIOSInfo() {
    // Crear banner informativo SUAVE (azul, no rojo)
    const banner = document.createElement('div');
    banner.id = 'edge-ios-info-banner';
    banner.innerHTML = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 99999;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
        color: white;
        padding: 12px 16px;
        box-shadow: var(--shadow-lg);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        animation: slideDown 0.5s ease-out;
        font-size: 0.9rem;
      ">
        <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
          <span style="font-size: 1.5rem;">📱</span>
          <div>
            <strong>Edge Móvil Detectado</strong> • 
            📷 Cámara + 🖼️ Galería/iCloud disponibles
          </div>
        </div>
        <button onclick="document.getElementById('edge-ios-info-banner').style.display='none'" 
                style="
                  padding: 6px 12px;
                  background: rgba(255,255,255,0.2);
                  color: white;
                  border: 1px solid rgba(255,255,255,0.3);
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 0.85rem;
                  font-weight: 600;
                "
                onmouseover="this.style.background='rgba(255,255,255,0.3)'"
                onmouseout="this.style.background='rgba(255,255,255,0.2)'">
          ✓ Entendido
        </button>
      </div>
      <style>
        @keyframes slideDown {
          from { transform: translateY(-100%); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
        @media (max-width: 768px) {
          #edge-ios-info-banner > div {
            font-size: 0.85rem;
          }
        }
      </style>
    `;

    document.body.insertBefore(banner, document.body.firstChild);
    
    // Auto-cerrar después de 5 segundos
    setTimeout(() => {
      const bannerEl = document.getElementById('edge-ios-info-banner');
      if (bannerEl) {
        bannerEl.style.transition = 'opacity 0.5s ease-out';
        bannerEl.style.opacity = '0';
        setTimeout(() => bannerEl.remove(), 500);
      }
    }, 5000);
  }

  // Mostrar banner de modo móvil simplificado (sin FileSystem)
  showMobileSimplifiedBanner() {
    const banner = document.createElement('div');
    banner.id = 'mobile-simplified-banner';
    banner.innerHTML = `
      <div style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 99999;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.95), rgba(124, 58, 237, 0.95));
        color: white;
        padding: 14px 16px;
        box-shadow: var(--shadow-lg);
        animation: slideDown 0.5s ease-out;
        font-size: 0.85rem;
      ">
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px;">
            <div style="display: flex; align-items: center; gap: 10px; flex: 1;">
              <span style="font-size: 1.8rem;">📱</span>
              <div>
                <strong style="font-size: 1rem; display: block; margin-bottom: 3px;">
                  Modo Móvil Simplificado
                </strong>
                <span style="opacity: 0.95; font-size: 0.8rem;">
                  Solo datos • Sin fotos
                </span>
              </div>
            </div>
            <button onclick="document.getElementById('mobile-simplified-banner').style.display='none'" 
                    style="
                      padding: 6px 12px;
                      background: rgba(255,255,255,0.2);
                      color: white;
                      border: 1px solid rgba(255,255,255,0.3);
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 0.8rem;
                      font-weight: 600;
                      white-space: nowrap;
                    ">
              ✓ Entendido
            </button>
          </div>
          
          <div style="
            background: rgba(255,255,255,0.15);
            padding: 10px 12px;
            border-radius: 6px;
            line-height: 1.5;
            font-size: 0.8rem;
          ">
            <strong style="display: block; margin-bottom: 6px;">✅ Funciones activas:</strong>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 0.75rem;">
              <span>• Ver inventario</span>
              <span>• Conteo rápido</span>
              <span>• Agregar repuestos</span>
              <span>• Buscar/Filtrar</span>
              <span>• Editar datos</span>
              <span>• Eliminar items</span>
            </div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 0.75rem;">
              💡 <strong>Para fotos:</strong> Usa la versión de PC
            </div>
          </div>
        </div>
      </div>
      <style>
        @keyframes slideDown {
          from { transform: translateY(-100%); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
      </style>
    `;
    
    document.body.insertBefore(banner, document.body.firstChild);
    
    // Auto-cerrar después de 8 segundos (más tiempo para leer todo)
    setTimeout(() => {
      const bannerEl = document.getElementById('mobile-simplified-banner');
      if (bannerEl) {
        bannerEl.style.transition = 'opacity 0.5s ease-out';
        bannerEl.style.opacity = '0';
        setTimeout(() => bannerEl.remove(), 500);
      }
    }, 8000);
    
    console.log('📱 Banner de Modo Móvil Simplificado mostrado');
  }

  // Obtener nombre del navegador actual
  getBrowserName() {
    const userAgent = navigator.userAgent.toLowerCase();
    
    if (userAgent.includes('firefox')) return 'Mozilla Firefox';
    if (userAgent.includes('chrome') && !userAgent.includes('edg')) return 'Google Chrome';
    if (userAgent.includes('safari') && !userAgent.includes('chrome')) return 'Safari';
    if (userAgent.includes('opera') || userAgent.includes('opr')) return 'Opera';
    
    return 'Navegador Desconocido';
  }

  // Helper para obtener URL de imagen (soporta base64 Y rutas externas)
  async getImageUrl(media) {
    if (!media) return null;
    
    // ===================================================================
    // MANEJO UNIVERSAL DE IMÁGENES (FileSystem, IndexedDB, base64)
    // ===================================================================
    
    // Si es un string simple
    if (typeof media === 'string') {
      // Base64 inline → Retornar directamente
      if (media.startsWith('data:image')) {
        return media;
      }
      // ID de IndexedDB (img_timestamp_filename)
      if (media.startsWith('img_') && this.storageMode === 'indexeddb') {
        return await this.loadImageFromFileSystem(media);
      }
      // Ruta de FileSystem (./imagenes/...)
      if (media.startsWith('./imagenes/') || media.startsWith('imagenes/')) {
        return await this.loadImageFromFileSystem(media);
      }
      // Ruta relativa o absoluta
      return media;
    }
    
    // Si es objeto con flag de IndexedDB
    if (media.type === 'image' && media.url) {
      if (media.isIndexedDB && media.url.startsWith('img_')) {
        return await this.loadImageFromFileSystem(media.url);
      }
      // Si es objeto con flag de FileSystem
      if (media.isFileSystem && (media.url.startsWith('./imagenes/') || media.url.startsWith('imagenes/'))) {
        return await this.loadImageFromFileSystem(media.url);
      }
      // Base64 u otro formato
      return media.url;
    }
    
    // Si es objeto con estructura {tipo: 'imagen', url: '...'}
    if (media.tipo === 'imagen' && media.url) {
      // ✅ SOPORTE PARA ARCHIVOS EXTERNOS
      if (media.esArchivoExterno) {
        return media.url;
      }
      // Base64 o URL normal
      return media.url;
    }
    
    return null;
  }

  async loadImageFromFileSystem(path) {
    // ===================================================================
    // CARGA UNIVERSAL DE IMÁGENES (FileSystem, IndexedDB o base64)
    // ===================================================================
    
    console.log(`🔍 [DEBUG] loadImageFromFileSystem llamado con:`, path);
    console.log(`   storageMode: ${this.storageMode}`);
    console.log(`   fsManager.isFileSystemMode: ${fsManager.isFileSystemMode}`);
    console.log(`   fsManager.imagesFolder:`, fsManager.imagesFolder ? 'EXISTE ✅' : 'NO EXISTE ❌');
    
    // CASO 1: Base64 inline (LocalStorage mode) - Retornar directamente
    if (path.startsWith('data:image')) {
      console.log(`✅ [DEBUG] Base64 detectado, retornando directamente`);
      return path;
    }
    
    // CASO 2: IndexedDB ID (Mobile mode)
    if (path.startsWith('img_') && this.storageMode === 'indexeddb') {
      console.log(`🔍 [DEBUG] Intentando cargar desde IndexedDB...`);
      try {
        const imageData = await indexedDBManager.getImage(path);
        if (imageData && imageData.url) {
          console.log(`✅ IndexedDB: ${path} cargada`);
          return imageData.url;
        }
      } catch (error) {
        console.error(`❌ Error cargando desde IndexedDB: ${path}`, error);
        return null;
      }
    }
    
    // CASO 3: FileSystem path (PC mode con Edge)
    if (!fsManager.isFileSystemMode || !fsManager.imagesFolder) {
      console.error('❌ [DEBUG] NO SE PUEDE CARGAR - Modo FileSystem no está activo');
      console.error('   isFileSystemMode:', fsManager.isFileSystemMode);
      console.error('   imagesFolder:', fsManager.imagesFolder);
      console.error('   Ruta solicitada:', path);
      console.error('⚠️ SOLUCIÓN: Haz clic en "Almacenamiento Ilimitado" para activar FileSystem');
      return null;
    }

    try {
      // SIMPLIFICADO: Todas las imágenes están en carpeta raíz INVENTARIO_STORAGE/imagenes/
      // Extraer solo el nombre del archivo (sin subcarpetas)
      let filename = path.replace('./', '').replace(/^imagenes\//, '');
      
      // Si tiene subcarpetas en el path (modo legacy), extraer solo el nombre final
      if (filename.includes('/')) {
        const parts = filename.split('/');
        filename = parts[parts.length - 1];
      }
      
      console.log(`🔍 Cargando imagen desde FileSystem (carpeta plana): ${filename}`);
      
      // Usar caché global con referencias fuertes (previene Garbage Collection)
      return await getCachedBlobUrl(filename, async () => {
        // Cargar directamente desde carpeta raíz imagenes/
        const fileHandle = await fsManager.imagesFolder.getFileHandle(filename);
        const file = await fileHandle.getFile();
        
        // Crear Blob URL permanente
        const blobUrl = URL.createObjectURL(file);
        
        console.log(`✅ Imagen cargada: ${filename} (${file.size} bytes)`);
        return blobUrl;
      });
    } catch (error) {
      // Error silencioso - retornará placeholder automáticamente
      console.debug(`⚠️ Imagen no encontrada: ${path.split('/').pop()}`);
      return null;
    }
  }

  // Obtener primera imagen de multimedia array
  // Imagen placeholder SVG para repuestos sin foto
  getPlaceholderImage() {
    // Placeholder simple en PNG base64 (200x150 gris con texto)
    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACWCAYAAACb3McZAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR4nO3dy0pDQRRF0ZOI///L4sPIQNAY86h0n7X2gDvJoKu7TqeqngEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP/q9cV7AK7w+uXlbYwxvr5/f/sewKV+hOPx+Ph8fHwc3wW40I9wjDHG4/Fx8R7Ahb6F4/n5+eE9gAt9C8cY4+49gAt9D8er9wAu9CMcz+N1eA/gQj/CMcZr8x7AhSYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgFv6AyRmU3vlastLAAAAAElFTkSuQmCC';
  }

  async getFirstImage(multimedia) {
    if (!multimedia || !Array.isArray(multimedia) || multimedia.length === 0) {
      return this.getPlaceholderImage();
    }
    
    for (const media of multimedia) {
      const url = await this.getImageUrl(media);
      if (url) return url;
    }
    
    return this.getPlaceholderImage();
  }

  loadCustomSistemas() {
    try {
      const stored = localStorage.getItem('inventarioCustomSistemas');
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      console.error('❌ Error cargando sistemas personalizados:', error);
      return {};
    }
  }
  
  saveCustomSistemas() {
    try {
      localStorage.setItem('inventarioCustomSistemas', JSON.stringify(this.customSistemas));
      console.log('✅ Sistemas personalizados guardados:', this.customSistemas);
    } catch (error) {
      console.error('❌ Error guardando sistemas personalizados:', error);
      this.showAlert('Error al guardar sistemas personalizados', 'error');
    }
  }
  
  addCustomSistema(equipo, sistema) {
    if (!equipo || !sistema || sistema.trim() === '') return;
    
    if (!this.customSistemas[equipo]) {
      this.customSistemas[equipo] = [];
    }
    
    const sistemaTrimmed = sistema.trim();
    const predefinidos = this.sistemaPorEquipo[equipo] || this.sistemaPorEquipo['default'];
    
    if (predefinidos.includes(sistemaTrimmed) || this.customSistemas[equipo].includes(sistemaTrimmed)) {
      return false;
    }
    
    this.customSistemas[equipo].push(sistemaTrimmed);
    this.saveCustomSistemas();
    console.log(`✅ Sistema personalizado agregado: ${sistemaTrimmed} (${equipo})`);
    return true;
  }
  
  deleteCustomSistema(equipo, sistema) {
    if (!this.customSistemas[equipo]) return false;
    
    const index = this.customSistemas[equipo].indexOf(sistema);
    if (index > -1) {
      this.customSistemas[equipo].splice(index, 1);
      
      if (this.customSistemas[equipo].length === 0) {
        delete this.customSistemas[equipo];
      }
      
      this.saveCustomSistemas();
      console.log(`✅ Sistema personalizado eliminado: ${sistema} (${equipo})`);
      return true;
    }
    return false;
  }
  
  editCustomSistema(equipo, oldSistema, newSistema) {
    if (!this.customSistemas[equipo] || !newSistema || newSistema.trim() === '') return false;
    
    const index = this.customSistemas[equipo].indexOf(oldSistema);
    if (index > -1) {
      const newSistemaTrimmed = newSistema.trim();
      
      const predefinidos = this.sistemaPorEquipo[equipo] || this.sistemaPorEquipo['default'];
      if (predefinidos.includes(newSistemaTrimmed) || this.customSistemas[equipo].includes(newSistemaTrimmed)) {
        this.showAlert('Este sistema ya existe', 'warning');
        return false;
      }
      
      this.customSistemas[equipo][index] = newSistemaTrimmed;
      this.saveCustomSistemas();
      console.log(`✅ Sistema personalizado editado: ${oldSistema} → ${newSistemaTrimmed} (${equipo})`);
      return true;
    }
    return false;
  }
  
  // ============================================
  // GESTIÓN DE OPCIONES PERSONALIZADAS DE JERARQUÍA
  // ============================================
  
  loadOpcionesPersonalizadas() {
    try {
      const stored = localStorage.getItem('inventarioOpcionesJerarquia');
      if (stored) {
        // Si existe en localStorage, usar ESO (respeta eliminaciones)
        this.opcionesJerarquia = JSON.parse(stored);
        console.log('✅ Opciones cargadas desde localStorage');
      } else {
        // Primera vez: usar valores predefinidos y guardarlos
        this.opcionesJerarquia = JSON.parse(JSON.stringify(this.opcionesJerarquiaPredefinidas));
        this.saveOpcionesPersonalizadas();
        console.log('✅ Opciones inicializadas con valores predefinidos');
      }
    } catch (error) {
      console.error('❌ Error cargando opciones personalizadas:', error);
      // En caso de error, usar predefinidas
      this.opcionesJerarquia = JSON.parse(JSON.stringify(this.opcionesJerarquiaPredefinidas));
    }
  }
  
  saveOpcionesPersonalizadas() {
    try {
      // Guardar todas las opciones actuales
      const toSave = {};
      Object.keys(this.opcionesJerarquia).forEach(nivel => {
        toSave[nivel] = [...this.opcionesJerarquia[nivel]];
      });
      localStorage.setItem('inventarioOpcionesJerarquia', JSON.stringify(toSave));
      console.log('✅ Opciones personalizadas guardadas');
    } catch (error) {
      console.error('❌ Error guardando opciones personalizadas:', error);
    }
  }
  
  // 🆕 NUEVA FUNCIÓN: Cargar/Inicializar Jerarquía Anidada
  loadJerarquiaAnidada() {
    try {
      const stored = localStorage.getItem('inventarioJerarquiaAnidada');
      if (stored) {
        this.jerarquiaAnidada = JSON.parse(stored);
        
        // 🔄 MIGRACIÓN: Si tiene "plantas", renombrar a "areas"
        if (this.jerarquiaAnidada.plantas && !this.jerarquiaAnidada.areas) {
          console.log('🔄 Migrando "plantas" → "areas"');
          this.jerarquiaAnidada.areas = this.jerarquiaAnidada.plantas;
          delete this.jerarquiaAnidada.plantas;
          this.saveJerarquiaAnidada();
        }
        
        console.log('✅ Jerarquía anidada cargada desde localStorage');
      } else {
        // Primera vez: crear estructura base
        this.jerarquiaAnidada = this.crearEstructuraJerarquicaBase();
        this.saveJerarquiaAnidada();
        console.log('✅ Jerarquía anidada inicializada con estructura base');
      }
    } catch (error) {
      console.error('❌ Error cargando jerarquía anidada:', error);
      this.jerarquiaAnidada = this.crearEstructuraJerarquicaBase();
    }
  }
  
  // 🆕 NUEVA FUNCIÓN: Crear estructura base
  crearEstructuraJerarquicaBase() {
    return {
      empresa: {
        nombre: 'Aquachile Antarfood Chonchi',
        id: 'empresa_principal'
      },
      areas: [
        {
          id: 'area_planta_principal',
          nombre: 'Planta Principal',
          subAreas: [
            {
              id: 'eviscerado',
              nombre: 'Eviscerado',
              sistemas: [
                {
                  id: 'grader',
                  nombre: 'Grader',
                  subSistemas: [
                    {
                      id: 'cinta_larga_grader',
                      nombre: 'Cinta Larga Grader',
                      secciones: [
                        {
                          id: 'sistema_electrico',
                          nombre: 'Sistema Eléctrico',
                          subSecciones: [
                            {
                              id: 'panel_control',
                              nombre: 'Panel de Control'
                            },
                            {
                              id: 'cableado',
                              nombre: 'Cableado'
                            }
                          ]
                        },
                        {
                          id: 'sistema_mecanico',
                          nombre: 'Sistema Mecánico',
                          subSecciones: [
                            {
                              id: 'rodamientos',
                              nombre: 'Rodamientos'
                            },
                            {
                              id: 'correa',
                              nombre: 'Correa'
                            }
                          ]
                        }
                      ]
                    },
                    {
                      id: 'motor_principal',
                      nombre: 'Motor Principal',
                      secciones: [
                        {
                          id: 'alimentacion_electrica',
                          nombre: 'Alimentación Eléctrica',
                          subSecciones: []
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              id: 'filete',
              nombre: 'Filete',
              sistemas: []
            }
          ]
        },
        {
          id: 'acopio',
          nombre: 'Acopio',
          subAreas: []
        }
      ]
    };
  }
  
  // 🆕 NUEVA FUNCIÓN: Guardar jerarquía anidada
  saveJerarquiaAnidada() {
    try {
      localStorage.setItem('inventarioJerarquiaAnidada', JSON.stringify(this.jerarquiaAnidada));
      console.log('✅ Jerarquía anidada guardada');
    } catch (error) {
      console.error('❌ Error guardando jerarquía anidada:', error);
    }
  }
  
  aprenderNuevaOpcion(nivel, valor) {
    if (!nivel || !valor || valor.trim() === '') return false;
    if (!this.opcionesJerarquia[nivel]) return false;
    
    const valorTrimmed = valor.trim();
    
    // Si ya existe, no hacer nada
    if (this.opcionesJerarquia[nivel].includes(valorTrimmed)) {
      return false;
    }
    
    // Agregar nueva opción
    this.opcionesJerarquia[nivel].push(valorTrimmed);
    this.saveOpcionesPersonalizadas();
    console.log(`✅ Nueva opción aprendida: ${valorTrimmed} en ${nivel}`);
    
    // 🔄 SINCRONIZACIÓN: Si la pestaña de configuración está visible, actualizar UI en tiempo real
    if (this.currentTab === 'configuracion') {
      this.renderListasGestion();
      console.log(`🔄 UI de configuración actualizada automáticamente`);
    }
    
    return true;
  }
  
  eliminarOpcionJerarquia(nivel, valor) {
    if (!this.opcionesJerarquia[nivel]) return false;
    
    const index = this.opcionesJerarquia[nivel].indexOf(valor);
    if (index > -1) {
      this.opcionesJerarquia[nivel].splice(index, 1);
      this.saveOpcionesPersonalizadas();
      
      // Limpiar esta opción de todos los repuestos que la usen
      this.limpiarOpcionDeRepuestos(nivel, valor);
      
      console.log(`✅ Opción eliminada: ${valor} de ${nivel}`);
      return true;
    }
    return false;
  }
  
  limpiarOpcionDeRepuestos(nivel, valor) {
    let modificados = 0;
    
    this.repuestos.forEach(repuesto => {
      if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
        repuesto.ubicaciones.forEach(ubicacion => {
          if (ubicacion[nivel] === valor) {
            ubicacion[nivel] = '';
            modificados++;
          }
        });
      }
    });
    
    if (modificados > 0) {
      this.guardarDatos();
      console.log(`✅ Limpiado "${valor}" de ${modificados} ubicación(es)`);
      this.showAlert(`Se eliminó "${valor}" de ${modificados} ubicación(es)`, 'success');
    }
  }
  
  agregarOpcionJerarquia(nivel, valor) {
    if (!nivel || !valor || valor.trim() === '') {
      this.showToast('❌ Debes ingresar un valor', 'warning');
      return false;
    }
    
    // Inicializar array si no existe
    if (!this.opcionesJerarquia[nivel]) {
      this.opcionesJerarquia[nivel] = [];
    }
    
    const valorTrimmed = valor.trim();
    
    if (this.opcionesJerarquia[nivel].includes(valorTrimmed)) {
      this.showToast('⚠️ Esta opción ya existe', 'warning');
      return false;
    }
    
    this.opcionesJerarquia[nivel].push(valorTrimmed);
    this.opcionesJerarquia[nivel].sort();
    this.saveOpcionesPersonalizadas();
    console.log(`✅ Opción agregada: ${valorTrimmed} a ${nivel}`);
    this.showToast(`✅ "${valorTrimmed}" agregado correctamente`, 'success');
    return true;
  }


  toggleNivelesConfig() {
    const panel = document.getElementById('nivelesConfigPanel');
    if (panel.style.display === 'none') {
      panel.style.display = 'block';
      this.renderNivelesConfig();
    } else {
      panel.style.display = 'none';
    }
  }

  renderNivelesConfig() {
    const container = document.getElementById('nivelesCheckboxes');
    if (!container) return;
    
    let html = '';
    this.jerarquiaNiveles.forEach((nivel, index) => {
      if (nivel.id === 'planta' || nivel.id === 'areaGeneral') return;
      
      html += `
        <label style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-primary); border-radius: 6px; cursor: pointer; border: 2px solid ${nivel.visible ? 'var(--success)' : 'var(--border-color)'};">
          <input type="checkbox" 
                 ${nivel.visible ? 'checked' : ''}
                 onchange="app.toggleNivelVisibilidad('${nivel.id}', this.checked)"
                 style="cursor: pointer;">
          <span style="font-weight: 600; font-size: 0.85rem;">${index + 1}. ${nivel.nombre}</span>
        </label>
      `;
    });
    
    container.innerHTML = html;
  }

  toggleNivelVisibilidad(nivelId, visible) {
    const nivel = this.jerarquiaNiveles.find(n => n.id === nivelId);
    if (nivel) {
      nivel.visible = visible;
      this.renderNivelesDinamicos();
      this.updateJerarquiaPreview();
    }
  }

  renderNivelesDinamicos() {
    const container = document.getElementById('nivelesDinamicosContainer');
    if (!container) return;
    
    let html = '';
    let numeroNivel = 3;
    
    this.jerarquiaNiveles.forEach(nivel => {
      if (nivel.id === 'planta' || nivel.id === 'areaGeneral') return;
      
      html += `
        <div class="form-group" style="opacity: ${nivel.visible ? '1' : '0.5'};">
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" 
                   ${nivel.visible ? 'checked' : ''}
                   onchange="app.toggleNivelVisibilidad('${nivel.id}', this.checked)"
                   style="width: 18px; height: 18px; cursor: pointer;">
            <span style="font-weight: 700; color: var(--primary); min-width: 20px;">${numeroNivel}.</span>
            <span style="flex: 1;">${nivel.nombre}:</span>
            ${nivel.requerido ? '<span style="background: var(--danger); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 700;">OBLIGATORIO</span>' : '<span style="background: var(--text-secondary); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.65rem;">Opcional</span>'}
          </label>
          <input type="text" 
                 class="form-control nivel-input" 
                 id="nivel_${nivel.id}" 
                 data-nivel="${nivel.id}"
                 ${nivel.requerido ? 'required' : ''}
                 ${nivel.visible ? '' : 'disabled'}
                 placeholder="Ej: ${this.getPlaceholderParaNivel(nivel.id)}"
                 onchange="app.updateJerarquiaPreview()"
                 style="margin-left: 26px;">
        </div>
      `;
      
      numeroNivel++;
    });
    
    container.innerHTML = html;
  }

  getPlaceholderParaNivel(nivelId) {
    const placeholders = {
      'subArea': 'Zona Norte, Piso 1, Sector A',
      'sistemaEquipo': 'Grader, Compresor 01, Bomba Principal',
      'subSistema': 'Pocket 1, Motor Principal, Cinta Z',
      'seccion': 'Sistema Hidráulico, Panel Eléctrico, Controles',
      'detalle': 'Lado Izquierdo, Bastidor Superior, Válvula V3'
    };
    return placeholders[nivelId] || 'Ingrese valor';
  }

  updateJerarquiaPreview() {
    const previewText = document.getElementById('jerarquiaPreviewText');
    if (!previewText) return;
    
    const partes = [];
    
    partes.push(this.plantaBase);
    
    this.jerarquiaNiveles.forEach(nivel => {
      if (nivel.id === 'planta') return;
      
      const input = document.getElementById(`nivel_${nivel.id}`);
      if (input && input.value.trim() !== '') {
        partes.push(input.value.trim());
      }
    });
    
    if (partes.length > 0) {
      previewText.innerHTML = partes.map(parte => 
        `<span style="font-weight: 600;">${parte}</span>`
      ).join(' <span style="color: var(--success); font-weight: bold;">›</span> ');
    } else {
      previewText.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">Complete los campos para ver la ruta</span>';
    }
  }

  generarUbicacionResumida(repuesto) {
    // Si tiene múltiples ubicaciones
    if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones) && repuesto.ubicaciones.length > 0) {
      return repuesto.ubicaciones.map(ub => {
        const partes = [];
        if (ub.areaGeneral) partes.push(ub.areaGeneral);
        if (ub.sistemaEquipo) partes.push(ub.sistemaEquipo);
        if (ub.subSistema) partes.push(ub.subSistema);
        return partes.length > 0 ? partes.join(' › ') : 'Sin detalles';
      }).join(' <span style="color: var(--warning);">|</span> ');
    }
    
    // Compatibilidad con formato antiguo
    const partes = [];
    const areaGeneral = repuesto.areaGeneral || repuesto.area || '';
    if (areaGeneral) partes.push(areaGeneral);
    
    const sistemaEquipo = repuesto.sistemaEquipo || repuesto.equipo || '';
    if (sistemaEquipo) partes.push(sistemaEquipo);
    
    const subSistema = repuesto.subSistema || repuesto.sistema || '';
    if (subSistema) partes.push(subSistema);
    
    if (partes.length === 0) return '<em style="color: var(--text-secondary);">Sin ubicación</em>';
    
    return partes.join(' › ');
  }

  // ===== GESTIÓN DE MÚLTIPLES UBICACIONES =====
  
  ubicacionesActuales = [];
  
  agregarUbicacion() {
    const nuevaUbicacion = {
      id: Date.now(),
      areaGeneral: '',
      subArea: '',
      sistemaEquipo: '',
      subSistema: '',
      seccion: '',
      detalle: ''
    };
    
    this.ubicacionesActuales.push(nuevaUbicacion);
    
    // 🔄 SWITCH: Usar versión con cascada o versión original
    if (this.usarVersionCascada) {
      this.renderUbicacionesCascada();
    } else {
      this.renderUbicaciones();
    }
  }
  
  eliminarUbicacion(id) {
    this.ubicacionesActuales = this.ubicacionesActuales.filter(ub => ub.id !== id);
    
    // 🔄 SWITCH: Usar versión con cascada o versión original
    if (this.usarVersionCascada) {
      this.renderUbicacionesCascada();
    } else {
      this.renderUbicaciones();
    }
  }
  
  /**
   * VERSIÓN NUEVA CON CASCADA - Usa jerarquiaAnidada con selects en cascada
   * Esta versión reemplazará a renderUbicaciones() después de ser probada
   */
  renderUbicacionesCascada() {
    const container = document.getElementById('ubicacionesContainer');
    if (!container) return;
    
    if (this.ubicacionesActuales.length === 0) {
      this.agregarUbicacion();
      return;
    }
    
    console.log('🔄 [renderUbicacionesCascada] Renderizando con cascada...');
    
    // Layout horizontal adaptativo según cantidad de ubicaciones
    const numUbicaciones = this.ubicacionesActuales.length;
    const minWidth = numUbicaciones <= 2 ? '350px' : '320px';
    let html = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(${minWidth}, 1fr)); gap: 16px;">`;
    
    this.ubicacionesActuales.forEach((ubicacion, index) => {
      html += `
        <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; border: 2px solid var(--border-color);">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <h5 style="margin: 0; color: var(--text-primary); font-size: 0.95rem; font-weight: 600;">
              Ubicación ${index + 1}
            </h5>
            ${this.ubicacionesActuales.length > 1 ? `
              <button type="button" onclick="app.eliminarUbicacion(${ubicacion.id})" class="btn btn-danger" style="padding: 4px 10px; font-size: 0.75rem;">
                Eliminar
              </button>
            ` : ''}
          </div>
          
          <!-- Nivel 1: Empresa (fijo) -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">1.</span>
              <span>Empresa:</span>
            </label>
            <input type="text" class="form-control" value="Aquachile Antarfood Chonchi" readonly style="background: var(--bg-secondary); cursor: not-allowed; font-size: 0.85rem;">
          </div>
          
          <!-- Nivel 2: Área General -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">2.</span>
              <span>Área General: *</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="areaGeneral"
                    data-nivel="area"
                    style="font-size: 0.85rem;">
              <option value="">-- Seleccionar Área --</option>
            </select>
          </div>
          
          <!-- Nivel 3: Sub-Área -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">3.</span>
              <span>Sub-Área:</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="subArea"
                    data-nivel="subArea"
                    style="font-size: 0.85rem;"
                    disabled>
              <option value="">-- Primero selecciona Área --</option>
            </select>
          </div>
          
          <!-- Nivel 4: Sistema/Equipo -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">4.</span>
              <span>Sistema/Equipo:</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="sistemaEquipo"
                    data-nivel="sistema"
                    style="font-size: 0.85rem;"
                    disabled>
              <option value="">-- Primero selecciona Sub-Área --</option>
            </select>
          </div>
          
          <!-- Nivel 5: Sub-Sistema -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">5.</span>
              <span>Sub-Sistema:</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="subSistema"
                    data-nivel="subSistema"
                    style="font-size: 0.85rem;"
                    disabled>
              <option value="">-- Primero selecciona Sistema --</option>
            </select>
          </div>
          
          <!-- Nivel 6: Sección -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">6.</span>
              <span>Sección:</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="seccion"
                    data-nivel="seccion"
                    style="font-size: 0.85rem;"
                    disabled>
              <option value="">-- Primero selecciona Sub-Sistema --</option>
            </select>
          </div>
          
          <!-- Nivel 7: Sub-Sección -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">7.</span>
              <span>Sub-Sección:</span>
            </label>
            <select class="form-control ubicacion-select-cascada" 
                    data-ubicacion-id="${ubicacion.id}"
                    data-field="subSeccion"
                    data-nivel="subSeccion"
                    style="font-size: 0.85rem;"
                    disabled>
              <option value="">-- Primero selecciona Sección --</option>
            </select>
          </div>
          
          <!-- Nivel 8: Detalle (texto libre) -->
          <div class="form-group" style="margin-bottom: 0;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">8.</span>
              <span>Detalle / Ubicación Específica:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="detalle"
                   value="${ubicacion.detalle || ''}"
                   placeholder="Ej: Lado Izquierdo, Estante 2 Nivel 3, Bastidor Superior"
                   style="font-size: 0.85rem;">
            <small style="color: var(--text-secondary); font-size: 0.7rem; display: block; margin-top: 4px;">
              💡 Campo de texto libre para referencia exacta de ubicación
            </small>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
    // 1. Inicializar los selects con valores actuales
    this.inicializarSelectsCascada();
    
    // 2. Agregar listeners para cascada
    this.configurarListenersCascada();
    
    // 3. Listener para campo de texto libre (detalle)
    document.querySelectorAll('.ubicacion-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const ubicacionId = parseInt(e.target.dataset.ubicacionId);
        const field = e.target.dataset.field;
        const ubicacion = this.ubicacionesActuales.find(ub => ub.id === ubicacionId);
        if (ubicacion) {
          ubicacion[field] = e.target.value;
          console.log(`✏️ [Cascada] Actualizado ${field} =`, e.target.value);
        }
      });
    });
    
    // Actualizar indicador visual
    this.actualizarIndicadorVersion();
    
    console.log('✅ [renderUbicacionesCascada] Renderizado completo');
  }
  
  /**
   * Inicializa los selects con las opciones correctas según valores actuales
   */
  inicializarSelectsCascada() {
    this.ubicacionesActuales.forEach(ubicacion => {
      // Cargar áreas (siempre disponibles)
      this.cargarOpcionesSelect(ubicacion.id, 'area', {});
      
      // Si hay área seleccionada, cargar sub-áreas
      if (ubicacion.areaGeneral) {
        this.cargarOpcionesSelect(ubicacion.id, 'subArea', { area: ubicacion.areaGeneral });
      }
      
      // Si hay sub-área, cargar sistemas
      if (ubicacion.areaGeneral && ubicacion.subArea) {
        this.cargarOpcionesSelect(ubicacion.id, 'sistema', { 
          area: ubicacion.areaGeneral, 
          subArea: ubicacion.subArea 
        });
      }
      
      // Si hay sistema, cargar sub-sistemas
      if (ubicacion.areaGeneral && ubicacion.subArea && ubicacion.sistemaEquipo) {
        this.cargarOpcionesSelect(ubicacion.id, 'subSistema', { 
          area: ubicacion.areaGeneral, 
          subArea: ubicacion.subArea,
          sistema: ubicacion.sistemaEquipo
        });
      }
      
      // Si hay sub-sistema, cargar secciones
      if (ubicacion.areaGeneral && ubicacion.subArea && ubicacion.sistemaEquipo && ubicacion.subSistema) {
        this.cargarOpcionesSelect(ubicacion.id, 'seccion', { 
          area: ubicacion.areaGeneral, 
          subArea: ubicacion.subArea,
          sistema: ubicacion.sistemaEquipo,
          subSistema: ubicacion.subSistema
        });
      }
      
      // Si hay sección, cargar sub-secciones
      if (ubicacion.areaGeneral && ubicacion.subArea && ubicacion.sistemaEquipo && 
          ubicacion.subSistema && ubicacion.seccion) {
        this.cargarOpcionesSelect(ubicacion.id, 'subSeccion', { 
          area: ubicacion.areaGeneral, 
          subArea: ubicacion.subArea,
          sistema: ubicacion.sistemaEquipo,
          subSistema: ubicacion.subSistema,
          seccion: ubicacion.seccion
        });
      }
    });
  }
  
  /**
   * Carga opciones en un select específico según nivel y padres
   */
  cargarOpcionesSelect(ubicacionId, nivel, valoresPadres) {
    const select = document.querySelector(`select[data-ubicacion-id="${ubicacionId}"][data-nivel="${nivel}"]`);
    if (!select) return;
    
    const opciones = this.getOpcionesJerarquicasCascada(nivel, valoresPadres);
    const ubicacion = this.ubicacionesActuales.find(ub => ub.id === ubicacionId);
    const valorActual = ubicacion ? ubicacion[select.dataset.field] : '';
    
    // Generar options
    let optionsHtml = `<option value="">-- Seleccionar ${this.getNombreNivel(nivel)} --</option>`;
    opciones.forEach(opcion => {
      const selected = opcion === valorActual ? 'selected' : '';
      optionsHtml += `<option value="${opcion}" ${selected}>${opcion}</option>`;
    });
    
    select.innerHTML = optionsHtml;
    select.disabled = opciones.length === 0;
    
    console.log(`🔄 [cargarOpcionesSelect] ${nivel} para ubicación ${ubicacionId}: ${opciones.length} opciones`);
  }
  
  /**
   * Obtiene el nombre legible de un nivel
   */
  getNombreNivel(nivel) {
    const nombres = {
      'area': 'Área',
      'subArea': 'Sub-Área',
      'sistema': 'Sistema',
      'subSistema': 'Sub-Sistema',
      'seccion': 'Sección',
      'subSeccion': 'Sub-Sección'
    };
    return nombres[nivel] || nivel;
  }
  
  /**
   * Configura los listeners para la cascada de selects
   */
  configurarListenersCascada() {
    document.querySelectorAll('.ubicacion-select-cascada').forEach(select => {
      select.addEventListener('change', (e) => {
        const ubicacionId = parseInt(e.target.dataset.ubicacionId);
        const field = e.target.dataset.field;
        const nivel = e.target.dataset.nivel;
        const valor = e.target.value;
        
        // Actualizar valor en ubicacionesActuales
        const ubicacion = this.ubicacionesActuales.find(ub => ub.id === ubicacionId);
        if (ubicacion) {
          ubicacion[field] = valor;
          console.log(`✏️ [Cascada] Seleccionado ${field} = "${valor}"`);
          
          // Resetear niveles inferiores
          this.resetearNivelesInferiores(ubicacion, nivel);
          
          // Actualizar select del siguiente nivel
          this.actualizarSiguienteNivel(ubicacionId, nivel, ubicacion);
        }
      });
    });
  }
  
  /**
   * Resetea los valores de niveles inferiores al cambiar un nivel superior
   */
  resetearNivelesInferiores(ubicacion, nivelCambiado) {
    const jerarquia = ['area', 'subArea', 'sistema', 'subSistema', 'seccion', 'subSeccion'];
    const index = jerarquia.indexOf(nivelCambiado);
    
    if (index === -1) return;
    
    // Mapeo de niveles a campos
    const camposPorNivel = {
      'area': 'areaGeneral',
      'subArea': 'subArea',
      'sistema': 'sistemaEquipo',
      'subSistema': 'subSistema',
      'seccion': 'seccion',
      'subSeccion': 'subSeccion'
    };
    
    // Resetear todos los niveles inferiores
    for (let i = index + 1; i < jerarquia.length; i++) {
      const campo = camposPorNivel[jerarquia[i]];
      if (campo && ubicacion[campo]) {
        console.log(`🔄 [resetearNivelesInferiores] Reseteando ${campo}`);
        ubicacion[campo] = '';
      }
    }
  }
  
  /**
   * Actualiza el siguiente nivel en la cascada
   */
  actualizarSiguienteNivel(ubicacionId, nivelActual, ubicacion) {
    const siguienteNivel = {
      'area': 'subArea',
      'subArea': 'sistema',
      'sistema': 'subSistema',
      'subSistema': 'seccion',
      'seccion': 'subSeccion'
    };
    
    const proximoNivel = siguienteNivel[nivelActual];
    if (!proximoNivel) return;
    
    // Construir objeto de valores padres
    const valoresPadres = {};
    if (ubicacion.areaGeneral) valoresPadres.area = ubicacion.areaGeneral;
    if (ubicacion.subArea) valoresPadres.subArea = ubicacion.subArea;
    if (ubicacion.sistemaEquipo) valoresPadres.sistema = ubicacion.sistemaEquipo;
    if (ubicacion.subSistema) valoresPadres.subSistema = ubicacion.subSistema;
    if (ubicacion.seccion) valoresPadres.seccion = ubicacion.seccion;
    
    // Cargar opciones del siguiente nivel
    this.cargarOpcionesSelect(ubicacionId, proximoNivel, valoresPadres);
    
    // También resetear y deshabilitar niveles aún más abajo
    const select = document.querySelector(`select[data-ubicacion-id="${ubicacionId}"][data-nivel="${proximoNivel}"]`);
    if (select) {
      select.disabled = false;
    }
  }

  renderUbicaciones() {
    const container = document.getElementById('ubicacionesContainer');
    if (!container) return;
    
    if (this.ubicacionesActuales.length === 0) {
      this.agregarUbicacion(); // Agregar al menos una ubicación
      return;
    }
    
    // Layout horizontal adaptativo según cantidad de ubicaciones
    const numUbicaciones = this.ubicacionesActuales.length;
    const minWidth = numUbicaciones <= 2 ? '350px' : '320px';
    let html = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(${minWidth}, 1fr)); gap: 16px;">`;
    
    this.ubicacionesActuales.forEach((ubicacion, index) => {
      html += `
        <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; border: 2px solid var(--border-color);">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <h5 style="margin: 0; color: var(--text-primary); font-size: 0.95rem; font-weight: 600;">
              Ubicación ${index + 1}
            </h5>
            ${this.ubicacionesActuales.length > 1 ? `
              <button type="button" onclick="app.eliminarUbicacion(${ubicacion.id})" class="btn btn-danger" style="padding: 4px 10px; font-size: 0.75rem;">
                Eliminar
              </button>
            ` : ''}
          </div>
          
          <!-- Nivel 1: Empresa (fijo) -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">1.</span>
              <span>Empresa:</span>
            </label>
            <input type="text" class="form-control" value="Aquachile Antarfood Chonchi" readonly style="background: var(--bg-secondary); cursor: not-allowed; font-size: 0.85rem;">
          </div>
          
          <!-- Nivel 2: Área General -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">2.</span>
              <span>Área General: *</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="areaGeneral"
                   value="${ubicacion.areaGeneral}"
                   list="areaGeneralList-${ubicacion.id}"
                   placeholder="Ej: Planta Principal, Acopio"
                   style="font-size: 0.85rem;">
            <datalist id="areaGeneralList-${ubicacion.id}">
              ${this.opcionesJerarquia.areaGeneral.map(opt => `<option value="${opt}">`).join('')}
            </datalist>
          </div>
          
          <!-- Nivel 3: Sub-Área -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">3.</span>
              <span>Sub-Área:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="subArea"
                   value="${ubicacion.subArea}"
                   list="subAreaList-${ubicacion.id}"
                   placeholder="Ej: Zona Norte, Piso 1"
                   style="font-size: 0.85rem;">
            <datalist id="subAreaList-${ubicacion.id}">
              ${this.opcionesJerarquia.subArea.map(opt => `<option value="${opt}">`).join('')}
            </datalist>
          </div>
          
          <!-- Nivel 4: Sistema/Equipo -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">4.</span>
              <span>Sistema/Equipo:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="sistemaEquipo"
                   value="${ubicacion.sistemaEquipo}"
                   list="sistemaEquipoList-${ubicacion.id}"
                   placeholder="Ej: Grader Marel, Compresor 01"
                   style="font-size: 0.85rem;">
            <datalist id="sistemaEquipoList-${ubicacion.id}">
              ${this.opcionesJerarquia.sistemaEquipo.map(opt => `<option value="${opt}">`).join('')}
            </datalist>
          </div>
          
          <!-- Nivel 5: Sub-Sistema -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">5.</span>
              <span>Sub-Sistema:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="subSistema"
                   value="${ubicacion.subSistema}"
                   list="subSistemaList-${ubicacion.id}"
                   placeholder="Ej: Pocket 1, Motor Principal"
                   style="font-size: 0.85rem;">
            <datalist id="subSistemaList-${ubicacion.id}">
              ${this.opcionesJerarquia.subSistema.map(opt => `<option value="${opt}">`).join('')}
            </datalist>
          </div>
          
          <!-- Nivel 6: Sección -->
          <div class="form-group" style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">6.</span>
              <span>Sección:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="seccion"
                   value="${ubicacion.seccion}"
                   list="seccionList-${ubicacion.id}"
                   placeholder="Ej: Sistema Hidráulico, Panel Eléctrico"
                   style="font-size: 0.85rem;">
            <datalist id="seccionList-${ubicacion.id}">
              ${this.opcionesJerarquia.seccion.map(opt => `<option value="${opt}">`).join('')}
            </datalist>
          </div>
          
          <!-- Nivel 7: Detalle -->
          <div class="form-group" style="margin-bottom: 0;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 0.85rem;">
              <span style="font-weight: 700; color: var(--primary);">7.</span>
              <span>Detalle / Ubicación Específica:</span>
            </label>
            <input type="text" 
                   class="form-control ubicacion-input" 
                   data-ubicacion-id="${ubicacion.id}"
                   data-field="detalle"
                   value="${ubicacion.detalle}"
                   placeholder="Ej: Lado Izquierdo, Estante 2 Nivel 3, Bastidor Superior"
                   style="font-size: 0.85rem;">
            <small style="color: var(--text-secondary); font-size: 0.7rem; display: block; margin-top: 4px;">
              💡 Campo de texto libre para referencia exacta de ubicación
            </small>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
    // Agregar listeners para actualizar datos
    document.querySelectorAll('.ubicacion-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const ubicacionId = parseInt(e.target.dataset.ubicacionId);
        const field = e.target.dataset.field;
        const ubicacion = this.ubicacionesActuales.find(ub => ub.id === ubicacionId);
        if (ubicacion) {
          ubicacion[field] = e.target.value;
          console.log(`✏️ Actualizado ${field} =`, e.target.value, 'en ubicación', ubicacionId);
        }
      });
    });
    
    // DEBUG: Mostrar estado actual
    console.log('📍 Ubicaciones actuales:', JSON.stringify(this.ubicacionesActuales, null, 2));
    
    // Actualizar indicador visual
    this.actualizarIndicadorVersion();
    
    // Ajustar ancho del modal según cantidad de ubicaciones
    this.ajustarAnchoModal();
  }
  
  /**
   * 🧪 Actualiza el indicador visual de qué versión está activa
   */
  actualizarIndicadorVersion() {
    const indicador = document.getElementById('versionIndicator');
    if (!indicador) return;
    
    if (this.usarVersionCascada) {
      indicador.innerHTML = '🆕 CASCADA (selects en cascada)';
      indicador.style.background = 'rgba(34, 197, 94, 0.15)';
      indicador.style.borderColor = 'rgba(34, 197, 94, 0.4)';
      indicador.style.color = '#22c55e';
    } else {
      indicador.innerHTML = '📝 ORIGINAL (inputs + datalist)';
      indicador.style.background = 'rgba(59, 130, 246, 0.15)';
      indicador.style.borderColor = 'rgba(59, 130, 246, 0.4)';
      indicador.style.color = '#3b82f6';
    }
  }
  
  ajustarAnchoModal() {
    const modalContent = document.querySelector('.modal-content');
    if (!modalContent) return;
    
    const numUbicaciones = this.ubicacionesActuales.length;
    const screenWidth = window.innerWidth;
    
    // En móviles, siempre full width
    if (screenWidth <= 480) {
      modalContent.style.width = 'calc(100vw - 20px)';
      return;
    }
    
    // Calcular ancho óptimo según número de ubicaciones
    let optimalWidth;
    if (numUbicaciones === 1) {
      optimalWidth = '800px';
    } else if (numUbicaciones === 2) {
      optimalWidth = '1100px';
    } else if (numUbicaciones === 3) {
      optimalWidth = '1400px';
    } else if (numUbicaciones === 4) {
      optimalWidth = '1700px';
    } else {
      optimalWidth = 'calc(100vw - 20px)'; // 5 o más = full width
    }
    
    // Aplicar el ancho, pero no exceder el ancho de pantalla
    modalContent.style.width = optimalWidth;
    modalContent.style.maxWidth = 'calc(100vw - 20px)';
  }

  /**
   * NUEVA FUNCIÓN AUXILIAR - Obtiene opciones jerárquicas en cascada
   * Recorre jerarquiaAnidada y retorna opciones válidas según selección de padres
   * 
   * @param {string} nivel - El nivel a obtener: 'area', 'subArea', 'sistema', 'subSistema', 'seccion', 'subSeccion'
   * @param {object} valoresPadres - Valores seleccionados de niveles superiores
   * @returns {Array<string>} - Array de nombres válidos para el nivel especificado
   * 
   * Ejemplos de uso:
   *   getOpcionesJerarquicasCascada('area', {})  
   *   → ['Planta Principal', 'Acopio', ...]
   * 
   *   getOpcionesJerarquicasCascada('subArea', { area: 'Planta Principal' })  
   *   → ['Eviscerado', 'Proceso', ...] (solo las que pertenecen a Planta Principal)
   * 
   *   getOpcionesJerarquicasCascada('sistema', { area: 'Planta Principal', subArea: 'Eviscerado' })
   *   → ['Grader', ...] (solo sistemas bajo Eviscerado)
   */
  getOpcionesJerarquicasCascada(nivel, valoresPadres = {}) {
    console.log(`[getOpcionesJerarquicasCascada] Nivel: ${nivel}, Padres:`, valoresPadres);
    
    // Si no hay jerarquía anidada, retornar array vacío
    if (!this.jerarquiaAnidada || !this.jerarquiaAnidada.areas) {
      console.warn('[getOpcionesJerarquicasCascada] No existe jerarquiaAnidada');
      return [];
    }
    
    const opciones = [];
    
    try {
      switch(nivel) {
        case 'area':
          // Nivel 2: retornar todas las áreas
          this.jerarquiaAnidada.areas.forEach(area => {
            if (area.nombre) opciones.push(area.nombre);
          });
          break;
          
        case 'subArea':
          // Nivel 3: filtrar por área seleccionada
          if (!valoresPadres.area) {
            console.warn('[getOpcionesJerarquicasCascada] Se requiere área para obtener sub-áreas');
            return [];
          }
          
          const area = this.jerarquiaAnidada.areas.find(a => a.nombre === valoresPadres.area);
          if (area && area.subAreas) {
            area.subAreas.forEach(subArea => {
              if (subArea.nombre) opciones.push(subArea.nombre);
            });
          }
          break;
          
        case 'sistema':
          // Nivel 4: filtrar por área y sub-área seleccionadas
          if (!valoresPadres.area || !valoresPadres.subArea) {
            console.warn('[getOpcionesJerarquicasCascada] Se requiere área y sub-área para obtener sistemas');
            return [];
          }
          
          const areaParaSistema = this.jerarquiaAnidada.areas.find(a => a.nombre === valoresPadres.area);
          if (areaParaSistema && areaParaSistema.subAreas) {
            const subArea = areaParaSistema.subAreas.find(sa => sa.nombre === valoresPadres.subArea);
            if (subArea && subArea.sistemas) {
              subArea.sistemas.forEach(sistema => {
                if (sistema.nombre) opciones.push(sistema.nombre);
              });
            }
          }
          break;
          
        case 'subSistema':
          // Nivel 5: filtrar por área, sub-área y sistema seleccionados
          if (!valoresPadres.area || !valoresPadres.subArea || !valoresPadres.sistema) {
            console.warn('[getOpcionesJerarquicasCascada] Se requiere área, sub-área y sistema para obtener sub-sistemas');
            return [];
          }
          
          const areaParaSubSistema = this.jerarquiaAnidada.areas.find(a => a.nombre === valoresPadres.area);
          if (areaParaSubSistema && areaParaSubSistema.subAreas) {
            const subAreaParaSubSistema = areaParaSubSistema.subAreas.find(sa => sa.nombre === valoresPadres.subArea);
            if (subAreaParaSubSistema && subAreaParaSubSistema.sistemas) {
              const sistema = subAreaParaSubSistema.sistemas.find(s => s.nombre === valoresPadres.sistema);
              if (sistema && sistema.subSistemas) {
                sistema.subSistemas.forEach(subSistema => {
                  if (subSistema.nombre) opciones.push(subSistema.nombre);
                });
              }
            }
          }
          break;
          
        case 'seccion':
          // Nivel 6: filtrar por área, sub-área, sistema y sub-sistema seleccionados
          if (!valoresPadres.area || !valoresPadres.subArea || !valoresPadres.sistema || !valoresPadres.subSistema) {
            console.warn('[getOpcionesJerarquicasCascada] Se requiere área, sub-área, sistema y sub-sistema para obtener secciones');
            return [];
          }
          
          const areaParaSeccion = this.jerarquiaAnidada.areas.find(a => a.nombre === valoresPadres.area);
          if (areaParaSeccion && areaParaSeccion.subAreas) {
            const subAreaParaSeccion = areaParaSeccion.subAreas.find(sa => sa.nombre === valoresPadres.subArea);
            if (subAreaParaSeccion && subAreaParaSeccion.sistemas) {
              const sistemaParaSeccion = subAreaParaSeccion.sistemas.find(s => s.nombre === valoresPadres.sistema);
              if (sistemaParaSeccion && sistemaParaSeccion.subSistemas) {
                const subSistema = sistemaParaSeccion.subSistemas.find(ss => ss.nombre === valoresPadres.subSistema);
                if (subSistema && subSistema.secciones) {
                  subSistema.secciones.forEach(seccion => {
                    if (seccion.nombre) opciones.push(seccion.nombre);
                  });
                }
              }
            }
          }
          break;
          
        case 'subSeccion':
          // Nivel 7: filtrar por área, sub-área, sistema, sub-sistema y sección seleccionados
          if (!valoresPadres.area || !valoresPadres.subArea || !valoresPadres.sistema || 
              !valoresPadres.subSistema || !valoresPadres.seccion) {
            console.warn('[getOpcionesJerarquicasCascada] Se requieren todos los niveles superiores para obtener sub-secciones');
            return [];
          }
          
          const areaParaSubSeccion = this.jerarquiaAnidada.areas.find(a => a.nombre === valoresPadres.area);
          if (areaParaSubSeccion && areaParaSubSeccion.subAreas) {
            const subAreaParaSubSeccion = areaParaSubSeccion.subAreas.find(sa => sa.nombre === valoresPadres.subArea);
            if (subAreaParaSubSeccion && subAreaParaSubSeccion.sistemas) {
              const sistemaParaSubSeccion = subAreaParaSubSeccion.sistemas.find(s => s.nombre === valoresPadres.sistema);
              if (sistemaParaSubSeccion && sistemaParaSubSeccion.subSistemas) {
                const subSistemaParaSubSeccion = sistemaParaSubSeccion.subSistemas.find(ss => ss.nombre === valoresPadres.subSistema);
                if (subSistemaParaSubSeccion && subSistemaParaSubSeccion.secciones) {
                  const seccion = subSistemaParaSubSeccion.secciones.find(sec => sec.nombre === valoresPadres.seccion);
                  if (seccion && seccion.subSecciones) {
                    seccion.subSecciones.forEach(subSeccion => {
                      if (subSeccion.nombre) opciones.push(subSeccion.nombre);
                    });
                  }
                }
              }
            }
          }
          break;
          
        default:
          console.error(`[getOpcionesJerarquicasCascada] Nivel desconocido: ${nivel}`);
          return [];
      }
      
      console.log(`[getOpcionesJerarquicasCascada] Resultado: ${opciones.length} opciones`, opciones);
      return opciones;
      
    } catch (error) {
      console.error('[getOpcionesJerarquicasCascada] Error al obtener opciones:', error);
      return [];
    }
  }

  mostrarEjemplosCategoria(categoria) {
    const ejemplosElement = document.getElementById('ejemplosCategoria');
    if (!ejemplosElement) return;
    
    const ejemplos = {
      'Repuesto': 'Ejemplos: filtros, rodamientos, válvulas, correas, motores',
      'Insumo': 'Ejemplos: brochas, guantes, grasas, pinturas, cintas adhesivas',
      'Herramienta': 'Ejemplos: taladros, llaves, destornilladores, martillos',
      'EPP': 'Ejemplos: cascos, lentes, arneses, guantes de seguridad',
      'Químico': 'Ejemplos: desengrasantes, ácidos, solventes, desinfectantes'
    };
    
    if (categoria && ejemplos[categoria]) {
      ejemplosElement.textContent = ejemplos[categoria];
      ejemplosElement.style.color = '#7A9AB8'; // Azul claro
    } else {
      ejemplosElement.textContent = 'Selecciona una categoría para ver ejemplos';
      ejemplosElement.style.color = '#94a3b8'; // Gris
    }
  }

  mostrarJerarquia(id) {
    const repuesto = this.repuestos.find(r => r.id === id);
    if (!repuesto) return;
    
    // Obtener ubicaciones (nuevo formato o antiguo)
    let ubicaciones = [];
    if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones) && repuesto.ubicaciones.length > 0) {
      ubicaciones = repuesto.ubicaciones;
    } else {
      // Formato antiguo: crear array con una ubicación
      ubicaciones = [{
        areaGeneral: repuesto.areaGeneral || repuesto.area,
        subArea: repuesto.subArea,
        sistemaEquipo: repuesto.sistemaEquipo || repuesto.equipo,
        subSistema: repuesto.subSistema || repuesto.sistema,
        seccion: repuesto.seccion,
        detalle: repuesto.detalle || repuesto.detalleUbicacion
      }];
    }
    
    const planta = repuesto.planta || this.plantaBase;
    
    // CONSTRUIR ÁRBOL RAMIFICADO (con nombre del repuesto)
    const arbolHTML = this.construirArbolJerarquia(ubicaciones, planta, repuesto.nombre);
    
    const html = `
      <div style="width: 90vw; max-width: 1400px; max-height: 85vh; background: var(--card-bg); border-radius: 12px; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
        
        <!-- Header -->
        <div style="padding: 20px 24px; background: var(--primary); border-bottom: 1px solid rgba(255,255,255,0.1); flex-shrink: 0;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <h3 style="margin: 0; color: #ffffff; font-size: 1.3rem; font-weight: 600;">
              📍 Ubicación del Repuesto
            </h3>
            <button onclick="app.closeCustomModal()" 
                    style="background: rgba(255,255,255,0.15); border: none; color: white; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; font-size: 18px; transition: all 0.2s;"
                    onmouseover="this.style.background='rgba(255,255,255,0.25)'"
                    onmouseout="this.style.background='rgba(255,255,255,0.15)'">✕</button>
          </div>
          <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
            <div style="font-size: 0.9rem; font-weight: 600; color: #ffffff;">${repuesto.nombre}</div>
            ${repuesto.codSAP ? `<div style="font-size: 0.75rem; color: rgba(255,255,255,0.85); background: rgba(255,255,255,0.15); padding: 4px 10px; border-radius: 4px;">SAP: ${repuesto.codSAP}</div>` : ''}
            <div style="margin-left: auto; font-size: 0.7rem; color: rgba(255,255,255,0.75); background: rgba(255,255,255,0.1); padding: 5px 12px; border-radius: 12px; font-weight: 500;">
              ${ubicaciones.length} ${ubicaciones.length === 1 ? 'Ubicación' : 'Ubicaciones'}
            </div>
          </div>
        </div>
        
        <!-- Área del árbol con scroll -->
        <div style="flex: 1; overflow: auto; background: var(--bg-secondary); padding: 20px;">
          ${arbolHTML}
        </div>
        
        <!-- Footer -->
        <div style="padding: 14px 24px; background: var(--bg-secondary); border-top: 1px solid var(--border); flex-shrink: 0; display: flex; justify-content: center;">
          <button onclick="app.closeCustomModal()" 
                  style="padding: 12px 48px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.95rem; font-weight: 600; transition: all 0.2s;"
                  onmouseover="this.style.opacity='0.9'"
                  onmouseout="this.style.opacity='1'">
            Cerrar
          </button>
        </div>
        
      </div>
    `;
    
    this.showCustomModal(html);
  }
  
  construirArbolJerarquia(ubicaciones, planta, nombreRepuesto) {
    console.log('🌳 Construyendo árbol tipo dendrograma VERTICAL...', ubicaciones);
    if (ubicaciones.length === 0) return '<div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 0.95rem;">Sin ubicaciones registradas</div>';
    
    // Estructura de árbol: agrupar ubicaciones por jerarquía común (CON nombre del repuesto antes del detalle)
    const niveles = ['areaGeneral', 'subArea', 'sistemaEquipo', 'subSistema', 'seccion', 'nombreRepuesto', 'detalle'];
    const nodos = this.construirNodosArbol(ubicaciones, planta, niveles, nombreRepuesto);
    console.log('🌲 Nodos construidos:', nodos);
    
    // Calcular posiciones VERTICALES (hacia abajo)
    let posicionX = 0;
    const nodosConPosicion = [];
    const nivelY = 110; // Espacio vertical entre niveles
    const anchoNodo = 240; // Ancho de nodos
    const altoNodo = 70;
    
    const calcularPosiciones = (nodo, nivel = 0) => {
      const y = nivel * nivelY + 50;
      
      if (!nodo.hijos || nodo.hijos.length === 0) {
        // Nodo hoja
        const x = posicionX * (anchoNodo + 30) + 50;
        nodosConPosicion.push({ ...nodo, x, y, nivel });
        posicionX++;
        return x;
      } else {
        // Nodo con hijos
        const posicionesHijos = nodo.hijos.map(hijo => 
          calcularPosiciones(hijo, nivel + 1)
        );
        const xPromedio = (Math.min(...posicionesHijos) + Math.max(...posicionesHijos)) / 2;
        nodosConPosicion.push({ ...nodo, x: xPromedio, y, nivel, posicionesHijos });
        return xPromedio;
      }
    };
    
    // Calcular posiciones de todos los nodos
    nodos.forEach(nodo => calcularPosiciones(nodo));
    
    // Calcular dimensiones del SVG
    const maxX = Math.max(...nodosConPosicion.map(n => n.x)) + anchoNodo + 100;
    const maxY = Math.max(...nodosConPosicion.map(n => n.y)) + altoNodo + 60;
    
    // Generar SVG con líneas y nodos (VERTICAL)
    let svg = `<svg width="${maxX}" height="${maxY}" style="font-family: system-ui, -apple-system, sans-serif; display: block; min-width: 100%;">`;
    
    // Definir gradientes y filtros SUAVES
    svg += `
      <defs>
        <filter id="sombra" x="-30%" y="-30%" width="160%" height="160%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
          <feOffset dx="0" dy="3" result="offsetblur"/>
          <feComponentTransfer>
            <feFuncA type="linear" slope="0.15"/>
          </feComponentTransfer>
          <feMerge>
            <feMergeNode/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
    `;
    
    // Dibujar líneas de conexión
    nodosConPosicion.forEach(nodo => {
      if (nodo.hijos && nodo.hijos.length > 0) {
        const nodoCentroX = nodo.x + anchoNodo / 2;
        const nodoCentroYAbajo = nodo.y + altoNodo;
        
        nodo.hijos.forEach((hijo, idx) => {
          const hijoNodo = nodosConPosicion.find(n => n.valor === hijo.valor && n.nivel === nodo.nivel + 1);
          if (hijoNodo) {
            const hijoCentroX = hijoNodo.x + anchoNodo / 2;
            const hijoCentroYArriba = hijoNodo.y;
            
            // Línea vertical desde el padre
            const yMedio = nodoCentroYAbajo + 25;
            svg += `<line x1="${nodoCentroX}" y1="${nodoCentroYAbajo}" x2="${nodoCentroX}" y2="${yMedio}" stroke="#94a3b8" stroke-width="2" opacity="0.6"/>`;
            
            // Línea horizontal (si hay múltiples hijos)
            if (nodo.hijos.length > 1) {
              if (idx === 0) {
                const ultimoHijo = nodosConPosicion.find(n => n.valor === nodo.hijos[nodo.hijos.length - 1].valor && n.nivel === nodo.nivel + 1);
                if (ultimoHijo) {
                  const ultimoHijoCentroX = ultimoHijo.x + anchoNodo / 2;
                  svg += `<line x1="${hijoCentroX}" y1="${yMedio}" x2="${ultimoHijoCentroX}" y2="${yMedio}" stroke="#94a3b8" stroke-width="2" opacity="0.6"/>`;
                }
              }
            }
            
            // Línea vertical hasta el hijo
            svg += `<line x1="${hijoCentroX}" y1="${yMedio}" x2="${hijoCentroX}" y2="${hijoCentroYArriba}" stroke="#94a3b8" stroke-width="2" opacity="0.6"/>`;
          }
        });
      }
    });
    
    // Colores CORPORATIVOS MATE del proyecto (los originales que pediste)
    const coloresPorNivel = [
      { fondo: '#C4A882', borde: '#A68F6D', texto: '#ffffff' }, // Nivel 0 - Empresa (beige/café mate)
      { fondo: '#6B8499', borde: '#5A7188', texto: '#ffffff' }, // Nivel 1 - Área (azul gris mate)
      { fondo: '#7D8A97', borde: '#6A7784', texto: '#ffffff' }, // Nivel 2 - Sub-área (gris azulado mate)
      { fondo: '#8897A8', borde: '#7586a7', texto: '#ffffff' }, // Nivel 3 - Sistema (azul acero mate)
      { fondo: '#939FAB', borde: '#808C98', texto: '#ffffff' }, // Nivel 4 - Sub-sistema (gris perla mate)
      { fondo: '#A1B0BC', borde: '#8E9DA9', texto: '#ffffff' }, // Nivel 5 - Sección (azul claro mate)
      { fondo: '#7FA396', borde: '#6C9083', texto: '#ffffff' }, // Nivel 6 - Repuesto (verde gris mate)
      { fondo: '#6D9488', borde: '#5A8175', texto: '#ffffff' }  // Nivel 7 - Detalle (verde azulado mate)
    ];
    
    // Dibujar nodos SIN INTERACTIVIDAD (solo visualización)
    nodosConPosicion.forEach(nodo => {
      const tieneUbicaciones = nodo.ubicaciones && nodo.ubicaciones.length > 0;
      const colores = coloresPorNivel[nodo.nivel] || coloresPorNivel[coloresPorNivel.length - 1];
      
      // Grupo del nodo (sin eventos)
      svg += `<g>`;
      
      // Fondo del nodo
      if (tieneUbicaciones) {
        // Nodo final con ubicación - Verde corporativo destacado
        svg += `<rect x="${nodo.x}" y="${nodo.y}" width="${anchoNodo}" height="${altoNodo}" rx="8" 
                  fill="#6D9488" 
                  stroke="#5A8175" 
                  stroke-width="2.5"
                  filter="url(#sombra)"/>`;
      } else {
        // Nodo normal con colores corporativos
        svg += `<rect x="${nodo.x}" y="${nodo.y}" width="${anchoNodo}" height="${altoNodo}" rx="8" 
                  fill="${colores.fondo}" 
                  stroke="${colores.borde}" 
                  stroke-width="2"
                  filter="url(#sombra)"/>`;
      }
      
      // Etiqueta del nivel
      if (nodo.etiqueta) {
        svg += `<text x="${nodo.x + anchoNodo/2}" y="${nodo.y + 15}" 
                  text-anchor="middle" 
                  fill="rgba(255,255,255,0.65)" 
                  font-size="9" 
                  font-weight="600"
                  letter-spacing="0.8"
                  pointer-events="none">${nodo.etiqueta.toUpperCase()}</text>`;
      }
      
      // Texto del nodo
      const lineas = this.dividirTextoEnLineas(nodo.valor, 32);
      const yInicial = nodo.y + (lineas.length === 1 ? altoNodo/2 + 6 : altoNodo/2 - 2);
      
      lineas.forEach((linea, idx) => {
        svg += `<text x="${nodo.x + anchoNodo/2}" y="${yInicial + (idx * 17)}" 
                  text-anchor="middle" 
                  dominant-baseline="middle" 
                  fill="#ffffff" 
                  font-size="13.5" 
                  font-weight="600"
                  pointer-events="none">${linea}</text>`;
      });
      
      // Badge de ubicación
      if (tieneUbicaciones) {
        svg += `<text x="${nodo.x + anchoNodo/2}" y="${nodo.y + altoNodo - 10}" 
                  text-anchor="middle" 
                  fill="rgba(255,255,255,0.9)" 
                  font-size="8.5" 
                  font-weight="700"
                  letter-spacing="0.5"
                  pointer-events="none">📍 UBICACIÓN ${nodo.ubicaciones.join(', ')}</text>`;
      }
      
      svg += `</g>`;
    });
    
    svg += '</svg>';
    
    return `<div style="width: 100%; height: 100%; overflow: auto; display: flex; align-items: center; justify-content: center;">${svg}</div>`;
  }
  
  // Función auxiliar para dividir texto en líneas
  dividirTextoEnLineas(texto, maxCaracteres) {
    if (texto.length <= maxCaracteres) return [texto];
    
    const palabras = texto.split(' ');
    const lineas = [];
    let lineaActual = '';
    
    palabras.forEach(palabra => {
      if ((lineaActual + palabra).length <= maxCaracteres) {
        lineaActual += (lineaActual ? ' ' : '') + palabra;
      } else {
        if (lineaActual) lineas.push(lineaActual);
        lineaActual = palabra;
      }
    });
    
    if (lineaActual) lineas.push(lineaActual);
    return lineas.slice(0, 3); // Máximo 3 líneas
  }

  // Filtrar repuestos por nivel de jerarquía
  filtrarPorJerarquia(campo, valor) {
    console.log(`🔍 Filtrando por ${campo}: "${valor}"`);
    
    // Mapeo de campos del árbol a campos de ubicación
    const mapaCampos = {
      'planta': 'planta',
      'areaGeneral': 'areaGeneral',
      'subArea': 'subArea',
      'sistemaEquipo': 'sistemaEquipo',
      'subSistema': 'subSistema',
      'seccion': 'seccion',
      'detalle': 'detalle'
    };
    
    const campoReal = mapaCampos[campo] || campo;
    
    // Buscar repuestos que tengan este valor en cualquiera de sus ubicaciones
    const repuestosFiltrados = this.repuestos.filter(repuesto => {
      if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
        return repuesto.ubicaciones.some(ub => ub[campoReal] === valor);
      } else {
        // Formato antiguo
        return repuesto[campoReal] === valor;
      }
    });
    
    console.log(`✅ Encontrados ${repuestosFiltrados.length} repuestos`);
    
    // Mostrar resultados en modal ampliado
    this.mostrarResultadosFiltro(campo, valor, repuestosFiltrados);
  }

  // Mostrar resultados del filtro en modal ampliado
  mostrarResultadosFiltro(campo, valor, repuestos) {
    const nombreCampo = {
      'planta': 'Empresa',
      'areaGeneral': 'Área General',
      'subArea': 'Sub-Área',
      'sistemaEquipo': 'Sistema/Equipo',
      'subSistema': 'Sub-Sistema',
      'seccion': 'Sección',
      'detalle': 'Detalle'
    }[campo] || campo;
    
    let html = `
      <div style="padding: clamp(20px, 3vw, 32px); background: var(--card-bg); border-radius: 16px; width: 95vw; max-width: 1800px; height: 90vh; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; border-bottom: 2px solid var(--border); padding-bottom: 16px; flex-shrink: 0; flex-wrap: wrap; gap: 12px;">
          <div>
            <h3 style="margin: 0 0 8px 0; color: var(--text-primary); font-size: clamp(1.1rem, 2vw, 1.4rem); font-weight: 600;">
              Repuestos en ${nombreCampo}
            </h3>
            <div style="font-size: clamp(0.8rem, 1.5vw, 0.9rem); color: var(--text-secondary); font-weight: 500;">
              "${valor}"
            </div>
          </div>
          <div style="display: flex; gap: 12px; align-items: center;">
            <div style="font-size: 0.75rem; color: var(--text-secondary); background: var(--bg-secondary); padding: 6px 14px; border-radius: 20px; font-weight: 600;">
              ${repuestos.length} Repuesto${repuestos.length !== 1 ? 's' : ''}
            </div>
            <button onclick="app.closeCustomModal()" style="background: var(--bg-secondary); border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; color: var(--text-primary); font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='var(--border)'" onmouseout="this.style.background='var(--bg-secondary)'">
              Cerrar
            </button>
          </div>
        </div>
        
        <div style="flex: 1; overflow-y: auto; padding-right: 8px;">
    `;
    
    if (repuestos.length === 0) {
      html += `
        <div style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">
          <div style="font-size: 3rem; margin-bottom: 16px; opacity: 0.3;">📦</div>
          <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 8px;">No hay repuestos</div>
          <div style="font-size: 0.9rem;">No se encontraron repuestos en esta ubicación</div>
        </div>
      `;
    } else {
      // Grid de repuestos (responsivo)
      html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(300px, 100%), 1fr)); gap: 16px;">';
      
      repuestos.forEach(repuesto => {
        // Obtener imagen principal (buscar formatos FileSystem primero)
        let imagenPrincipal = null;
        if (repuesto.multimedia && repuesto.multimedia.length > 0) {
          const imagenFS = repuesto.multimedia.find(m => m.isFileSystem && m.url);
          imagenPrincipal = imagenFS ? imagenFS.url : repuesto.multimedia[0].url;
        }
        
        html += `
          <div style="background: var(--bg-primary); border: 2px solid var(--border); border-radius: 12px; overflow: hidden; transition: all 0.2s; cursor: pointer;" 
               onclick="app.editRepuesto('${repuesto.id}')"
               onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 20px rgba(0,0,0,0.15)'"
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            
            ${imagenPrincipal ? `
              <div style="height: 180px; background: var(--bg-secondary); position: relative; overflow: hidden;">
                <img src="${imagenPrincipal}" 
                     style="width: 100%; height: 100%; object-fit: cover;" 
                     onerror="this.parentElement.innerHTML='<div style=\\'height: 180px; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; color: var(--text-secondary); font-size: 3rem; opacity: 0.3;\\'>📦</div>'">
              </div>
            ` : `
              <div style="height: 180px; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; color: var(--text-secondary); font-size: 3rem; opacity: 0.3;">
                📦
              </div>
            `}
            
            <div style="padding: 16px;">
              <div style="font-weight: 600; font-size: 1rem; color: var(--text-primary); margin-bottom: 8px; line-height: 1.3;">
                ${repuesto.nombre}
              </div>
              
              ${repuesto.codSAP ? `
                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 4px;">
                  <span style="font-weight: 600;">SAP:</span> ${repuesto.codSAP}
                </div>
              ` : ''}
              
              <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                ${repuesto.tipo ? `<span style="font-size: 0.7rem; background: var(--bg-secondary); padding: 4px 8px; border-radius: 6px; color: var(--text-secondary); font-weight: 600;">${repuesto.tipo}</span>` : ''}
                <span style="font-size: 0.7rem; background: ${repuesto.cantidad > repuesto.minimo ? '#d1fae5' : '#fee2e2'}; color: ${repuesto.cantidad > repuesto.minimo ? '#065f46' : '#991b1b'}; padding: 4px 8px; border-radius: 6px; font-weight: 600;">Stock: ${repuesto.cantidad}</span>
              </div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
    }
    
    html += `
        </div>
      </div>
    `;
    
    this.showCustomModal(html);
  }
  
  construirNodosArbol(ubicaciones, planta, niveles, nombreRepuesto) {
    // Crear nodo raíz (empresa/planta)
    const raiz = {
      nivel: -1,
      campo: 'planta',
      valor: planta || 'Aquachile Antarfood Chonchi',
      etiqueta: 'Empresa',
      hijos: [],
      ubicaciones: []
    };
    
    const etiquetasNiveles = {
      'areaGeneral': 'Área General',
      'subArea': 'Sub-Área',
      'sistemaEquipo': 'Sistema/Equipo',
      'subSistema': 'Sub-Sistema',
      'seccion': 'Sección',
      'nombreRepuesto': 'Repuesto',
      'detalle': 'Detalle Ubicación'
    };
    
    // Procesar cada ubicación
    ubicaciones.forEach((ubicacion, index) => {
      let nodoActual = raiz;
      let ultimoNodoConValor = null;
      
      // Recorrer cada nivel de jerarquía
      niveles.forEach((campo, nivelIdx) => {
        let valor = ubicacion[campo];
        
        // Si es nombreRepuesto, usar el valor pasado como parámetro
        if (campo === 'nombreRepuesto') {
          valor = nombreRepuesto;
        }
        
        if (!valor || valor.trim() === '') return; // Saltar niveles vacíos
        
        // Buscar si ya existe un hijo con este valor
        let hijo = nodoActual.hijos.find(h => h.campo === campo && h.valor === valor);
        
        if (!hijo) {
          // Crear nuevo nodo
          hijo = {
            nivel: nivelIdx,
            campo: campo,
            valor: valor,
            etiqueta: etiquetasNiveles[campo] || campo,
            hijos: [],
            ubicaciones: []
          };
          nodoActual.hijos.push(hijo);
        }
        
        ultimoNodoConValor = hijo;
        nodoActual = hijo;
      });
      
      // Marcar la ubicación en el último nodo con valor
      if (ultimoNodoConValor) {
        ultimoNodoConValor.ubicaciones.push(index + 1);
      }
    });
    
    return [raiz];
  }

  showCustomModal(content) {
    let modal = document.getElementById('customModalOverlay');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'customModalOverlay';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;
      modal.onclick = (e) => {
        if (e.target === modal) this.closeCustomModal();
      };
      document.body.appendChild(modal);
    }
    modal.innerHTML = `
      <div style="max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto;">
        ${content}
      </div>
    `;
    modal.style.display = 'flex';
    
    // Agregar listener para ESC
    this.addEscapeListener();
  }

  closeCustomModal() {
    const modal = document.getElementById('customModalOverlay');
    if (modal) modal.style.display = 'none';
    this.removeEscapeListener();
  }

  addEscapeListener() {
    if (!this.escapeHandler) {
      this.escapeHandler = (e) => {
        if (e.key === 'Escape') {
          // Cerrar modal personalizado si está abierto
          const customModal = document.getElementById('customModalOverlay');
          if (customModal && customModal.style.display === 'flex') {
            this.closeCustomModal();
            return;
          }
          
          // Cerrar modal principal si está abierto
          const mainModal = document.getElementById('modal');
          if (mainModal && mainModal.classList.contains('active')) {
            this.closeModal();
            return;
          }
        }
      };
    }
    document.addEventListener('keydown', this.escapeHandler);
  }

  removeEscapeListener() {
    if (this.escapeHandler) {
      document.removeEventListener('keydown', this.escapeHandler);
    }
  }

  // ===============================================
  // SISTEMA DE ORGANIZACIÓN AUTOMÁTICA DE IMÁGENES
  // ===============================================

  /**
   * Normaliza un nombre para usarlo como nombre de carpeta
   * Elimina caracteres especiales, acentos y espacios
   */
  normalizarNombreCarpeta(texto) {
    if (!texto || texto.trim() === '') return '_SIN_NOMBRE';
    
    return texto
      .trim()
      .toUpperCase()
      // Reemplazar acentos
      .replace(/[áàäâ]/gi, 'A')
      .replace(/[éèëê]/gi, 'E')
      .replace(/[íìïî]/gi, 'I')
      .replace(/[óòöô]/gi, 'O')
      .replace(/[úùüû]/gi, 'U')
      .replace(/[ñ]/gi, 'N')
      // Solo alfanuméricos, espacios, guiones y guiones bajos
      .replace(/[^A-Z0-9\s_-]/g, '')
      // Espacios a guiones bajos
      .replace(/\s+/g, '_')
      // Múltiples guiones bajos a uno solo
      .replace(/_+/g, '_')
      // Máximo 50 caracteres
      .substring(0, 50);
  }

  /**
   * Genera un nombre de archivo descriptivo automáticamente
   * Formato: SAP_NOMBRE_TIMESTAMP_INDEX.webp
   */
  generarNombreArchivo(repuesto, imageIndex = 0) {
    // 1. Código SAP (máx 20 caracteres)
    const codigoSAP = (repuesto.codSAP || 'SAP_PENDIENTE')
      .replace(/[^a-zA-Z0-9_-]/g, '')
      .substring(0, 20);
    
    // 2. Nombre del repuesto (máx 40 caracteres)
    const nombreNormalizado = repuesto.nombre
      .toUpperCase()
      .trim()
      .replace(/[áàäâ]/gi, 'A')
      .replace(/[éèëê]/gi, 'E')
      .replace(/[íìïî]/gi, 'I')
      .replace(/[óòöô]/gi, 'O')
      .replace(/[úùüû]/gi, 'U')
      .replace(/[ñ]/gi, 'N')
      .replace(/[^A-Z0-9\s]/g, '') // Solo letras, números y espacios
      .replace(/\s+/g, '_')        // Espacios → guiones bajos
      .substring(0, 40);
    
    // 3. Timestamp único
    const timestamp = Date.now();
    
    // 4. Índice (si hay múltiples imágenes)
    const suffix = imageIndex > 0 ? `_${imageIndex + 1}` : '';
    
    // Resultado: SAP_NOMBRE_TIMESTAMP_INDEX.webp
    return `${codigoSAP}_${nombreNormalizado}_${timestamp}${suffix}.webp`;
  }

  /**
   * Genera la ruta jerárquica según la ubicación del repuesto
   */
  generarRutaImagen(ubicacion) {
    const partes = ['imagenes']; // Siempre empieza con /imagenes/
    
    // Nivel 1: Área General (OBLIGATORIO)
    if (ubicacion.areaGeneral && ubicacion.areaGeneral.trim() !== '') {
      partes.push(this.normalizarNombreCarpeta(ubicacion.areaGeneral));
    } else {
      partes.push('_SIN_UBICACION');
    }
    
    // Nivel 2: Sistema/Equipo (OPCIONAL - solo si nivelJerarquiaImagenes >= 2)
    if (this.nivelJerarquiaImagenes >= 2 && ubicacion.sistemaEquipo && ubicacion.sistemaEquipo.trim() !== '') {
      partes.push(this.normalizarNombreCarpeta(ubicacion.sistemaEquipo));
    }
    
    // Nivel 3: Sub-Sistema (OPCIONAL - solo si nivelJerarquiaImagenes >= 3)
    if (this.nivelJerarquiaImagenes >= 3 && ubicacion.subSistema && ubicacion.subSistema.trim() !== '') {
      partes.push(this.normalizarNombreCarpeta(ubicacion.subSistema));
    }
    
    return './' + partes.join('/');
  }

  /**
   * Crea las carpetas jerárquicas automáticamente si no existen
   */
  async crearCarpetasJerarquicas(ubicacion) {
    console.log('📁 Creando carpetas jerárquicas...', ubicacion);
    
    // VALIDACIÓN: Verificar que fsManager existe y está inicializado
    if (!this.fsManager) {
      console.error('❌ this.fsManager es undefined');
      throw new Error('FileSystemManager no está inicializado');
    }
    
    if (!this.fsManager.rootFolder) {
      console.error('❌ this.fsManager.rootFolder es undefined');
      console.error('   this.fsManager:', this.fsManager);
      throw new Error('Root folder no está disponible. ¿Conectaste la carpeta?');
    }
    
    try {
      // Obtener carpeta base de imágenes
      let carpetaActual = await this.fsManager.rootFolder.getDirectoryHandle('imagenes', { create: true });
      
      // Nivel 1: Área General
      const areaGeneral = ubicacion.areaGeneral && ubicacion.areaGeneral.trim() !== '' 
        ? this.normalizarNombreCarpeta(ubicacion.areaGeneral)
        : '_SIN_UBICACION';
      
      carpetaActual = await carpetaActual.getDirectoryHandle(areaGeneral, { create: true });
      console.log(`  ✅ Carpeta creada/verificada: ${areaGeneral}`);
      
      // Nivel 2: Sistema/Equipo (opcional)
      if (this.nivelJerarquiaImagenes >= 2 && ubicacion.sistemaEquipo && ubicacion.sistemaEquipo.trim() !== '') {
        const sistema = this.normalizarNombreCarpeta(ubicacion.sistemaEquipo);
        carpetaActual = await carpetaActual.getDirectoryHandle(sistema, { create: true });
        console.log(`  ✅ Subcarpeta creada/verificada: ${sistema}`);
      }
      
      // Nivel 3: Sub-Sistema (opcional)
      if (this.nivelJerarquiaImagenes >= 3 && ubicacion.subSistema && ubicacion.subSistema.trim() !== '') {
        const subSistema = this.normalizarNombreCarpeta(ubicacion.subSistema);
        carpetaActual = await carpetaActual.getDirectoryHandle(subSistema, { create: true });
        console.log(`  ✅ Subcarpeta creada/verificada: ${subSistema}`);
      }
      
      return carpetaActual;
      
    } catch (error) {
      console.error('❌ Error creando carpetas:', error);
      // Si falla, devolver carpeta raíz de imágenes
      return await this.fsManager.rootFolder.getDirectoryHandle('imagenes', { create: true });
    }
  }

  /**
   * Navega a una carpeta por su ruta completa
   */
  async navegarACarpeta(ruta) {
    const partes = ruta.replace('./', '').split('/');
    let carpeta = this.fsManager.rootFolder;
    
    for (const parte of partes) {
      carpeta = await carpeta.getDirectoryHandle(parte);
    }
    
    return carpeta;
  }

  /**
   * Limpia carpetas vacías (sin archivos)
   */
  async limpiarCarpetasVacias() {
    console.log('🧹 Limpiando carpetas vacías...');
    
    try {
      const carpetaImagenes = await this.fsManager.rootFolder.getDirectoryHandle('imagenes');
      
      // Obtener todas las subcarpetas (áreas)
      for await (const [nombre, handle] of carpetaImagenes.entries()) {
        if (handle.kind !== 'directory') continue;
        
        // Contar archivos en la carpeta
        let tieneArchivos = false;
        const carpeta = await carpetaImagenes.getDirectoryHandle(nombre);
        
        for await (const entry of carpeta.values()) {
          if (entry.kind === 'file') {
            tieneArchivos = true;
            break;
          }
        }
        
        // Si está vacía, eliminarla
        if (!tieneArchivos) {
          await carpetaImagenes.removeEntry(nombre, { recursive: true });
          console.log(`  🗑️ Carpeta vacía eliminada: ${nombre}`);
        }
      }
      
      console.log('✅ Limpieza completada');
    } catch (error) {
      console.error('❌ Error limpiando carpetas:', error);
    }
  }

  /**
   * Mueve imágenes a nueva carpeta si cambió la ubicación del repuesto
   */
  async moverImagenSiCambiaUbicacion(repuesto, ubicacionesAntiguas, ubicacionesNuevas) {
    if (!fsManager || !fsManager.isFileSystemMode) return;
    if (!ubicacionesAntiguas || !ubicacionesNuevas) return;
    if (ubicacionesAntiguas.length === 0 || ubicacionesNuevas.length === 0) return;
    
    console.log('🔄 Verificando si hay que mover imágenes...');
    
    // Comparar primera ubicación (la principal)
    const ubicacionAntigua = ubicacionesAntiguas[0];
    const ubicacionNueva = ubicacionesNuevas[0];
    
    // Verificar si cambió el área general
    const areaAntiguaNorm = this.normalizarNombreCarpeta(ubicacionAntigua.areaGeneral || '');
    const areaNuevaNorm = this.normalizarNombreCarpeta(ubicacionNueva.areaGeneral || '');
    
    if (areaAntiguaNorm === areaNuevaNorm) {
      console.log('  ℹ️ Área no cambió, no es necesario mover imágenes');
      return; // No cambió, no hacer nada
    }
    
    console.log(`  🚚 Área cambió: ${areaAntiguaNorm} → ${areaNuevaNorm}`);
    
    // Mover cada imagen
    let imagenesMovidas = 0;
    for (const media of repuesto.multimedia || []) {
      if (media.type !== 'image' || !media.isFileSystem) continue;
      
      try {
        // 1. Obtener nombre del archivo de la URL
        const nombreArchivo = media.url.split('/').pop();
        
        // 2. Obtener archivo de ubicación antigua
        const rutaAntigua = this.generarRutaImagen(ubicacionAntigua);
        const carpetaAntigua = await this.navegarACarpeta(rutaAntigua);
        const fileHandle = await carpetaAntigua.getFileHandle(nombreArchivo);
        const file = await fileHandle.getFile();
        
        // 3. Crear carpeta nueva (si no existe)
        const carpetaNueva = await this.crearCarpetasJerarquicas(ubicacionNueva);
        
        // 4. Copiar archivo a nueva ubicación
        const result = await this.fsManager.saveImageJerarquica(file, nombreArchivo, carpetaNueva);
        
        if (result) {
          // 5. Actualizar ruta en objeto multimedia
          const rutaNueva = this.generarRutaImagen(ubicacionNueva);
          media.url = `${rutaNueva}/${nombreArchivo}`;
          
          // 6. (Opcional) Eliminar archivo antiguo
          if (this.eliminarImagenAntiguaAlMover) {
            await carpetaAntigua.removeEntry(nombreArchivo);
            console.log(`  🗑️ Archivo antiguo eliminado: ${nombreArchivo}`);
          }
          
          imagenesMovidas++;
          console.log(`  ✅ Imagen movida: ${nombreArchivo}`);
        }
        
      } catch (error) {
        console.error(`  ❌ Error moviendo imagen:`, error);
        // Continuar con las demás imágenes
      }
    }
    
    if (imagenesMovidas > 0) {
      console.log(`✅ Total de imágenes movidas: ${imagenesMovidas}`);
      this.showToast(`✅ ${imagenesMovidas} imagen(es) movida(s) a nueva ubicación`, 'success');
      
      // Limpiar carpetas vacías
      await this.limpiarCarpetasVacias();
    }
  }

  // ========================================================================
  // 🔌 MÉTODO CENTRALIZADO DE CONEXIÓN - PUNTO ÚNICO DE ENTRADA
  // ========================================================================
  /**
   * Conecta la carpeta de trabajo y sincroniza TODOS los sistemas
   * Este es el ÚNICO método que debe usarse para conectar la carpeta
   * 
   * @param {boolean} isReconnect - true si es una reconexión automática
   * @param {boolean} promptUser - true si debe mostrar el selector de carpeta
   * @returns {Promise<boolean>} - true si la conexión fue exitosa
   */
  async connectWorkspace(isReconnect = false, promptUser = false) {
    try {
      console.log(`\n${'═'.repeat(60)}`);
      console.log(`🔌 CONEXIÓN CENTRALIZADA ${isReconnect ? '(AUTO-RECONEXIÓN)' : '(MANUAL)'}`);
      console.log(`${'═'.repeat(60)}\n`);
      
      let connected = false;
      
      // PASO 1: Conectar FileSystemManager
      if (promptUser) {
        // Usuario selecciona carpeta manualmente
        connected = await fsManager.selectFolder();
      } else {
        // Intentar reconectar automáticamente
        connected = await fsManager.restoreFromPreviousSession();
      }
      
      if (!connected) {
        console.log('❌ No se pudo conectar FileSystem');
        this.updateAllConnectionBadges(false);
        return false;
      }
      
      console.log('✅ FileSystem conectado:', fsManager.folderPath);
      
      // PASO 2: Inicializar MapStorage (si no está inicializado)
      if (typeof mapStorage !== 'undefined' && !mapStorage.initialized) {
        try {
          await mapStorage.init({ autoReconnect: false });
          console.log('✅ MapStorage inicializado');
        } catch (error) {
          console.warn('⚠️ Error inicializando MapStorage:', error);
        }
      }
      
      // PASO 3: Actualizar TODOS los badges de conexión
      this.updateAllConnectionBadges(true);
      
      // PASO 4: Cargar datos (solo si es primera conexión o si no hay datos)
      const needsDataLoad = !isReconnect || !this.repuestos || this.repuestos.length === 0;
      
      if (needsDataLoad) {
        console.log('🔄 Cargando datos desde carpeta...');
        await this.loadData();
        await this.render();
        this.showToast('✅ Carpeta conectada y datos cargados', 'success');
      } else {
        console.log('✅ Reconexión - Datos preservados en memoria');
        this.showToast('✅ Carpeta reconectada - Datos preservados', 'success');
      }
      
      console.log(`\n${'═'.repeat(60)}`);
      console.log('✅ CONEXIÓN COMPLETADA');
      console.log(`   📁 Carpeta: ${fsManager.folderPath}`);
      console.log(`   📊 Repuestos: ${this.repuestos.length}`);
      console.log(`   🗺️ MapStorage: ${mapStorage?.initialized ? 'Inicializado' : 'No inicializado'}`);
      console.log(`${'═'.repeat(60)}\n`);
      
      return true;
      
    } catch (error) {
      console.error('❌ Error en connectWorkspace:', error);
      this.updateAllConnectionBadges(false);
      this.showToast('❌ Error al conectar carpeta: ' + error.message, 'error');
      return false;
    }
  }

  /**
   * Actualiza TODOS los badges de conexión en la UI
   * @param {boolean} connected - Estado de conexión
   */
  updateAllConnectionBadges(connected) {
    const folderPath = connected ? (fsManager.folderPath || 'Conectada') : '';
    
    // 1. Badge del header principal (updateStatusIndicator de fsManager)
    if (typeof fsManager.updateStatusIndicator === 'function') {
      fsManager.updateStatusIndicator(connected, folderPath);
    }
    
    // 2. Badge de la pestaña Mapas (updateConnectionBadge de mapController)
    if (typeof mapController !== 'undefined' && mapController.updateConnectionBadge) {
      mapController.updateConnectionBadge();
      
      // 🎯 IMPORTANTE: Si MapStorage está inicializado, cargar datos del módulo de mapas
      if (connected && mapStorage?.initialized) {
        setTimeout(() => {
          mapController.loadData({ force: true }).catch(err => {
            console.warn('⚠️ Error cargando datos de mapas:', err);
          });
        }, 300);
      }
    }
    
    // 3. Badge de la pestaña Configuración (actualizarEstadoUI)
    // IMPORTANTE: setTimeout para asegurar que el HTML ya esté renderizado
    if (typeof configuracion !== 'undefined' && configuracion.actualizarEstadoUI) {
      setTimeout(() => {
        configuracion.actualizarEstadoUI();
      }, 200); // Esperar 200ms para que renderStorageUI haya terminado
    }
    
    // 4. Cualquier otro badge que se agregue en el futuro
    // (centralizado aquí para fácil mantenimiento)
    
    console.log(`📍 Badges actualizados: ${connected ? '🟢 CONECTADO' : '🔴 DESCONECTADO'}`);
  }

  async init() {
    this.showBrowserWarning();
    
    // 🧹 Limpiar backups obsoletos del sistema antiguo
    try {
      localStorage.removeItem('inventario_backups_marcadores');
      console.log('🧹 Limpieza: Backups antiguos de marcadores eliminados');
    } catch (e) {
      // Silenciar error
    }
    
    // Renderizar UI de almacenamiento según plataforma (PC o móvil)
    if (typeof configuracion !== 'undefined') {
      setTimeout(() => {
        configuracion.renderStorageUI();
        configuracion.loadICloudPathConfig(); // Cargar ruta iCloud guardada
      }, 100);
    }
    
    await this.loadData();
    this.setupEvents();
    this.setupDelegatedEvents(); // Event delegation para botones con data-attributes
    this.setupPhotoInputs(); // NUEVO: Configurar inputs de foto según plataforma
    this.applyViewModeStyles(); // Aplicar modo de visualización guardado
    this.updateViewModeInfo(); // Actualizar info del modo
    await this.render();
    this.renderFilters();
    
    // Cargar datos de autocompletado guardados o generar desde repuestos
    const savedAutocomplete = localStorage.getItem('autocompleteData');
    if (savedAutocomplete) {
      try {
        this.autocompleteData = JSON.parse(savedAutocomplete);
      } catch (e) {
        console.warn('Error cargando autocomplete guardado, regenerando...', e);
        this.updateAutocompleteData();
      }
    } else {
      this.updateAutocompleteData();
    }
    
    this.setupAutocomplete();
    
    // Setup listener para cambio de equipo (cargar sistemas)
    const equipoInput = document.getElementById('equipo');
    if (equipoInput) {
      equipoInput.addEventListener('blur', () => {
        const equipo = equipoInput.value.trim();
        if (equipo) {
          this.cargarSistemasPorEquipo(equipo);
        }
      });
    }
    
    // Log de plataforma y optimizaciones
    console.log(`\n${'='.repeat(60)}`);
    console.log(`📱 PLATAFORMA: ${this.isMobile ? 'MÓVIL' : 'PC'}`);
    console.log(`💾 ALMACENAMIENTO: ${this.storageMode.toUpperCase()}`);
    console.log(`📁 File System API: ${this.hasFileSystemAPI ? '✅ Disponible' : '❌ No disponible'}`);
    
    if (this.isEdge) {
      if (this.isEdgeIOS) {
        console.log(`🌐 NAVEGADOR: Microsoft Edge iOS (Modo Móvil)`);
        console.log('📱 Características activas:');
        console.log('  ✅ IndexedDB para imágenes (~50-100MB)');
        console.log('  📷 Captura de cámara directa');
        console.log('  🖼️ Selección de galería/iCloud Photos');
        console.log('  ✅ Sincronización vía JSON');
        console.log('  ⚠️ WebKit (limitado por Apple, no Chromium)');
      } else {
        console.log(`🌐 NAVEGADOR: Microsoft Edge (Optimizado)`);
        console.log('🚀 Optimizaciones activadas:');
        console.log('  ✅ CSS Grid avanzado');
        console.log('  ✅ Backdrop filters');
        console.log('  ✅ Container queries');
        console.log('  ✅ Scroll snap');
        if (this.hasFileSystemAPI) {
          console.log('  ✅ File System Access API completa');
        }
      }
    } else {
      console.log(`⚠️ NAVEGADOR: ${this.getBrowserName()} (No optimizado)`);
    }
    console.log(`${'='.repeat(60)}\n`);
  }

  // NUEVO: Configurar inputs de fotos según plataforma (móvil o PC)
  setupPhotoInputs() {
    const mobileButtons = document.getElementById('mobile-photo-buttons');
    const galleryInput = document.getElementById('galleryInput');
    const oldInput = document.getElementById('imagenFile');
    const multimediaSection = document.querySelector('.multimedia-section');
    
    // MÓVIL SIN FILESYSTEM: Ocultar toda la sección de multimedia
    if (this.isMobile && !this.hasFileSystemAPI) {
      console.log('📱 Modo Móvil Simplificado - Multimedia DESACTIVADA');
      
      // Ocultar toda la sección de multimedia
      if (multimediaSection) {
        multimediaSection.style.display = 'none';
      }
      
      // Crear mensaje informativo
      const multimediaParent = multimediaSection ? multimediaSection.parentElement : null;
      if (multimediaParent) {
        const existingMessage = document.getElementById('mobile-no-photos-message');
        if (!existingMessage) {
          const messageDiv = document.createElement('div');
          messageDiv.id = 'mobile-no-photos-message';
          messageDiv.style.cssText = `
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.1));
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid var(--info);
            margin: 16px 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
          `;
          messageDiv.innerHTML = `
            <strong style="color: var(--info); display: block; margin-bottom: 6px;">📱 Modo Móvil Simplificado</strong>
            Las fotos no están disponibles en dispositivos móviles.<br>
            <strong>Funciones activas:</strong> Ver, Agregar, Editar, Eliminar, Conteo.
            <br><br>
            💡 <strong>Para fotos:</strong> Usa la versión de PC con todas las funcionalidades.
          `;
          multimediaSection.parentNode.insertBefore(messageDiv, multimediaSection);
        }
      }
      
      return; // Salir - no configurar inputs de fotos
    }
    
    // MÓVIL CON FILESYSTEM (no debería pasar, pero por si acaso)
    if (this.isMobile && this.hasFileSystemAPI) {
      // MÓVIL: Mostrar botones cámara + galería
      if (mobileButtons) {
        mobileButtons.style.display = 'flex';
      }
      if (galleryInput) {
        galleryInput.style.display = 'none'; // Ocultar input directo
      }
      if (oldInput) {
        oldInput.style.display = 'none';
      }
      if (multimediaSection) {
        multimediaSection.style.display = 'block';
      }
      console.log('📱 Inputs de foto configurados para MÓVIL (Cámara + Galería)');
    } 
    // PC: Mostrar todo normalmente
    else {
      // PC: Mostrar solo input de galería (sin botones)
      if (mobileButtons) {
        mobileButtons.style.display = 'none';
      }
      if (galleryInput) {
        galleryInput.style.display = 'block'; // Mostrar input directo
      }
      if (oldInput) {
        oldInput.style.display = 'none';
      }
      if (multimediaSection) {
        multimediaSection.style.display = 'block';
      }
      console.log('💻 Inputs de foto configurados para PC (Galería)');
    }
  }

  // Event delegation para manejar todos los clicks en botones con data-action
  setupDelegatedEvents() {
    // Clicks en botones
    document.addEventListener('click', (e) => {
      const target = e.target.closest('[data-action]');
      if (!target) return;
      
      const action = target.dataset.action;
      const id = target.dataset.id;
      
      if (action === 'edit') {
        this.openModal('edit', id);
      } else if (action === 'delete') {
        if (confirm('¿Eliminar este repuesto?')) {
          this.deleteRepuesto(id);
        }
      } else if (action === 'lightbox') {
        console.log('🖼️ Abriendo lightbox para ID:', id);
        this.openLightbox(id);
      } else if (action === 'contar') {
        this.abrirModalConteoIndividual(id);
      } else if (action === 'goto-card') {
        this.irATarjeta(id);
      } else if (action === 'verMapa') {
        // 🗺️ ETAPA 5: Ver repuesto en mapa
        this.verRepuestoEnMapa(id);
      }
    });

    // Change events en inputs (conteo)
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (!target.dataset || !target.dataset.action) return;
      
      const action = target.dataset.action;
      const id = target.dataset.id;
      
      if (action === 'update-conteo') {
        this.updateConteo(id, target.value);
      }
    });

    // Listener para teclado - controles del lightbox
    document.addEventListener('keydown', (e) => {
      const lightbox = document.getElementById('lightbox');
      const isLightboxActive = lightbox && lightbox.classList.contains('active');
      
      if (!isLightboxActive) return;
      
      // ESC - Cerrar lightbox
      if (e.key === 'Escape' || e.key === 'Esc') {
        console.log('⌨️ ESC presionado - cerrando lightbox');
        this.closeLightbox();
        return;
      }
      
      // Flecha IZQUIERDA - Imagen anterior
      if (e.key === 'ArrowLeft' || e.key === 'Left') {
        console.log('⌨️ ← Flecha izquierda - imagen anterior');
        e.preventDefault(); // Evitar scroll de página
        this.lightboxPrev();
        return;
      }
      
      // Flecha DERECHA - Imagen siguiente
      if (e.key === 'ArrowRight' || e.key === 'Right') {
        console.log('⌨️ → Flecha derecha - imagen siguiente');
        e.preventDefault(); // Evitar scroll de página
        this.lightboxNext();
        return;
      }
    });
  }

  async cleanBase64ImagesFromLocalStorage() {
    // Limpiar imágenes base64 del localStorage cuando estamos en modo FileSystem
    if (!fsManager.isFileSystemMode) return;
    
    try {
      const localData = localStorage.getItem('inventarioData');
      if (!localData) return;
      
      const data = JSON.parse(localData);
      let limpiadas = 0;
      let tamañoAntes = new Blob([localData]).size;
      
      // Eliminar todas las imágenes base64
      data.forEach(item => {
        if (item.multimedia && item.multimedia.length > 0) {
          const multimediaLimpia = item.multimedia.filter(media => {
            const esBase64 = media.url && media.url.startsWith('data:image');
            if (esBase64) {
              limpiadas++;
              console.log(`🧹 Limpiando base64 de: ${item.nombre}`);
            }
            return !esBase64; // Mantener solo rutas de FileSystem
          });
          item.multimedia = multimediaLimpia;
        }
      });
      
      if (limpiadas > 0) {
        const datosLimpios = JSON.stringify(data);
        localStorage.setItem('inventarioData', datosLimpios);
        
        const tamañoDespues = new Blob([datosLimpios]).size;
        const liberado = ((tamañoAntes - tamañoDespues) / 1024).toFixed(2);
        
        console.log(`🧹 Limpiadas ${limpiadas} imágenes base64 del localStorage (${liberado} KB liberados)`);
      } else {
        console.log('✅ localStorage ya está limpio (no hay imágenes base64)');
      }
    } catch (error) {
      console.warn('⚠️ Error limpiando localStorage:', error);
    }
  }

  // 🔧 REPARAR imágenes rotas (rutas que ya no existen)
  async repararImagenesRotas() {
    if (!fsManager.isFileSystemMode || !fsManager.imagesFolder) {
      console.warn('⚠️ FileSystem no disponible para reparar imágenes');
      return;
    }

    try {
      console.log('🔧 Iniciando reparación de imágenes rotas...');
      
      // 1. Obtener TODAS las imágenes disponibles en la carpeta
      const imagenesDisponibles = [];
      for await (const entry of fsManager.imagesFolder.values()) {
        if (entry.kind === 'file') {
          const name = entry.name.toLowerCase();
          if (name.match(/\.(jpg|jpeg|png|webp|gif)$/i)) {
            imagenesDisponibles.push(entry.name);
          }
        }
      }
      
      console.log(`📸 Disponibles: ${imagenesDisponibles.length} imágenes en carpeta`);
      
      let reparadas = 0;
      let eliminadas = 0;
      
      // SOLO VERIFICAR Y REPARAR REPUESTOS QUE YA TIENEN IMÁGENES
      for (const repuesto of this.repuestos) {
        if (!repuesto.multimedia || repuesto.multimedia.length === 0) {
          // No tiene imágenes, NO hacer nada (no vincular automáticamente)
          continue;
        }
        
        // Tiene imágenes, verificar si existen
        const multimediaReparada = [];
        
        for (const media of repuesto.multimedia) {
          if (media.type !== 'image') {
            multimediaReparada.push(media); // Mantener documentos sin cambios
            continue;
          }
          
          // Extraer nombre de archivo de la URL
          let nombreArchivo = media.url;
          if (nombreArchivo.startsWith('./imagenes/')) {
            nombreArchivo = nombreArchivo.substring(11);
          } else if (nombreArchivo.startsWith('imagenes/')) {
            nombreArchivo = nombreArchivo.substring(9);
          }
          
          // Verificar si el archivo existe
          try {
            await fsManager.imagesFolder.getFileHandle(nombreArchivo);
            // Existe, mantener
            multimediaReparada.push(media);
          } catch (error) {
            // NO existe, buscar reemplazo
            console.log(`  ❌ Imagen rota: ${nombreArchivo}`);
            
            // Buscar imagen similar por nombre de repuesto
            const imagenReemplazo = await this.buscarImagenPorNombre(repuesto.nombre, imagenesDisponibles);
            
            if (imagenReemplazo) {
              const fileHandle = await fsManager.imagesFolder.getFileHandle(imagenReemplazo);
              const file = await fileHandle.getFile();
              
              multimediaReparada.push({
                type: 'image',
                url: `./imagenes/${imagenReemplazo}`,
                name: imagenReemplazo,
                size: file.size,
                isFileSystem: true
              });
              
              reparadas++;
              console.log(`  🔧 Reparada: ${nombreArchivo} → ${imagenReemplazo}`);
            } else {
              // NO se encontró reemplazo, eliminar referencia rota
              console.log(`  🗑️ Eliminando referencia rota: ${nombreArchivo}`);
              eliminadas++;
            }
          }
        }
        
        repuesto.multimedia = multimediaReparada;
      }
      
      console.log(`✅ Reparación completada:`);
      console.log(`   🔧 Imágenes reparadas: ${reparadas}`);
      console.log(`   🗑️ Referencias rotas eliminadas: ${eliminadas}`);
      
      // Guardar cambios si hubo modificaciones
      if (reparadas > 0 || eliminadas > 0) {
        await this.saveData();
        this.showToast(`✅ ${reparadas} reparadas, ${eliminadas} referencias rotas eliminadas`, 'success');
        this.actualizarVistaActual();
      } else {
        this.showToast('✅ No se encontraron imágenes rotas', 'info');
      }
      
    } catch (error) {
      console.error('❌ Error reparando imágenes:', error);
      this.showToast('❌ Error al reparar imágenes', 'error');
    }
  }

  // Buscar imagen por nombre de repuesto (inteligente)
  async buscarImagenPorNombre(nombreRepuesto, imagenesDisponibles) {
    const nombreNorm = nombreRepuesto.toUpperCase().trim().replace(/\s+/g, '_');
    
    // Estrategia 1: Buscar por nombre exacto
    let encontrada = imagenesDisponibles.find(img => {
      const imgNorm = img.replace(/\.(jpg|jpeg|png|webp|gif)$/i, '').toUpperCase().replace(/\s+/g, '_');
      return imgNorm === nombreNorm;
    });
    
    if (encontrada) return encontrada;
    
    // Estrategia 2: Buscar que contenga el nombre del repuesto
    encontrada = imagenesDisponibles.find(img => {
      const imgNorm = img.toUpperCase();
      // Buscar palabras clave del nombre del repuesto
      const palabras = nombreNorm.split('_').filter(p => p.length > 3);
      return palabras.every(palabra => imgNorm.includes(palabra));
    });
    
    if (encontrada) return encontrada;
    
    // Estrategia 3: Buscar por timestamp más reciente con coincidencia parcial
    const coincidenciasParciales = imagenesDisponibles.filter(img => {
      const imgNorm = img.toUpperCase();
      const palabras = nombreNorm.split('_').filter(p => p.length > 3);
      return palabras.some(palabra => imgNorm.includes(palabra));
    });
    
    if (coincidenciasParciales.length > 0) {
      // Ordenar por timestamp (más reciente primero)
      coincidenciasParciales.sort((a, b) => {
        const timestampA = parseInt(a.match(/^(\d+)_/)?.[1] || '0');
        const timestampB = parseInt(b.match(/^(\d+)_/)?.[1] || '0');
        return timestampB - timestampA; // Más reciente primero
      });
      
      return coincidenciasParciales[0];
    }
    
    return null;
  }

  // Vincular imágenes automáticamente SIN confirmación (versión silenciosa)
  async vincularImagenesSilencioso() {
    // Esta función ahora solo repara referencias rotas, NO vincula nuevas imágenes
    // Para vincular nuevas imágenes, usar el botón manual desde CONFIGURACIÓN
    try {
      await this.repararImagenesRotas();
    } catch (error) {
      console.error('Error en reparación silenciosa:', error);
      // NO mostrar toast para no molestar al usuario
    }
  }

  async loadData() {
    // PRIORIDAD 1: Intentar cargar desde FileSystem si está activo
    if (fsManager.isFileSystemMode) {
      console.log('⌕ Modo FileSystem activo, intentando cargar desde archivo...');
      try {
        const fileHandle = await fsManager.directoryHandle.getFileHandle('inventario.json');
        const file = await fileHandle.getFile();
        const content = await file.text();
        const rawData = JSON.parse(content);
        
        console.log(`✅ Cargados ${rawData.length} repuestos desde FileSystem`);
        this.repuestos = rawData.map((item, index) => {
          if (!item.id || item.id === 'undefined' || item.id === 'null') {
            item.id = `repuesto-${Date.now()}-${index}`;
          } else {
            item.id = String(item.id);
          }
          if (!item.multimedia || !Array.isArray(item.multimedia)) {
            item.multimedia = [];
          }
          return item;
        });
        
        // 🧹 LIMPIEZA AUTOMÁTICA: Eliminar formato antiguo de ubicaciones si existe el nuevo
        this.limpiarFormatoAntiguoUbicaciones();
        
        // 🔍 DIAGNÓSTICO: Contar repuestos con/sin imágenes
        const conImagenes = this.repuestos.filter(r => r.multimedia && r.multimedia.length > 0).length;
        const sinImagenes = this.repuestos.length - conImagenes;
        console.log(`📊 [DIAGNÓSTICO] Repuestos CON imágenes: ${conImagenes}`);
        console.log(`📊 [DIAGNÓSTICO] Repuestos SIN imágenes: ${sinImagenes}`);
        
        // ⚠️ VINCULACIÓN AUTOMÁTICA DESACTIVADA
        // Se ha desactivado la vinculación automática de imágenes al cargar
        // para evitar duplicaciones y errores. Usar el botón manual si es necesario.
        
        this.loadMapData();
        return; // Salir, ya cargamos desde FileSystem
      } catch (error) {
        console.warn('⚠️ No se pudo cargar desde FileSystem:', error.message);
        console.log('Intentando cargar desde localStorage como fallback...');
      }
    }
    
    // PRIORIDAD 2: MÓVIL SIN FILESYSTEM - Cargar desde datos embebidos
    if (this.isMobile && !this.hasFileSystemAPI) {
      console.log('📱 Modo Móvil detectado - Cargando desde datos embebidos...');
      
      // Verificar si hay datos embebidos
      if (typeof EMBEDDED_DATA !== 'undefined' && EMBEDDED_DATA.repuestos && EMBEDDED_DATA.repuestos.length > 0) {
        console.log(`✅ Cargados ${EMBEDDED_DATA.repuestos.length} repuestos desde datos embebidos`);
        
        this.repuestos = EMBEDDED_DATA.repuestos.map((item, index) => {
          if (!item.id || item.id === 'undefined' || item.id === 'null') {
            item.id = `repuesto-${Date.now()}-${index}`;
          } else {
            item.id = String(item.id);
          }
          // ⚠️ IMPORTANTE: Forzar multimedia vacío en móvil
          item.multimedia = [];
          return item;
        });
        
        // 🧹 LIMPIEZA AUTOMÁTICA: Eliminar formato antiguo de ubicaciones si existe el nuevo
        this.limpiarFormatoAntiguoUbicaciones();
        
        console.log(`📱 Modo Móvil Simplificado: ${this.repuestos.length} repuestos sin multimedia`);
        console.log(`📅 Última actualización: ${EMBEDDED_DATA.lastUpdate || 'Desconocida'}`);
        
        // Guardar en localStorage para ediciones locales
        localStorage.setItem('inventarioData', JSON.stringify(this.repuestos));
        
        this.loadMapData();
        return; // Salir, ya cargamos desde datos embebidos
      } else {
        console.warn('⚠️ No hay datos embebidos, intentando localStorage...');
      }
    }
    
    // FALLBACK: Cargar desde localStorage
    const saved = localStorage.getItem('inventarioData');
    if (saved) {
      try {
        const rawData = JSON.parse(saved);
        console.log(`Cargando ${rawData.length} repuestos desde localStorage`);
        
        // NORMALIZAR IDs: Asegurar que todos los repuestos tengan IDs válidos
        this.repuestos = rawData.map((item, index) => {
          // Si no tiene ID o es inválido, generar uno nuevo
          if (!item.id || item.id === 'undefined' || item.id === 'null') {
            item.id = `repuesto-${Date.now()}-${index}`;
            console.log(`🆔 ID generado para "${item.nombre}": ${item.id}`);
          } else {
            // Convertir ID a string para consistencia
            item.id = String(item.id);
          }
          
          // Asegurar que multimedia existe como array
          if (!item.multimedia || !Array.isArray(item.multimedia)) {
            item.multimedia = [];
          }
          
          return item;
        });
        
        console.log(`✅ ${this.repuestos.length} repuestos cargados correctamente`);
        
        // 🧹 LIMPIEZA AUTOMÁTICA: Eliminar formato antiguo de ubicaciones si existe el nuevo
        this.limpiarFormatoAntiguoUbicaciones();
        
        // Verificar IDs únicos
        const idsSet = new Set(this.repuestos.map(r => r.id));
        if (idsSet.size !== this.repuestos.length) {
          console.warn('⚠️ Se detectaron IDs duplicados, regenerando...');
          this.repuestos = this.repuestos.map((r, i) => {
            r.id = `repuesto-${Date.now()}-${i}`;
            return r;
          });
          this.saveData(); // Guardar con IDs corregidos
        }
        
      } catch (e) {
        console.error('❌ Error al cargar datos:', e);
        this.loadDefaultData();
      }
    } else {
      console.log('📭 Sin datos guardados, iniciando vacío');
      this.loadDefaultData();
    }
    
    this.loadMapData();
  }

  loadMapData() {
    const savedMap = localStorage.getItem('mapData');
    if (savedMap) {
      try {
        this.mapObjects = JSON.parse(savedMap);
      } catch (e) {
        this.mapObjects = [];
      }
    }
    
    const savedMapImage = localStorage.getItem('mapImage');
    if (savedMapImage) {
      this.mapImage = savedMapImage;
    }
  }

  // 🧹 NUEVA FUNCIÓN: Limpiar formato antiguo de ubicaciones para evitar duplicados en mapas
  limpiarFormatoAntiguoUbicaciones() {
    let limpiados = 0;
    
    this.repuestos.forEach(repuesto => {
      // Si tiene ubicaciones[] Y también propiedades antiguas, eliminar las antiguas
      if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones) && repuesto.ubicaciones.length > 0) {
        if (repuesto.mapId || repuesto.markerX || repuesto.markerY || repuesto.areaId) {
          console.log(`🧹 Limpiando formato antiguo de "${repuesto.nombre}"`);
          delete repuesto.mapId;
          delete repuesto.areaId;
          delete repuesto.markerX;
          delete repuesto.markerY;
          delete repuesto.ubicacionDescripcion;
          limpiados++;
        }
      }
    });
    
    if (limpiados > 0) {
      console.log(`✅ Limpiados ${limpiados} repuestos con formato antiguo duplicado`);
      // Guardar cambios automáticamente
      this.saveData().catch(err => console.error('Error guardando limpieza:', err));
    }
  }

  loadDefaultData() {
    // 🧪 DATOS DE PRUEBA: 2 repuestos por cada nivel de jerarquía
    this.repuestos = [
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 1: Solo Planta (mínimo)
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 1,
        nombre: 'Extintor Polvo Químico ABC 10kg',
        codSAP: 'EXT-001',
        codProv: 'PROV-EXT-001',
        cantidad: 15,
        minimo: 10,
        optimo: 20,
        precio: 45000,
        planta: 'Aquachile Antarfood Chonchi',
        descripcion: 'Extintor tipo ABC para fuegos clase A, B y C',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 2,
        nombre: 'Botiquín Primeros Auxilios Completo',
        codSAP: 'BOT-001',
        codProv: 'PROV-BOT-001',
        cantidad: 8,
        minimo: 5,
        optimo: 12,
        precio: 35000,
        planta: 'Aquachile Antarfood Chonchi',
        descripcion: 'Botiquín con elementos básicos de primeros auxilios',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 2: Planta + Área General
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 3,
        nombre: 'Válvula Mariposa 6 Pulgadas',
        codSAP: 'VAL-MA-006',
        codProv: 'PROV-VAL-006',
        cantidad: 12,
        minimo: 8,
        optimo: 15,
        precio: 125000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        descripcion: 'Válvula mariposa para control de flujo en tuberías principales',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 4,
        nombre: 'Sensor de Temperatura PT100',
        codSAP: 'SEN-TMP-100',
        codProv: 'PROV-SEN-100',
        cantidad: 20,
        minimo: 15,
        optimo: 25,
        precio: 28000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        descripcion: 'Sensor de temperatura tipo PT100 rango -50°C a +200°C',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 3: Planta + Área General + Sub-Área
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 5,
        nombre: 'Filtro de Cartucho 5 Micras',
        codSAP: 'FIL-CAR-005',
        codProv: 'PROV-FIL-005',
        cantidad: 30,
        minimo: 20,
        optimo: 40,
        precio: 15000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        descripcion: 'Cartucho de filtro de 5 micras para agua de proceso',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 6,
        nombre: 'Bomba Centrífuga 5HP',
        codSAP: 'BOM-CEN-5HP',
        codProv: 'PROV-BOM-5HP',
        cantidad: 4,
        minimo: 2,
        optimo: 6,
        precio: 450000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        descripcion: 'Bomba centrífuga 5HP para recirculación de agua',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 4: Planta + Área General + Sub-Área + Sistema/Equipo
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 7,
        nombre: 'Rodamiento SKF 6205-2RS',
        codSAP: 'ROD-SKF-6205',
        codProv: 'SKF-6205-2RS',
        cantidad: 25,
        minimo: 15,
        optimo: 30,
        precio: 18500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        descripcion: 'Rodamiento rígido de bolas con sellos de goma',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 8,
        nombre: 'Sello Mecánico 25mm',
        codSAP: 'SEL-MEC-025',
        codProv: 'PROV-SEL-025',
        cantidad: 8,
        minimo: 5,
        optimo: 12,
        precio: 65000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        descripcion: 'Sello mecánico para eje de 25mm en bombas',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 5: Planta + Área General + Sub-Área + Sistema/Equipo + Sub-Sistema
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 9,
        nombre: 'Impulsor de Bomba Acero Inox',
        codSAP: 'IMP-BOM-INOX',
        codProv: 'PROV-IMP-INOX',
        cantidad: 6,
        minimo: 3,
        optimo: 8,
        precio: 185000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        descripcion: 'Impulsor de acero inoxidable 316L para bomba centrífuga',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 10,
        nombre: 'Carcasa de Bomba Con Bridas',
        codSAP: 'CAR-BOM-BRID',
        codProv: 'PROV-CAR-BRID',
        cantidad: 3,
        minimo: 2,
        optimo: 5,
        precio: 320000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        descripcion: 'Carcasa de bomba centrífuga con bridas de conexión',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 6: Planta + Área General + Sub-Área + Sistema/Equipo + Sub-Sistema + Sección
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 11,
        nombre: 'O-Ring Viton 25x3mm',
        codSAP: 'ORI-VIT-25X3',
        codProv: 'PROV-ORI-25X3',
        cantidad: 50,
        minimo: 30,
        optimo: 60,
        precio: 3500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        descripcion: 'O-Ring de Viton para sellado de alta temperatura',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 12,
        nombre: 'Junta Tapa Bomba Teflón',
        codSAP: 'JUN-TAP-TEF',
        codProv: 'PROV-JUN-TEF',
        cantidad: 15,
        minimo: 10,
        optimo: 20,
        precio: 8500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        descripcion: 'Junta de teflón para tapa de bomba centrífuga',
        multimedia: [],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 7: Todos los campos (Jerarquía Completa)
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: 13,
        nombre: 'Tornillo Allen M8x40 Inox A4',
        codSAP: 'TOR-ALL-M8X40',
        codProv: 'DIN912-M8X40-A4',
        cantidad: 100,
        minimo: 50,
        optimo: 150,
        precio: 450,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        detalle: 'Conjunto de Fijación',
        descripcion: 'Tornillo allen cabeza cilíndrica M8x40mm acero inox A4-70',
        multimedia: [],
        ubicaciones: []
      },
      {
        id: 14,
        nombre: 'Arandela Presión M8 Inox',
        codSAP: 'ARA-PRE-M8',
        codProv: 'DIN127-M8-INOX',
        cantidad: 150,
        minimo: 80,
        optimo: 200,
        precio: 150,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        detalle: 'Conjunto de Fijación',
        descripcion: 'Arandela de presión (grower) M8 acero inoxidable',
        multimedia: [],
        ubicaciones: []
      }
    ];

    console.log('🧪 Datos de prueba cargados: 14 repuestos con jerarquía completa');
    console.log('📊 Cobertura: 2 repuestos por cada nivel (1-7)');
  }

  // 🧪 Cargar datos de prueba para visualizar jerarquía en PDF
  async cargarDatosPrueba() {
    if (!confirm('🧪 AGREGAR DATOS DE PRUEBA\n\n¿Deseas agregar 14 repuestos de prueba a tus datos existentes?\n\nTus ' + this.repuestos.length + ' repuestos actuales NO se borrarán.\n\nLos datos de prueba tendrán IDs desde 9000 en adelante para fácil identificación.')) {
      return;
    }

    // Obtener el siguiente ID disponible (usar serie 9000 para identificar datos de prueba)
    const testIdBase = 9000;
    
    // Crear datos de prueba con IDs únicos
    const datosPrueba = [
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 1: Solo Planta (mínimo)
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 1,
        nombre: '🧪 Extintor Polvo Químico ABC 10kg',
        codSAP: 'TEST-EXT-001',
        codProv: 'TEST-PROV-EXT-001',
        cantidad: 15,
        minimo: 10,
        optimo: 20,
        precio: 45000,
        planta: 'Aquachile Antarfood Chonchi',
        descripcion: '🧪 TEST - Extintor tipo ABC para fuegos clase A, B y C',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/FF6B35/FFFFFF?text=Extintor+ABC',
          nombre: 'extintor_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 2,
        nombre: '🧪 Botiquín Primeros Auxilios Completo',
        codSAP: 'TEST-BOT-001',
        codProv: 'TEST-PROV-BOT-001',
        cantidad: 8,
        minimo: 5,
        optimo: 12,
        precio: 35000,
        planta: 'Aquachile Antarfood Chonchi',
        descripcion: '🧪 TEST - Botiquín con elementos básicos de primeros auxilios',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/4ECDC4/FFFFFF?text=Botiquin',
          nombre: 'botiquin_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 2: Planta + Área General
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 3,
        nombre: '🧪 Válvula Mariposa 6 Pulgadas',
        codSAP: 'TEST-VAL-MA-006',
        codProv: 'TEST-PROV-VAL-006',
        cantidad: 12,
        minimo: 8,
        optimo: 15,
        precio: 125000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        descripcion: '🧪 TEST - Válvula mariposa para control de flujo',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/F7B731/FFFFFF?text=Valvula+Mariposa',
          nombre: 'valvula_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 4,
        nombre: '🧪 Sensor de Temperatura PT100',
        codSAP: 'TEST-SEN-TMP-100',
        codProv: 'TEST-PROV-SEN-100',
        cantidad: 20,
        minimo: 15,
        optimo: 25,
        precio: 28000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        descripcion: '🧪 TEST - Sensor PT100 rango -50°C a +200°C',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/5F27CD/FFFFFF?text=Sensor+PT100',
          nombre: 'sensor_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 3: Planta + Área General + Sub-Área
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 5,
        nombre: '🧪 Filtro de Cartucho 5 Micras',
        codSAP: 'TEST-FIL-CAR-005',
        codProv: 'TEST-PROV-FIL-005',
        cantidad: 30,
        minimo: 20,
        optimo: 40,
        precio: 15000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        descripcion: '🧪 TEST - Cartucho de filtro de 5 micras',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/00B894/FFFFFF?text=Filtro+5um',
          nombre: 'filtro_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 6,
        nombre: '🧪 Bomba Centrífuga 5HP',
        codSAP: 'TEST-BOM-CEN-5HP',
        codProv: 'TEST-PROV-BOM-5HP',
        cantidad: 4,
        minimo: 2,
        optimo: 6,
        precio: 450000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        descripcion: '🧪 TEST - Bomba centrífuga 5HP',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/0984E3/FFFFFF?text=Bomba+5HP',
          nombre: 'bomba_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 4: Planta + Área General + Sub-Área + Sistema/Equipo
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 7,
        nombre: '🧪 Rodamiento SKF 6205-2RS',
        codSAP: 'TEST-ROD-SKF-6205',
        codProv: 'TEST-SKF-6205-2RS',
        cantidad: 25,
        minimo: 15,
        optimo: 30,
        precio: 18500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        descripcion: '🧪 TEST - Rodamiento rígido de bolas',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/6C5CE7/FFFFFF?text=Rodamiento+SKF',
          nombre: 'rodamiento_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 8,
        nombre: '🧪 Sello Mecánico 25mm',
        codSAP: 'TEST-SEL-MEC-025',
        codProv: 'TEST-PROV-SEL-025',
        cantidad: 8,
        minimo: 5,
        optimo: 12,
        precio: 65000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        descripcion: '🧪 TEST - Sello mecánico para eje 25mm',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/FD79A8/FFFFFF?text=Sello+Mecanico',
          nombre: 'sello_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 5: Planta + Área General + Sub-Área + Sistema/Equipo + Sub-Sistema
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 9,
        nombre: '🧪 Impulsor de Bomba Acero Inox',
        codSAP: 'TEST-IMP-BOM-INOX',
        codProv: 'TEST-PROV-IMP-INOX',
        cantidad: 6,
        minimo: 3,
        optimo: 8,
        precio: 185000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        descripcion: '🧪 TEST - Impulsor acero inoxidable 316L',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/A29BFE/FFFFFF?text=Impulsor+Inox',
          nombre: 'impulsor_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 10,
        nombre: '🧪 Carcasa de Bomba Con Bridas',
        codSAP: 'TEST-CAR-BOM-BRID',
        codProv: 'TEST-PROV-CAR-BRID',
        cantidad: 3,
        minimo: 2,
        optimo: 5,
        precio: 320000,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        descripcion: '🧪 TEST - Carcasa con bridas de conexión',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/74B9FF/FFFFFF?text=Carcasa+Bomba',
          nombre: 'carcasa_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 6: Planta + Área General + Sub-Área + Sistema/Equipo + Sub-Sistema + Sección
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 11,
        nombre: '🧪 O-Ring Viton 25x3mm',
        codSAP: 'TEST-ORI-VIT-25X3',
        codProv: 'TEST-PROV-ORI-25X3',
        cantidad: 50,
        minimo: 30,
        optimo: 60,
        precio: 3500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        descripcion: '🧪 TEST - O-Ring Viton alta temperatura',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/55EFC4/000000?text=O-Ring+Viton',
          nombre: 'oring_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 12,
        nombre: '🧪 Junta Tapa Bomba Teflón',
        codSAP: 'TEST-JUN-TAP-TEF',
        codProv: 'TEST-PROV-JUN-TEF',
        cantidad: 15,
        minimo: 10,
        optimo: 20,
        precio: 8500,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        descripcion: '🧪 TEST - Junta de teflón para tapa',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/FFEAA7/000000?text=Junta+Teflon',
          nombre: 'junta_test.jpg'
        }],
        ubicaciones: []
      },

      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // NIVEL 7: Todos los campos (Jerarquía Completa)
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      {
        id: testIdBase + 13,
        nombre: '🧪 Tornillo Allen M8x40 Inox A4',
        codSAP: 'TEST-TOR-ALL-M8X40',
        codProv: 'TEST-DIN912-M8X40-A4',
        cantidad: 100,
        minimo: 50,
        optimo: 150,
        precio: 450,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        detalle: 'Conjunto de Fijación',
        descripcion: '🧪 TEST - Tornillo allen M8x40mm inox A4-70',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/DFE6E9/000000?text=Tornillo+M8x40',
          nombre: 'tornillo_test.jpg'
        }],
        ubicaciones: []
      },
      {
        id: testIdBase + 14,
        nombre: '🧪 Arandela Presión M8 Inox',
        codSAP: 'TEST-ARA-PRE-M8',
        codProv: 'TEST-DIN127-M8-INOX',
        cantidad: 150,
        minimo: 80,
        optimo: 200,
        precio: 150,
        planta: 'Aquachile Antarfood Chonchi',
        areaGeneral: 'Área de Producción',
        subArea: 'Sistema de Agua',
        sistemaEquipo: 'Bomba Principal BP-01',
        subSistema: 'Sistema Hidráulico',
        seccion: 'Sección de Sellado',
        detalle: 'Conjunto de Fijación',
        descripcion: '🧪 TEST - Arandela grower M8 inoxidable',
        multimedia: [{
          tipo: 'imagen',
          url: 'https://via.placeholder.com/400x300/B2BEC3/000000?text=Arandela+M8',
          nombre: 'arandela_test.jpg'
        }],
        ubicaciones: []
      }
    ];

    // Agregar datos de prueba a los existentes
    this.repuestos.push(...datosPrueba);
    
    // Guardar automáticamente
    await this.saveData();
    
    // Renderizar
    this.renderRepuestos();
    
    // Mostrar confirmación
    this.mostrarToast('✅ 14 repuestos de prueba agregados con éxito\n\n🔍 Búscalos con el emoji 🧪 o con IDs 9001-9014\n💾 Datos guardados automáticamente', 'success', 6000);
    
    console.log('✅ Datos de prueba agregados. Total repuestos:', this.repuestos.length);
    console.log('🧪 IDs de prueba: 9001-9014');
  }

  async saveData() {
    // 💾 Mostrar indicador de guardado
    const toastId = this.showToast('💾 Guardando...', 'info', 10000);
    
    try {
      // 📱 MÓVIL: Actualizar EMBEDDED_DATA automáticamente
      if (this.isMobile && !this.hasFileSystemAPI && typeof EMBEDDED_DATA !== 'undefined') {
        console.log('📱 Actualizando EMBEDDED_DATA en memoria...');
        EMBEDDED_DATA.repuestos = this.repuestos.map(r => {
          const { multimedia, ...sinMultimedia } = r;
          return sinMultimedia;
        });
        EMBEDDED_DATA.lastUpdate = new Date().toISOString();
        console.log('✅ EMBEDDED_DATA actualizado:', EMBEDDED_DATA.repuestos.length, 'repuestos');
      }

      // MODO FILESYSTEM: Guardar en archivo
      if (fsManager.isFileSystemMode) {
        console.log('Guardando en FileSystem...');
        const success = await fsManager.saveJSON(this.repuestos);
        if (success !== false) {
          this.showToast('Guardado en carpeta (sin límites)', 'success', 2000);
          console.log('✅ Datos guardados en FileSystem');
          
          // 🔄 MARCAR QUE HAY CAMBIOS PENDIENTES DE BACKUP (no crear backup inmediatamente)
          if (configuracion && configuracion.backupManager) {
            configuracion.backupManager.marcarCambiosPendientes();
          }
          
          return true;
        }
        // Si falla FileSystem, continuar con localStorage como fallback
        console.warn('⚠️ FileSystem falló, usando localStorage como fallback');
      }
      
      // MODO LOCALSTORAGE: Guardar en navegador
      const dataString = JSON.stringify(this.repuestos);
      const sizeInMB = (dataString.length / (1024 * 1024)).toFixed(2);
      
      console.log('Intentando guardar en localStorage:', sizeInMB, 'MB');
      
      // Verificar si excede límite ANTES de intentar guardar
      if (sizeInMB > 9) {
        console.error(`❌ Archivo demasiado grande: ${sizeInMB}MB (límite: ~10MB)`);
        this.showToast(`❌ DATOS NO GUARDADOS: ${sizeInMB}MB excede límite de navegador (10MB)`, 'error', 8000);
        
        // Mostrar diálogo con opciones
        const opciones = confirm(
          `🚨 PROBLEMA CRÍTICO\n\n` +
          `• Tamaño: ${sizeInMB}MB\n` +
          `• Límite navegador: ~10MB\n` +
          `• Repuestos: ${this.repuestos.length}\n\n` +
          `❌ TUS CAMBIOS SE PERDERÁN AL REFRESCAR\n\n` +
          `SOLUCIONES:\n` +
          `1. Activar "📁 Modo Carpeta" (capacidad ilimitada)\n` +
          `2. Exportar JSON sin imágenes\n` +
          `3. Reducir cantidad de repuestos\n\n` +
          `¿Exportar AHORA los datos actuales (sin imágenes)?`
        );
        
        if (opciones) {
          this.exportJSONSinImagenes();
        }
        return false; // Indicar que NO se guardó
      }
      
      localStorage.setItem('inventarioData', dataString);
      
      // Advertencias por tamaño
      if (sizeInMB > 7) {
        this.showToast(`⚠️ ADVERTENCIA: ${sizeInMB}MB/10MB - Activa "📁 Modo Carpeta" para sin límites`, 'warning', 6000);
      } else if (sizeInMB > 4) {
        this.showToast(`Guardado: ${sizeInMB}MB`, 'info', 3000);
      }
      
      console.log('✅ Datos guardados en localStorage');
      return true; // Indicar éxito
    } catch (error) {
      if (error.name === 'QuotaExceededError') {
        const sizeInMB = (JSON.stringify(this.repuestos).length / (1024 * 1024)).toFixed(2);
        this.showToast(`❌ LÍMITE EXCEDIDO (${sizeInMB}MB). ¡Activa "📁 Modo Carpeta"!`, 'error', 10000);
        console.error('❌ LocalStorage lleno. Tamaño:', sizeInMB, 'MB');
      } else {
        this.showToast('❌ Error al guardar: ' + error.message, 'error');
        console.error('Error guardando:', error);
      }
      return false;
    }
  }

  // 🕒 NUEVO: Calcular tiempo transcurrido en formato legible
  calcularTiempoTranscurrido(timestamp) {
    const ahora = Date.now();
    const diferencia = ahora - timestamp;
    
    const segundos = Math.floor(diferencia / 1000);
    const minutos = Math.floor(segundos / 60);
    const horas = Math.floor(minutos / 60);
    const dias = Math.floor(horas / 24);
    
    if (dias > 0) return `${dias} día${dias === 1 ? '' : 's'}`;
    if (horas > 0) return `${horas} hora${horas === 1 ? '' : 's'}`;
    if (minutos > 0) return `${minutos} minuto${minutos === 1 ? '' : 's'}`;
    return 'menos de 1 minuto';
  }

  setupEvents() {
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
    });

    document.querySelectorAll('.view-btn').forEach(btn => {
      btn.addEventListener('click', () => this.switchView(btn.dataset.view));
    });

    document.getElementById('searchInput')?.addEventListener('input', () => {
      this.currentPage = 1;
      this.renderInventario();
    });

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('filter-chip')) {
        document.querySelectorAll('.filter-chip').forEach(f => f.classList.remove('active'));
        e.target.classList.add('active');
        this.currentPage = 1;
        this.renderInventario();
      }
    });

    document.getElementById('btnIniciarConteo')?.addEventListener('click', () => this.iniciarConteo());
    document.getElementById('btnFinalizarConteo')?.addEventListener('click', () => this.finalizarConteo());

    // Listener para resize - Recalcular paginación en modo auto
    let resizeTimeout;
    window.addEventListener('resize', () => {
      // Solo recalcular si estamos en modo auto (tanto viewMode como itemsPerPage)
      if (this.viewMode === 'auto' && this.itemsPerPage === 'auto') {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          console.log('🔄 Recalculando paginación responsive...');
          this.updateViewModeInfo(); // Actualizar info de dispositivo detectado
          this.currentPage = 1; // Resetear a primera página
          this.renderInventario();
        }, 500); // Debounce de 500ms
      }
    });

    this.setupCanvas();
  }

  setupCanvas() {
    this.canvas = document.getElementById('mapCanvas');
    if (!this.canvas) return;
    
    this.ctx = this.canvas.getContext('2d');
    
    const resize = () => {
      this.canvas.width = this.canvas.offsetWidth;
      this.canvas.height = this.canvas.offsetHeight;
      this.renderMap();
    };
    
    resize();
    window.addEventListener('resize', resize);
    
    this.canvas.addEventListener('click', (e) => this.handleMapClick(e));
  }

  // 🆕 Toggle secciones colapsables del panel de mapas
  toggleMapSection(headerElement) {
    const section = headerElement.closest('.map-section');
    section.classList.toggle('map-section--collapsed');
    
    // Guardar estado en localStorage
    const sectionTitle = headerElement.querySelector('h3').textContent.trim();
    const collapsed = section.classList.contains('map-section--collapsed');
    const collapsedSections = JSON.parse(localStorage.getItem('mapCollapsedSections') || '[]');
    
    if (collapsed) {
      if (!collapsedSections.includes(sectionTitle)) {
        collapsedSections.push(sectionTitle);
      }
    } else {
      const index = collapsedSections.indexOf(sectionTitle);
      if (index > -1) {
        collapsedSections.splice(index, 1);
      }
    }
    
    localStorage.setItem('mapCollapsedSections', JSON.stringify(collapsedSections));
  }

  // 🆕 Restaurar estado de secciones colapsadas
  restoreMapSectionsState() {
    const collapsedSections = JSON.parse(localStorage.getItem('mapCollapsedSections') || '[]');
    const sections = document.querySelectorAll('.map-section');
    
    sections.forEach(section => {
      const title = section.querySelector('.map-section-header h3').textContent.trim();
      if (collapsedSections.includes(title)) {
        section.classList.add('map-section--collapsed');
      }
    });
  }

  switchTab(tab) {
    console.log('Cambiando a pestaña:', tab);
    
    document.querySelectorAll('.tab-content').forEach(t => t.style.display = 'none');
    document.getElementById(tab).style.display = 'block';
    
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
    
    this.currentTab = tab;
    
    if (tab === 'jerarquia') {
      this.inicializarFiltrosJerarquia();
      this.renderJerarquia();
    } else if (tab === 'stats') {
      this.renderStats();
    } else if (tab === 'valores') {
      this.renderValores();
    } else if (tab === 'okr') {
      okrModule.renderDashboard();
    } else if (tab === 'configuracion') {
      this.renderListasGestion();
      // Actualizar badge de conexión cuando se abre la pestaña
      if (typeof configuracion !== 'undefined' && configuracion.actualizarEstadoUI) {
        // setTimeout para asegurar que el HTML esté renderizado
        setTimeout(() => configuracion.actualizarEstadoUI(), 50);
      }
      // Actualizar estado del backup manager
      if (typeof backupManager !== 'undefined' && backupManager.actualizarUI) {
        setTimeout(() => backupManager.actualizarUI(), 100);
      }
      // 🔽 Inicializar acordeón de configuración
      setTimeout(() => initConfigSections(), 150);
    } else if (tab === 'mapa') {
      // Dar tiempo para que el canvas se renderice antes de dibujar
      setTimeout(() => {
        if (!this.canvas || !this.ctx) {
          console.log('Inicializando canvas del mapa...');
          this.setupCanvas();
        }
        this.renderMap();
        
        // 🆕 Restaurar estado de secciones colapsadas
        this.restoreMapSectionsState();
        
        // 🆕 NUEVO: Cargar automáticamente el primer mapa si existe
        const mapStorage = JSON.parse(localStorage.getItem('mapStorage') || '{"maps":[],"areas":[]}');
        if (mapStorage.maps && mapStorage.maps.length > 0 && !this.state.currentMapId) {
          console.log('📍 Cargando automáticamente el primer mapa disponible...');
          const firstMap = mapStorage.maps[0];
          this.selectMap(firstMap.id);
        }
      }, 100);
    } else if (tab === 'conteo') {
      this.renderConteo();
    }
  }

  switchView(view) {
    this.currentView = view;
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`[data-view="${view}"]`).classList.add('active');
    this.renderInventario();
  }

  // Calcula items por página según el tamaño de pantalla (responsive) y modo de visualización
  calculateAutoItemsPerPage() {
    // Si hay modo forzado, usar valores predeterminados
    if (this.viewMode === 'mobile') {
      return 10; // Modo móvil forzado: siempre 10 items
    }
    if (this.viewMode === 'desktop') {
      return 21; // Modo PC forzado: siempre 21 items
    }
    
    // Modo auto: detectar tamaño de pantalla
    const width = window.innerWidth;
    
    // Calcular columnas según breakpoints del CSS (con tarjetas más anchas ~280-300px)
    let columns;
    if (width < 768) {
      columns = 1; // Móvil: 1 columna
    } else if (width < 1200) {
      columns = 2; // Tablet: ~2 columnas (300px cada una)
    } else if (width < 1600) {
      columns = 4; // Desktop: ~4 columnas (280px cada una)
    } else if (width < 1920) {
      columns = 5; // Ultra-wide: ~5 columnas (270px cada una)
    } else {
      columns = 6; // 4K: ~6 columnas (260px cada una)
    }
    
    // Calcular filas visibles (aproximado)
    const rows = width < 768 ? 10 : 3; // Móvil muestra más items verticalmente
    
    return columns * rows;
  }

  // Obtiene el número de items por página (auto o manual)
  getItemsPerPage() {
    if (this.itemsPerPage === 'auto') {
      return this.calculateAutoItemsPerPage();
    }
    return parseInt(this.itemsPerPage) || this.itemsPerPageManual;
  }

  // Cambia los items por página
  changeItemsPerPage(value) {
    this.itemsPerPage = value;
    if (value !== 'auto') {
      this.itemsPerPageManual = parseInt(value);
    }
    this.currentPage = 1; // Resetear a primera página
    this.renderInventario();
  }

  // Cambia el modo de visualización (auto/mobile/desktop)
  changeViewMode(mode) {
    console.log('🔄 Cambiando modo de visualización a:', mode);
    this.viewMode = mode;
    localStorage.setItem('viewMode', mode);
    
    // Aplicar estilos CSS según el modo
    this.applyViewModeStyles();
    
    // Actualizar info visual
    this.updateViewModeInfo();
    
    // Re-renderizar inventario
    this.currentPage = 1;
    this.renderInventario();
  }

  // Aplica estilos CSS dinámicos según el modo
  applyViewModeStyles() {
    // Remover clases anteriores
    document.body.classList.remove('force-mobile', 'force-desktop');
    
    // Aplicar clase según modo
    if (this.viewMode === 'mobile') {
      document.body.classList.add('force-mobile');
      console.log('📱 Modo Móvil activado');
    } else if (this.viewMode === 'desktop') {
      document.body.classList.add('force-desktop');
      console.log('💻 Modo PC activado');
    } else {
      console.log('🔄 Modo Auto activado');
    }
  }

  // Actualiza la información del modo actual
  updateViewModeInfo() {
    const select = document.getElementById('viewModeSelect');
    const textEl = document.getElementById('currentViewModeText');
    
    if (select) {
      select.value = this.viewMode;
    }
    
    if (textEl) {
      const width = window.innerWidth;
      let info = '';
      
      if (this.viewMode === 'auto') {
        const deviceType = width < 768 ? 'Móvil' : width < 1200 ? 'Tablet' : 'Desktop';
        info = `🔄 Auto - Detectado: ${deviceType} (${width}px)`;
      } else if (this.viewMode === 'mobile') {
        info = `📱 Modo Móvil Forzado (1 columna, botones grandes)`;
      } else if (this.viewMode === 'desktop') {
        info = `💻 Modo PC Forzado (5-8 columnas, máxima densidad)`;
      }
      
      textEl.textContent = info;
    }

    // Actualizar banner de Edge
    this.updateEdgeBanner();
  }

  // Actualiza el banner de Edge en configuración
  updateEdgeBanner() {
    const badge = document.getElementById('edgeStatusBadge');
    const downloadSection = document.getElementById('edgeDownloadSection');
    
    if (badge) {
      if (this.isEdge) {
        badge.textContent = '✅ EDGE DETECTADO';
        badge.style.background = 'rgba(16, 185, 129, 0.3)';
      } else {
        badge.textContent = '⚠️ NO EDGE';
        badge.style.background = 'rgba(220, 38, 38, 0.3)';
      }
    }
    
    if (downloadSection) {
      downloadSection.style.display = this.isEdge ? 'none' : 'block';
    }
  }

  render() {
    this.renderInventario();
    this.renderFilters();
  }

  renderFilters() {
    const areasGenerales = [...new Set(this.repuestos.map(r => r.areaGeneral || r.area).filter(a => a))].sort();
    const sistemasEquipos = [...new Set(this.repuestos.map(r => r.sistemaEquipo || r.equipo).filter(e => e))].sort();
    const tipos = [...new Set(this.repuestos.map(r => r.tipo).filter(t => t))].sort();
    
    const filterArea = document.getElementById('filterArea');
    const filterEquipo = document.getElementById('filterEquipo');
    const filterTipo = document.getElementById('filterTipo');
    
    if (filterArea) {
      filterArea.innerHTML = '<option value="">Todas las Áreas</option>' +
        areasGenerales.map(a => `<option value="${a}">${a}</option>`).join('');
    }
    
    if (filterEquipo) {
      filterEquipo.innerHTML = '<option value="">Todos los Sistemas/Equipos</option>' +
        sistemasEquipos.map(e => `<option value="${e}">${e}</option>`).join('');
    }
    
    if (filterTipo) {
      filterTipo.innerHTML = '<option value="">Todos los Tipos</option>' +
        tipos.map(t => `<option value="${t}">${t}</option>`).join('');
    }
  }

  applyFilters() {
    this.currentPage = 1;
    this.renderInventario();
  }

  getFilteredRepuestos() {
    const search = document.getElementById('searchInput')?.value.toLowerCase() || '';
    const filterArea = document.getElementById('filterArea')?.value || '';
    const filterEquipo = document.getElementById('filterEquipo')?.value || '';
    const filterTipo = document.getElementById('filterTipo')?.value || '';
    const filterStock = document.getElementById('filterStock')?.value || '';

    // 🐛 DEBUG: Ver si hay filtros jerárquicos activos
    if (this.filtrosJerarquicosActivos) {
      console.log('🔍 Filtros Jerárquicos Activos:', this.filtrosJerarquicosActivos);
    }

    return this.repuestos.filter(r => {
      const matchSearch = !search || 
        (r.codSAP && r.codSAP.toLowerCase().includes(search)) ||
        (r.nombre && r.nombre.toLowerCase().includes(search)) ||
        (r.tipo && r.tipo.toLowerCase().includes(search)) ||
        (r.codProv && r.codProv.toLowerCase().includes(search)) ||
        // BUSCAR EN NUEVA JERARQUÍA DE 7 NIVELES
        (r.planta && r.planta.toLowerCase().includes(search)) ||
        (r.areaGeneral && r.areaGeneral.toLowerCase().includes(search)) ||
        (r.subArea && r.subArea.toLowerCase().includes(search)) ||
        (r.sistemaEquipo && r.sistemaEquipo.toLowerCase().includes(search)) ||
        (r.subSistema && r.subSistema.toLowerCase().includes(search)) ||
        (r.seccion && r.seccion.toLowerCase().includes(search)) ||
        (r.detalle && r.detalle.toLowerCase().includes(search)) ||
        // COMPATIBILIDAD CON FORMATO ANTIGUO
        (r.area && r.area.toLowerCase().includes(search)) ||
        (r.equipo && r.equipo.toLowerCase().includes(search)) ||
        (r.sistema && r.sistema.toLowerCase().includes(search)) ||
        (r.detalleUbicacion && r.detalleUbicacion.toLowerCase().includes(search));

      // Filtros de Área y Equipo con compatibilidad
      const matchArea = !filterArea || r.areaGeneral === filterArea || r.area === filterArea;
      const matchEquipo = !filterEquipo || r.sistemaEquipo === filterEquipo || r.equipo === filterEquipo;
      const matchTipo = !filterTipo || r.tipo === filterTipo;
      
      // Filtros jerárquicos desde pestaña JERARQUÍA
      let matchJerarquia = true;
      if (this.filtrosJerarquicosActivos) {
        const fj = this.filtrosJerarquicosActivos;
        
        // 🐛 DEBUG
        console.log('Evaluando repuesto:', r.nombre, {
          repuesto: { planta: r.planta, area: r.areaGeneral, subArea: r.subArea, sistema: r.sistemaEquipo, subSistema: r.subSistema },
          filtros: fj
        });
        
        // Si hay un ID de repuesto específico, solo mostrar ese
        if (fj.repuestoId) {
          matchJerarquia = r.id === fj.repuestoId;
        } else {
          // Filtrado por niveles jerárquicos
          if (fj.planta && r.planta !== fj.planta) matchJerarquia = false;
          if (fj.areaGeneral && r.areaGeneral !== fj.areaGeneral) matchJerarquia = false;
          if (fj.subArea && r.subArea !== fj.subArea) matchJerarquia = false;
          if (fj.sistemaEquipo && r.sistemaEquipo !== fj.sistemaEquipo) matchJerarquia = false;
          if (fj.subSistema && r.subSistema !== fj.subSistema) matchJerarquia = false;
          if (fj.seccion && r.seccion !== fj.seccion) matchJerarquia = false;
          if (fj.detalle && r.detalle !== fj.detalle) matchJerarquia = false;
        }
        
        console.log('Match:', matchJerarquia);
      }
      
      let matchStock = true;
      const minimo = r.minimo || r.stockMinimo || 5;
      const optimo = r.optimo || minimo * 2;
      if (filterStock === 'agotado') {
        matchStock = r.cantidad === 0;
      } else if (filterStock === 'critico') {
        matchStock = r.cantidad > 0 && r.cantidad < minimo;
      } else if (filterStock === 'adecuado') {
        matchStock = r.cantidad >= minimo && r.cantidad < optimo;
      } else if (filterStock === 'optimo') {
        matchStock = r.cantidad >= optimo;
      }

      return matchSearch && matchArea && matchEquipo && matchTipo && matchStock && matchJerarquia;
    });
  }

  async renderInventario() {
    this.filteredRepuestos = this.getFilteredRepuestos();
    
    // 📱 MODO MÓVIL: Vista simplificada sin paginación
    if (this.isMobile && !this.hasFileSystemAPI) {
      await this.renderMobileListView(this.filteredRepuestos);
      return;
    }
    
    // PC: Vista normal con paginación
    const itemsPerPage = this.getItemsPerPage();
    const totalPages = Math.ceil(this.filteredRepuestos.length / itemsPerPage);
    if (this.currentPage > totalPages) this.currentPage = totalPages || 1;
    
    const startIndex = (this.currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedRepuestos = this.filteredRepuestos.slice(startIndex, endIndex);
    
    if (this.currentView === 'cards') {
      await this.renderCards(paginatedRepuestos);
    } else {
      await this.renderList(paginatedRepuestos);
    }
    
    this.updatePagination();
  }

  async renderCards(repuestos) {
    const grid = document.getElementById('cardsGrid');
    const list = document.getElementById('listView');
    grid.style.display = 'grid';
    list.style.display = 'none';

    if (repuestos.length === 0) {
      grid.innerHTML = '<div class="text-center" style="grid-column: 1/-1; padding: 60px; color: var(--gray-500);">No se encontraron repuestos</div>';
      return;
    }

    // Cargar URLs de imágenes en paralelo
    const repuestosWithImages = await Promise.all(repuestos.map(async (r) => {
      const multimedia = r.multimedia || [];
      const imageUrl = await this.getFirstImage(multimedia); // Cargar desde FileSystem si es necesario
      return { ...r, imageUrl };
    }));

    grid.innerHTML = repuestosWithImages.map(r => {
      const multimedia = r.multimedia || [];
      const imageUrl = r.imageUrl;
      
      const minimo = r.minimo || r.stockMinimo || 5;
      const cantidad = r.cantidad || 0;
      const optimo = r.optimo || 10; // Usar stock óptimo manual
      
      // Calcular porcentaje RELATIVO al mínimo (más intuitivo)
      let porcentaje = 0;
      let porcentajeBarra = 0;
      
      if (minimo > 0) {
        if (cantidad < minimo) {
          // Crítico: porcentaje negativo (ej: 4/5 = -20%)
          porcentaje = ((cantidad - minimo) / minimo) * 100;
          porcentajeBarra = (cantidad / minimo) * 50; // Barra hasta 50%
        } else {
          // Bajo o Normal: porcentaje positivo sobre el mínimo (ej: 6/5 = +20%)
          porcentaje = ((cantidad - minimo) / minimo) * 100;
          
          if (cantidad < optimo) {
            // Bajo: de 50% a 100% de la barra
            const progreso = ((cantidad - minimo) / (optimo - minimo));
            porcentajeBarra = 50 + (progreso * 50);
          } else {
            // Normal: barra completa al 100%
            porcentajeBarra = 100;
          }
        }
      }
      
      // Determinar estado y color basado en mínimo (Paleta Niebla y Bosque)
      let stockStatus = 'ok';
      let stockColor = '#6B8E7F'; // Verde bosque suave
      let stockText = 'Stock Normal';
      
      if (cantidad === 0) {
        stockStatus = 'cero';
        stockColor = '#C76B6B'; // Rojo suave (alta legibilidad)
        stockText = 'Sin Stock';
      } else if (cantidad < minimo) {
        stockStatus = 'critico';
        stockColor = '#D4976C'; // Naranja tierra cálido
        stockText = 'Stock Crítico';
      } else if (cantidad >= minimo && cantidad < optimo) {
        stockStatus = 'bajo';
        stockColor = '#5B7C99'; // Azul-gris brumoso
        stockText = 'Stock Bajo';
      } else {
        // cantidad >= optimo
        stockStatus = 'ok';
        stockColor = '#6B8E7F'; // Verde bosque suave
        stockText = 'Stock Normal';
      }
      
      console.log(`🖼️ [TARJETA] Renderizando repuesto: ${r.nombre}`);
      console.log(`   imageUrl:`, imageUrl);
      console.log(`   multimedia:`, multimedia);
      
      return `
      <div class="repuesto-card">
        <div class="card-image" data-action="lightbox" data-id="${r.id}" style="cursor: pointer; position: relative;">
          ${imageUrl ? `<img src="${imageUrl}" alt="${r.nombre}" data-blob-url="${imageUrl}" onload="console.log('✅ Imagen cargada en DOM:', this.alt)" onerror="console.error('❌ ERROR onerror - Imagen falló en DOM:', this.src); this.style.display='none'; this.nextElementSibling.style.display='flex';">
          <div class="no-image" style="display:none;">Sin imagen</div>` : '<div class="no-image">Sin imagen</div>'}
          ${multimedia.length > 1 ? `<div style="position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">+${multimedia.length - 1}</div>` : ''}
        </div>
        <div class="card-content">
          <div style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 6px;">
            <h3 style="margin: 0; font-weight: 500; color: var(--text-primary); font-size: 1rem;">${r.nombre}</h3>
            <div style="display: flex; gap: 6px; width: 100%;">
              <button class="btn-add-location" onclick="app.agregarUbicacionMapa('${r.id}')" title="Añadir nueva ubicación en el mapa">
                Añadir Ubicación
              </button>
              <button class="btn-view-map" onclick="app.verRepuestoEnMapa('${r.id}')" title="Ver ubicaciones en el mapa">
                Ver en Mapa
              </button>
            </div>
          </div>
          <div class="card-info">
            ${r.codSAP ? `<div class="info-row"><span class="info-label">Cód. SAP:</span><span class="info-value" style="font-weight: 500; color: var(--primary);">${r.codSAP}</span></div>` : ''}
            ${r.codProv ? `<div class="info-row"><span class="info-label">Cód. Proveedor:</span><span class="info-value" style="font-weight: 500; color: var(--text-secondary);">${r.codProv}</span></div>` : ''}
          </div>
          ${r.tipo ? `<div class="info-row"><span class="info-label">Tipo:</span><span class="info-value">${r.tipo}</span></div>` : ''}
          ${r.categoria ? `<div class="info-row"><span class="info-label">Categoría:</span><span class="info-value" style="font-weight: 500; font-size: 0.85rem; padding: 2px 8px; border-radius: 4px; display: inline-block; background: rgba(91, 139, 180, 0.15); color: var(--primary); border: 1px solid rgba(91, 139, 180, 0.3);">${r.categoria}</span></div>` : ''}
          
          <!-- Datos Técnicos (si existen) -->
          ${r.datosTecnicos ? `
            <div style="background: rgba(91, 139, 180, 0.08); border-left: 2px solid var(--primary); padding: 8px 10px; border-radius: 4px; margin: 8px 0;">
              <div style="font-size: 0.7rem; font-weight: 600; color: var(--primary); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">
                Datos Técnicos
              </div>
              <div style="font-size: 0.78rem; color: var(--text-primary); line-height: 1.5; font-family: 'Segoe UI', Arial, sans-serif; white-space: pre-line; word-break: break-word;">${r.datosTecnicos}</div>
            </div>
          ` : ''}
          
          <div class="card-info">
            ${this.showPrecio && r.precio > 0 ? `<div class="info-row precio-info"><span class="info-label">Precio:</span><span class="info-value">$${r.precio.toFixed(2)}</span></div>` : ''}
            
            <div style="background: rgba(51, 65, 85, 0.6); padding: 6px; border-radius: 4px; margin-top: 6px; border-left: 2px solid ${stockColor};">
              
              <!-- Texto descriptivo del estado -->
              <div style="
                font-size: 0.68rem;
                color: ${stockColor};
                font-weight: 500;
                margin-bottom: 5px;
                line-height: 1.3;
              ">
                ${(() => {
                  if (cantidad === 0) {
                    return `Stock agotado. Requiere reposición urgente.`;
                  } else if (cantidad < minimo) {
                    const faltante = minimo - cantidad;
                    return `Stock insuficiente: ${cantidad} de ${minimo} unid. mínimas. Faltan ${faltante} unid.`;
                  } else if (cantidad >= minimo && cantidad < optimo) {
                    const exceso = cantidad - minimo;
                    return `Stock adecuado: ${cantidad} unid. disponibles (+${exceso} sobre mínimo).`;
                  } else {
                    const exceso = cantidad - optimo;
                    return `Stock óptimo: ${cantidad} unid. disponibles (+${exceso} sobre óptimo).`;
                  }
                })()}
              </div>
              
              <!-- BARRA VISUAL DE STOCK SIMPLIFICADA -->
              <div style="
                position: relative;
                width: 100%;
                height: 20px;
                background: rgba(15, 23, 42, 0.8);
                border-radius: 4px;
                overflow: hidden;
                margin-bottom: 4px;
                border: 1px solid ${stockColor}40;
              ">
                <!-- Barra de progreso sin gradiente -->
                <div style="
                  position: absolute;
                  left: 0;
                  top: 0;
                  height: 100%;
                  width: ${porcentajeBarra}%;
                  background: ${stockColor};
                  transition: width 0.3s ease;
                "></div>
                
                <!-- Contenido superpuesto -->
                <div style="
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  padding: 0 10px;
                  z-index: 3;
                ">
                  <!-- Centro: Unidades -->
                  <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 0.85rem; font-weight: 600; color: white;">${cantidad}</span>
                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.65);">/</span>
                    <span style="font-size: 0.75rem; font-weight: 500; color: rgba(255,255,255,0.85);">${minimo}</span>
                    <span style="font-size: 0.65rem; color: rgba(255,255,255,0.75); font-weight: 400;">unid.</span>
                  </div>
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(${r.cantidadInstalada > 0 ? '4' : '3'}, 1fr); gap: 4px; margin-bottom: 4px;">
                ${r.cantidadInstalada > 0 ? `
                <div style="text-align: center; background: rgba(91, 155, 122, 0.12); padding: 2px; border-radius: 3px; border: 1px solid rgba(91, 155, 122, 0.25);">
                  <div style="font-size: 0.5rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">En Uso</div>
                  <div style="font-size: 0.7rem; font-weight: 600; color: var(--success);">${r.cantidadInstalada}</div>
                </div>
                ` : ''}
                <div style="text-align: center;">
                  <div style="font-size: 0.5rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">Mínimo</div>
                  <div style="font-size: 0.7rem; font-weight: 600; color: var(--warning);">${minimo}</div>
                </div>
                <div style="text-align: center; background: rgba(91, 139, 180, 0.15); padding: 2px; border-radius: 3px; border: 1px solid rgba(91, 139, 180, 0.25);">
                  <div style="font-size: 0.5rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">Stock</div>
                  <div style="font-size: 0.75rem; font-weight: 700; color: ${stockColor};">${cantidad}</div>
                </div>
                <div style="text-align: center;">
                  <div style="font-size: 0.5rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">Óptimo</div>
                  <div style="font-size: 0.7rem; font-weight: 600; color: var(--success);">${optimo}</div>
                </div>
              </div>
              
              <!-- Información de último conteo -->
              <div style="
                font-size: 0.6rem;
                color: var(--text-secondary);
                padding: 4px 5px;
                background: rgba(15, 23, 42, 0.4);
                border-radius: 3px;
                margin-top: 4px;
                text-align: center;
              ">
                ${r.ultimoConteo ? `
                  <span style="color: rgba(255,255,255,0.75); font-size: 0.65rem;">Última verificación: ${new Date(r.ultimoConteo).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' })} - ${new Date(r.ultimoConteo).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}</span>
                ` : `
                  <span style="color: var(--warning); font-size: 0.65rem;">Pendiente de verificación</span>
                `}
              </div>
            </div>
          </div>
        </div>
        <div class="card-footer" style="display: flex; justify-content: center; align-items: center; gap: 8px; padding: 8px 12px;">
          <button class="card-btn" style="
            background: var(--primary);
            color: white;
            border: 1px solid rgba(91, 139, 180, 0.3);
            padding: 8px 14px;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 90px;
          " data-action="edit" data-id="${r.id}" 
          onmouseover="this.style.background='#6a9dc4'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.15)';"
          onmouseout="this.style.background='var(--primary)'; this.style.boxShadow='none';">
            Editar
          </button>
          
          <button class="card-btn" style="
            background: var(--success);
            color: white;
            border: 1px solid rgba(91, 155, 122, 0.3);
            padding: 8px 14px;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 90px;
          " data-action="contar" data-id="${r.id}"
          onmouseover="this.style.background='#6bae89'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.15)';"
          onmouseout="this.style.background='var(--success)'; this.style.boxShadow='none';">
            Contar
          </button>
          
          <button class="card-btn" style="
            background: var(--danger);
            color: white;
            border: 1px solid rgba(184, 107, 107, 0.3);
            padding: 8px 14px;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 90px;
          " data-action="delete" data-id="${r.id}"
          onmouseover="this.style.background='#c88080'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.15)';"
          onmouseout="this.style.background='var(--danger)'; this.style.boxShadow='none';">
            Eliminar
          </button>
        </div>
      </div>
      `;
    }).join('');

    // Ya no activamos zoom en tarjetas - el zoom es solo en el modal
  }

  renderList(repuestos) {
    const grid = document.getElementById('cardsGrid');
    const list = document.getElementById('listView');
    grid.style.display = 'none';
    list.style.display = 'block';

    if (repuestos.length === 0) {
      list.innerHTML = '<div class="text-center" style="padding: 60px; color: var(--gray-500);">No se encontraron repuestos</div>';
      return;
    }

    // Obtener orden actual
    const sortField = this.listSortField || 'codSAP';
    const sortOrder = this.listSortOrder || 'asc';
    
    // 🆕 Definir orden de niveles jerárquicos (8 niveles)
    const nivelOrder = { 'N1': 1, 'N2': 2, 'N3': 3, 'N4': 4, 'N5': 5, 'N6': 6, 'N7': 7, 'N8': 8 };
    
    // Ordenar repuestos
    const sortedRepuestos = [...repuestos].sort((a, b) => {
      // 🆕 PRIMERO: Ordenar por nivel jerárquico (N1 primero, N8 último)
      const nivelA = nivelOrder[a.nivelJerarquico] || 8; // Por defecto N8
      const nivelB = nivelOrder[b.nivelJerarquico] || 8;
      
      if (nivelA !== nivelB) {
        return nivelA - nivelB; // Ascendente siempre (N1 → N8)
      }
      
      // SEGUNDO: Si tienen el mismo nivel, ordenar por el campo seleccionado
      let valA, valB;
      
      if (sortField === 'stock') {
        valA = a.cantidad || 0;
        valB = b.cantidad || 0;
      } else if (sortField === 'stockPercent') {
        const minimoA = a.minimo || 5;
        const minimoB = b.minimo || 5;
        const optimoA = minimoA * 2;
        const optimoB = minimoB * 2;
        valA = ((a.cantidad || 0) / optimoA) * 100;
        valB = ((b.cantidad || 0) / optimoB) * 100;
      } else {
        valA = (a[sortField] || '').toString().toLowerCase();
        valB = (b[sortField] || '').toString().toLowerCase();
      }
      
      if (sortOrder === 'asc') {
        return valA > valB ? 1 : valA < valB ? -1 : 0;
      } else {
        return valA < valB ? 1 : valA > valB ? -1 : 0;
      }
    });

    const getSortIcon = (field) => {
      if (sortField !== field) return '⇅';
      return sortOrder === 'asc' ? '▲' : '▼';
    };

    list.innerHTML = `
      <div class="list-header" id="listHeader">
        <div class="list-header-cell ${sortField === 'codSAP' ? 'active' : ''}" onclick="app.sortList('codSAP')" style="min-width: 50px;" data-col="0">
          <span>Ub.</span>
          <div class="resize-handle" data-col="0"></div>
        </div>
        <div class="list-header-cell ${sortField === 'codSAP' ? 'active' : ''}" onclick="app.sortList('codSAP')" data-col="1">
          <span>Códigos</span>
          <span class="sort-icon">${getSortIcon('codSAP')}</span>
          <div class="resize-handle" data-col="1"></div>
        </div>
        <div class="list-header-cell ${sortField === 'nombre' ? 'active' : ''}" onclick="app.sortList('nombre')" data-col="2">
          <span>Nombre</span>
          <span class="sort-icon">${getSortIcon('nombre')}</span>
          <div class="resize-handle" data-col="2"></div>
        </div>
        <div class="list-header-cell ${sortField === 'stock' || sortField === 'stockPercent' ? 'active' : ''}" onclick="app.sortList('stock')" data-col="3">
          <span>Stock (Mín/Act/Ópt)</span>
          <span class="sort-icon">${getSortIcon('stock')}</span>
          <div class="resize-handle" data-col="3"></div>
        </div>
        <div data-col="4">Acciones</div>
      </div>
      ${sortedRepuestos.map(r => {
        const minimo = r.minimo || r.stockMinimo || 5;
        const cantidad = r.cantidad || 0;
        const optimo = r.optimo || 10; // Usar stock óptimo manual
        const porcentaje = Math.min((cantidad / optimo) * 100, 100);
        
        // Determinar color del stock (Paleta Niebla y Bosque)
        let stockColor = '#6B8E7F'; // Verde bosque suave
        let stockText = 'Normal';
        if (cantidad === 0) {
          stockColor = '#C76B6B'; // Rojo suave (alta legibilidad)
          stockText = 'Sin Stock';
        } else if (cantidad < minimo) {
          stockColor = '#D4976C'; // Naranja tierra cálido
          stockText = 'Crítico';
        } else if (cantidad <= optimo) {
          stockColor = '#5B7C99'; // Azul-gris brumoso
          stockText = 'Bajo';
        }
        
        // Preparar texto de códigos ultra-compacto con etiquetas
        let codigosHTML = '';
        if (r.codSAP) {
          codigosHTML += `<div style="font-weight: 600; color: #718096; font-size: 0.7rem; display: flex; align-items: center; gap: 4px; margin-bottom: 2px;">
            <span style="color: var(--text-secondary); font-weight: 500; font-size: 0.65rem;">SAP:</span>
            <span style="color: #5B7C99; font-weight: 700; font-size: 0.8rem;">${r.codSAP}</span>
          </div>`;
        }
        if (r.codProv) {
          codigosHTML += `<div style="font-weight: 600; color: #718096; font-size: 0.7rem; display: flex; align-items: center; gap: 4px;">
            <span style="color: var(--text-secondary); font-weight: 500; font-size: 0.65rem;">Proveedor:</span>
            <span style="color: #7A9AB8;">${r.codProv}</span>
          </div>`;
        }
        if (!codigosHTML) {
          codigosHTML = '<span style="color: var(--gray-400); font-size: 0.65rem;">Sin código</span>';
        }
        
        // Preparar jerarquía de ubicación completa (7 niveles)
        const ubicacionParts = [];
        const colors = {
          planta: '#D4976C',
          areaGeneral: '#5B7C99',
          subArea: '#718096',
          sistemaEquipo: '#7A9AB8',
          subSistema: '#8B9AAA',
          seccion: '#9AABB8',
          detalle: '#6B8E7F'
        };
        
        const planta = r.planta || this.plantaBase;
        if (planta) {
          ubicacionParts.push(`<span style="color: ${colors.planta};">${planta}</span>`);
        }
        
        this.jerarquiaNiveles.forEach(nivel => {
          if (nivel.id === 'planta') return;
          
          let valor = r[nivel.id];
          if (!valor && nivel.id === 'areaGeneral') valor = r.area;
          if (!valor && nivel.id === 'sistemaEquipo') valor = r.equipo;
          if (!valor && nivel.id === 'subSistema') valor = r.sistema;
          if (!valor && nivel.id === 'detalle') valor = r.detalleUbicacion;
          
          if (valor) {
            const color = colors[nivel.id] || '#718096';
            ubicacionParts.push(`<span style="color: ${color};">${valor}</span>`);
          }
        });
        
        const ubicacionHTML = ubicacionParts.length > 0 
          ? ubicacionParts.join('<span style="color: var(--primary); margin: 0 4px;">›</span>')
          : '<span style="color: var(--text-secondary); font-size: 0.7rem;">Sin ubicación</span>';
        
        return `
        <div class="list-row">
          <div data-label="Ubicación" style="display: flex; align-items: center; justify-content: center;">
            <button class="btn-hierarchy" onclick="app.mostrarJerarquia('${r.id}')" title="Ver jerarquía completa" style="width: auto; padding: 4px 8px; font-size: 0.7rem;">
              Ver
            </button>
          </div>
          <div data-label="Códigos" style="line-height: 1.2;">
            ${codigosHTML}
          </div>
          <div data-label="Nombre" style="line-height: 1.2;">
            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;">
              ${r.nivelJerarquico ? `<span style="background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; font-size: 0.6rem; font-weight: 700; padding: 2px 6px; border-radius: 3px; letter-spacing: 0.5px;">${r.nivelJerarquico}</span>` : ''}
              <div style="font-weight: 600; color: var(--text-primary); font-size: 0.8rem;">${r.nombre}</div>
            </div>
            ${r.tipo ? `<div style="color: var(--text-secondary); font-size: 0.65rem; margin-top: 1px;"><span style="font-weight: 600;">Tipo:</span> ${r.tipo}</div>` : ''}
          </div>
          <div data-label="Stock (Mín/Act/Ópt)" class="stock-visual">
            <div style="display: flex; gap: 4px; align-items: center; justify-content: space-around; margin-bottom: 2px; padding: 0;">
              <div style="text-align: center; flex: 1;">
                <div style="font-size: 0.5rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0px;">Mín</div>
                <div style="font-weight: 700; font-size: 0.75rem; color: #D4976C; line-height: 1;">${minimo}</div>
              </div>
              <div style="text-align: center; background: rgba(91, 124, 153, 0.25); padding: 3px 6px; border-radius: 3px; flex: 1;">
                <div style="font-size: 0.5rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0px;">Act</div>
                <div style="font-weight: 700; font-size: 0.85rem; color: ${stockColor}; line-height: 1;">${cantidad}</div>
              </div>
              <div style="text-align: center; flex: 1;">
                <div style="font-size: 0.5rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0px;">Ópt</div>
                <div style="font-weight: 700; font-size: 0.75rem; color: #6B8E7F; line-height: 1;">${optimo}</div>
              </div>
            </div>
            
            ${(() => {
              // Calcular barra termómetro compacta
              let barraAncho = 0;
              let barraColor = '#C76B6B';
              
              if (cantidad === 0) {
                barraAncho = 0;
                barraColor = '#C76B6B';
              } else if (cantidad < minimo) {
                barraAncho = (cantidad / minimo) * 50;
                barraColor = '#D4976C';
              } else if (cantidad >= minimo && cantidad < optimo) {
                const progreso = ((cantidad - minimo) / (optimo - minimo));
                barraAncho = 50 + (progreso * 50);
                barraColor = '#5B7C99';
              } else {
                barraAncho = 100;
                barraColor = '#6B8E7F';
              }
              
              return `
              <div style="margin: 2px 0 2px 0;">
                <div style="position: relative; width: 100%; height: 4px; background: rgba(100, 116, 139, 0.2); border-radius: 2px; overflow: visible;">
                  <div style="
                    position: absolute;
                    left: 0;
                    top: 0;
                    height: 100%;
                    width: ${barraAncho}%;
                    background: ${barraColor};
                    border-radius: 2px;
                    transition: width 0.4s ease;
                    box-shadow: 0 0 4px ${barraColor}80;
                  "></div>
                  
                  <div style="
                    position: absolute;
                    left: 50%;
                    top: 0px;
                    width: 1px;
                    height: 4px;
                    background: #D4976C;
                    transform: translateX(-50%);
                    z-index: 2;
                  "></div>
                  
                  <div style="
                    position: absolute;
                    right: 0;
                    top: 0px;
                    width: 1px;
                    height: 4px;
                    background: #6B8E7F;
                    z-index: 2;
                  "></div>
                </div>
                
                <div style="display: flex; justify-content: space-between; font-size: 0.45rem; color: var(--text-secondary); margin-top: 1px;">
                  <span>0</span>
                  <span style="color: #D4976C; font-weight: 600;">Mín</span>
                  <span style="color: #6B8E7F; font-weight: 600;">Ópt</span>
                </div>
              </div>
              `;
            })()}
            
            <div style="font-size: 0.6rem; color: ${stockColor}; font-weight: 600; text-align: center; margin-top: 0px; line-height: 1;">${stockText}</div>
          </div>
          <div class="list-actions">
            <button class="btn" style="
              background: #557566;
              color: white;
              border: 1px solid #6B8E7F;
              padding: 6px 8px;
              font-size: 0.65rem;
              border-radius: 4px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              box-shadow: 0 1px 3px rgba(0,0,0,0.15);
              white-space: nowrap;
              line-height: 1.1;
              width: 55px;
              flex: 0 0 55px;
            " data-action="contar" data-id="${r.id}"
            onmouseover="this.style.background='#6B8E7F'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)'"
            onmouseout="this.style.background='#557566'; this.style.transform='translateY(0)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.15)'">
              Contar
            </button>
            <button class="btn" style="
              background: #4A6278;
              color: white;
              border: 1px solid #5B7C99;
              padding: 6px 8px;
              font-size: 0.65rem;
              border-radius: 4px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              box-shadow: 0 1px 3px rgba(0,0,0,0.15);
              white-space: nowrap;
              line-height: 1.1;
              width: 55px;
              flex: 0 0 55px;
            " data-action="edit" data-id="${r.id}"
            onmouseover="this.style.background='#5B7C99'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)'"
            onmouseout="this.style.background='#4A6278'; this.style.transform='translateY(0)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.15)'">
              Editar
            </button>
            <button class="btn" style="
              background: #A85555;
              color: white;
              border: 1px solid #C76B6B;
              padding: 6px 8px;
              font-size: 0.65rem;
              border-radius: 4px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              box-shadow: 0 1px 3px rgba(0,0,0,0.15);
              white-space: nowrap;
              line-height: 1.1;
              width: 55px;
              flex: 0 0 55px;
            " data-action="delete" data-id="${r.id}"
            onmouseover="this.style.background='#C76B6B'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)'"
            onmouseout="this.style.background='#A85555'; this.style.transform='translateY(0)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.15)'">
              Eliminar
            </button>
          </div>
        </div>
        `;
      }).join('')}
    `;

    // Configurar resize de columnas después de renderizar
    setTimeout(() => {
      this.applyColumnWidths();
      this.setupColumnResize();
    }, 100);
  }
  
  // Aplicar anchos de columna guardados
  applyColumnWidths() {
    const listHeader = document.getElementById('listHeader');
    if (!listHeader) return;
    
    const gridTemplate = this.columnWidths.join(' ');
    listHeader.style.gridTemplateColumns = gridTemplate;
    
    // Aplicar a todas las filas también
    document.querySelectorAll('.list-row').forEach(row => {
      row.style.gridTemplateColumns = gridTemplate;
    });
  }

  // 📱 NUEVA FUNCIÓN: Vista de lista móvil limpia (sin tarjetas ni imágenes)
  async renderMobileListView(repuestos) {
    const grid = document.getElementById('cardsGrid');
    const list = document.getElementById('listView');
    grid.style.display = 'none';
    list.style.display = 'block';

    if (repuestos.length === 0) {
      list.innerHTML = '<div style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">📭 No se encontraron repuestos</div>';
      return;
    }

    // Calcular totales
    const totalItems = repuestos.length;
    const totalCantidad = repuestos.reduce((sum, r) => sum + (r.cantidad || 0), 0);
    const stockBajo = repuestos.filter(r => {
      const minimo = r.minimo || r.stockMinimo || 5;
      return r.cantidad > 0 && r.cantidad <= minimo;
    }).length;
    const sinStock = repuestos.filter(r => r.cantidad === 0).length;

    list.innerHTML = `
      <!-- HEADER STICKY CON TOTALES - CORPORATIVO -->
      <div style="
        position: sticky;
        top: 0;
        z-index: 100;
        background: linear-gradient(135deg, #003B5C 0%, #004d73 100%);
        backdrop-filter: blur(10px);
        padding: 16px;
        margin: -16px -16px 16px -16px;
        border-radius: 0 0 12px 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        border-bottom: 3px solid #C75300;
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; color: white; margin-bottom: 12px;">
          <div style="font-size: 1.1rem; font-weight: 700; display: flex; align-items: center; gap: 8px;">
            <span style="display: inline-block; width: 8px; height: 8px; background: #0095DA; border-radius: 50%;"></span>
            ${totalItems} Repuestos
          </div>
          <div style="font-size: 0.9rem; font-weight: 600; background: rgba(255,255,255,0.1); padding: 4px 10px; border-radius: 6px;">
            ${totalCantidad} unid.
          </div>
        </div>
        <div style="display: flex; gap: 8px; font-size: 0.75rem; flex-wrap: wrap;">
          ${sinStock > 0 ? `<span style="background: rgba(139, 90, 90, 0.9); padding: 5px 10px; border-radius: 6px; font-weight: 600; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${sinStock} sin stock</span>` : ''}
          ${stockBajo > 0 ? `<span style="background: rgba(199, 83, 0, 0.9); padding: 5px 10px; border-radius: 6px; font-weight: 600; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${stockBajo} bajo</span>` : ''}
          <span style="background: rgba(82, 120, 83, 0.9); padding: 5px 10px; border-radius: 6px; font-weight: 600; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${totalItems - sinStock - stockBajo} OK</span>
        </div>
      </div>

      <!-- LISTA DE REPUESTOS -->
      <div style="display: flex; flex-direction: column; gap: 12px;">
        ${repuestos.map(r => {
          const minimo = r.minimo || r.stockMinimo || 5;
          const cantidad = r.cantidad || 0;
          const optimo = r.optimo || 10; // Usar stock óptimo manual
          const porcentaje = Math.min((cantidad / optimo) * 100, 100);
          
          // Determinar color y estado (Paleta Niebla y Bosque)
          let stockColor = '#6B8E7F'; // Verde bosque suave
          let stockBg = 'rgba(107, 142, 127, 0.15)';
          let stockText = 'OK';
          
          if (cantidad === 0) {
            stockColor = '#C76B6B'; // Rojo suave (alta legibilidad)
            stockBg = 'rgba(199, 107, 107, 0.15)';
            stockText = 'Sin Stock';
          } else if (cantidad < minimo) {
            stockColor = '#D4976C'; // Naranja tierra cálido
            stockBg = 'rgba(212, 151, 108, 0.15)';
            stockText = 'Crítico';
          } else if (cantidad < optimo) {
            stockColor = '#5B7C99'; // Azul-gris brumoso
            stockBg = 'rgba(91, 124, 153, 0.15)';
            stockText = 'Bajo';
          }
          
          return `
            <div style="
              background: var(--bg-secondary);
              border: 2px solid var(--border-color);
              border-left: 4px solid ${stockColor};
              border-radius: 12px;
              padding: 12px;
              transition: all 0.2s ease;
            " ontouchstart="this.style.transform='scale(0.98)'" ontouchend="this.style.transform='scale(1)'">
              
              <!-- HEADER: Nombre y Stock -->
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px; gap: 12px;">
                <div style="flex: 1; min-width: 0;">
                  <div style="font-weight: 700; font-size: 0.95rem; color: var(--text-primary); margin-bottom: 4px; word-wrap: break-word;">
                    ${r.nombre}
                  </div>
                  ${r.tipo ? `<div style="font-size: 0.75rem; color: var(--text-secondary);">${r.tipo}</div>` : ''}
                </div>
                <!-- Stock 3 valores: Mínimo/Actual/Óptimo -->
                <div style="
                  background: #334155;
                  border-left: 3px solid ${stockColor};
                  border-radius: 6px;
                  padding: 8px;
                  min-width: 160px;
                ">
                  <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; text-align: center;">
                    <div>
                      <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--text-secondary);">Mín</div>
                      <div style="font-weight: 700; color: #C75300; font-size: 0.95rem;">${minimo}</div>
                    </div>
                    <div style="background: rgba(91,124,153,0.2); padding: 4px; border-radius: 4px;">
                      <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--text-secondary);">Act</div>
                      <div style="font-weight: 700; color: ${stockColor}; font-size: 1.1rem;">${cantidad}</div>
                    </div>
                    <div>
                      <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--text-secondary);">Ópt</div>
                      <div style="font-weight: 700; color: #527853; font-size: 0.95rem;">${optimo}</div>
                    </div>
                  </div>
                  <div style="font-size: 0.65rem; color: ${stockColor}; font-weight: 600; margin-top: 4px; text-align: center;">${stockText}</div>
                </div>
              </div>

              <!-- BARRA DE PROGRESO -->
              <div style="
                width: 100%;
                height: 6px;
                background: rgba(100, 116, 139, 0.2);
                border-radius: 3px;
                overflow: hidden;
                margin-bottom: 10px;
              ">
                <div style="
                  width: ${porcentaje}%;
                  height: 100%;
                  background: ${stockColor};
                  transition: width 0.3s ease;
                "></div>
              </div>

              <!-- INFO: Códigos y Ubicación -->
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; font-size: 0.8rem;">
                <div style="background: var(--bg-primary); padding: 6px 8px; border-radius: 6px;">
                  <div style="color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">Cód. SAP</div>
                  <div style="font-weight: 600; color: var(--primary);">${r.codSAP || 'N/A'}</div>
                </div>
                <div style="background: var(--bg-primary); padding: 6px 8px; border-radius: 6px;">
                  <div style="color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">Cód. Prov</div>
                  <div style="font-weight: 600; color: var(--info);">${r.codProv || 'N/A'}</div>
                </div>
              </div>

              <div style="display: flex; gap: 6px; margin-bottom: 12px; font-size: 0.75rem; flex-wrap: wrap;">
                <span style="background: var(--bg-primary); padding: 4px 8px; border-radius: 6px; color: var(--text-secondary); display: flex; align-items: center; gap: 4px;">
                  <span style="display: inline-block; width: 6px; height: 6px; background: #5B7C99; border-radius: 50%;"></span>
                  ${r.area || 'Sin área'}
                </span>
                <span style="background: var(--bg-primary); padding: 4px 8px; border-radius: 6px; color: var(--text-secondary); display: flex; align-items: center; gap: 4px;">
                  <span style="display: inline-block; width: 6px; height: 6px; background: #C75300; border-radius: 50%;"></span>
                  ${r.equipo || 'Sin equipo'}
                </span>
                ${r.ultimoConteo ? `
                <span style="background: var(--bg-primary); padding: 4px 8px; border-radius: 6px; color: var(--text-secondary); font-size: 0.7rem;">
                  Contado: ${new Date(r.ultimoConteo).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' })}
                </span>
                ` : ''}
              </div>

              <!-- BOTONES DE ACCIÓN CORPORATIVOS -->
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                <button 
                  onclick="app.abrirModalConteoIndividual('${r.id}')"
                  style="
                    background: linear-gradient(135deg, #527853, #3d5a3e);
                    color: white;
                    border: none;
                    padding: 12px 8px;
                    border-radius: 8px;
                    font-weight: 600;
                    font-size: 0.85rem;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                  "
                  ontouchstart="this.style.transform='scale(0.95)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)'"
                  ontouchend="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)'"
                >
                  Contar
                </button>
                <button 
                  onclick="app.editarRepuesto('${r.id}')"
                  style="
                    background: linear-gradient(135deg, #004d73, #003B5C);
                    color: white;
                    border: none;
                    padding: 12px 8px;
                    border-radius: 8px;
                    font-weight: 600;
                    font-size: 0.85rem;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                  "
                  ontouchstart="this.style.transform='scale(0.95)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)'"
                  ontouchend="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)'"
                >
                  Editar
                </button>
                <button 
                  onclick="app.eliminarRepuesto('${r.id}')"
                  style="
                    background: linear-gradient(135deg, #8B5A5A, #6B4444);
                    color: white;
                    border: none;
                    padding: 12px 8px;
                    border-radius: 8px;
                    font-weight: 600;
                    font-size: 0.85rem;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                  "
                  ontouchstart="this.style.transform='scale(0.95)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.3)'"
                  ontouchend="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.2)'"
                >
                  Eliminar
                </button>
              </div>

              ${r.ultimoConteo ? `
                <div style="
                  margin-top: 10px;
                  padding: 6px 8px;
                  background: rgba(59, 130, 246, 0.1);
                  border-radius: 6px;
                  font-size: 0.7rem;
                  color: var(--text-secondary);
                  text-align: center;
                ">
                  📊 Último conteo: ${new Date(r.ultimoConteo).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' })}
                  ${new Date(r.ultimoConteo).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}
                </div>
              ` : `
                <div style="
                  margin-top: 10px;
                  padding: 6px 8px;
                  background: rgba(245, 158, 11, 0.1);
                  border-radius: 6px;
                  font-size: 0.7rem;
                  color: var(--warning);
                  text-align: center;
                ">
                  ⚠️ Aún no se ha contado este repuesto
                </div>
              `}
            </div>
          `;
        }).join('')}
      </div>
    `;
    
    // Ocultar paginación en móvil
    const pagination = document.getElementById('pagination');
    if (pagination) pagination.style.display = 'none';
  }

  sortList(field) {
    // Si ya estamos ordenando por este campo, invertir orden
    if (this.listSortField === field) {
      this.listSortOrder = this.listSortOrder === 'asc' ? 'desc' : 'asc';
    } else {
      // Nuevo campo, orden ascendente por defecto
      this.listSortField = field;
      this.listSortOrder = 'asc';
    }
    
    // Re-renderizar
    this.render();
    
    // Toast informativo
    const orderText = this.listSortOrder === 'asc' ? 'Ascendente ▲' : 'Descendente ▼';
    const fieldText = {
      'codSAP': 'Códigos',
      'nombre': 'Nombre',
      'area': 'Área',
      'equipo': 'Equipo',
      'stock': 'Stock',
      'stockPercent': 'Stock %'
    }[field] || field;
    
    this.showToast(`Ordenando por: ${fieldText} (${orderText})`, 'info', 2000);
  }

  // Configurar resize de columnas arrastrables
  setupColumnResize() {
    const listHeader = document.getElementById('listHeader');
    if (!listHeader) return;

    const handles = listHeader.querySelectorAll('.resize-handle');
    let isResizing = false;
    let currentHandle = null;
    let startX = 0;
    let startWidth = 0;
    let currentCol = null;
    let colIndex = null;

    // Cargar anchos guardados o usar valores por defecto
    const savedWidths = localStorage.getItem('inventario_columnWidths');
    if (savedWidths) {
      try {
        this.columnWidths = JSON.parse(savedWidths);
      } catch (e) {
        console.warn('Error cargando anchos de columnas guardados:', e);
      }
    }

    handles.forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        isResizing = true;
        currentHandle = handle;
        colIndex = parseInt(handle.dataset.col);
        currentCol = listHeader.children[colIndex];
        startX = e.pageX;
        startWidth = currentCol.offsetWidth;
        
        listHeader.classList.add('resizing');
        handle.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });
    });

    const mouseMoveHandler = (e) => {
      if (!isResizing) return;
      
      const diff = e.pageX - startX;
      const newWidth = Math.max(50, startWidth + diff); // Mínimo 50px
      
      // Actualizar solo la columna que se está redimensionando
      this.columnWidths[colIndex] = `${newWidth}px`;
      
      // Aplicar nuevo grid template
      const newGridTemplate = this.columnWidths.join(' ');
      listHeader.style.gridTemplateColumns = newGridTemplate;
      
      // Aplicar a todas las filas también
      document.querySelectorAll('.list-row').forEach(row => {
        row.style.gridTemplateColumns = newGridTemplate;
      });
    };

    const mouseUpHandler = () => {
      if (isResizing) {
        isResizing = false;
        listHeader.classList.remove('resizing');
        if (currentHandle) {
          currentHandle.classList.remove('resizing');
        }
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        
        // Guardar anchos en localStorage
        try {
          localStorage.setItem('inventario_columnWidths', JSON.stringify(this.columnWidths));
          console.log('✅ Anchos de columnas guardados:', this.columnWidths);
        } catch (e) {
          console.warn('Error guardando anchos de columnas:', e);
        }
        
        currentHandle = null;
        currentCol = null;
        colIndex = null;
      }
    };

    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
  }

  updatePagination() {
    const itemsPerPage = this.getItemsPerPage();
    const totalPages = Math.ceil(this.filteredRepuestos.length / itemsPerPage);
    const totalItems = this.filteredRepuestos.length;
    const startItem = ((this.currentPage - 1) * itemsPerPage) + 1;
    const endItem = Math.min(this.currentPage * itemsPerPage, totalItems);
    
    const pagination = document.getElementById('pagination');
    const pageNumbers = document.getElementById('pageNumbers');
    const btnPrev = document.getElementById('btnPrevPage');
    const btnNext = document.getElementById('btnNextPage');
    const itemsPerPageSelect = document.getElementById('itemsPerPageSelect');
    const itemsPerPageInfo = document.getElementById('itemsPerPageInfo');
    
    // Actualizar el selector con el valor actual
    if (itemsPerPageSelect) {
      itemsPerPageSelect.value = this.itemsPerPage;
    }
    
    // Mostrar info del modo auto
    if (itemsPerPageInfo && this.itemsPerPage === 'auto') {
      const width = window.innerWidth;
      let deviceType = width < 768 ? 'Móvil' : width < 1200 ? 'Tablet' : width < 1600 ? 'Desktop' : width < 1920 ? 'Ultra-wide' : '4K';
      itemsPerPageInfo.textContent = `(${itemsPerPage} items - ${deviceType})`;
      itemsPerPageInfo.style.display = 'inline';
    } else if (itemsPerPageInfo) {
      itemsPerPageInfo.style.display = 'none';
    }
    
    if (pagination) {
      pagination.style.display = totalPages > 1 ? 'flex' : 'none';
    }
    
    if (!pageNumbers) return;
    
    // Deshabilitar botones según página actual
    if (btnPrev) btnPrev.disabled = this.currentPage === 1;
    if (btnNext) btnNext.disabled = this.currentPage === totalPages;
    
    // Generar números de páginas
    let pages = [];
    const maxVisible = 7; // Máximo de números visibles
    
    if (totalPages <= maxVisible) {
      // Mostrar todas las páginas
      pages = Array.from({length: totalPages}, (_, i) => i + 1);
    } else {
      // Mostrar páginas con elipsis
      if (this.currentPage <= 4) {
        pages = [1, 2, 3, 4, 5, '...', totalPages];
      } else if (this.currentPage >= totalPages - 3) {
        pages = [1, '...', totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages];
      } else {
        pages = [1, '...', this.currentPage - 1, this.currentPage, this.currentPage + 1, '...', totalPages];
      }
    }
    
    pageNumbers.innerHTML = pages.map(page => {
      if (page === '...') {
        return `<span style="color: var(--text-secondary); padding: 0 8px; opacity: 0.5;">...</span>`;
      }
      
      const isActive = page === this.currentPage;
      return `
        <button 
          onclick="app.goToPage(${page})" 
          class="btn ${isActive ? 'btn-primary' : 'btn-secondary'}"
          style="
            min-width: 42px; 
            padding: 8px 12px; 
            font-weight: ${isActive ? '700' : '500'}; 
            opacity: ${isActive ? '1' : '0.5'};
            ${isActive ? 'box-shadow: var(--shadow-lg); transform: scale(1.1);' : 'box-shadow: var(--shadow-sm);'}
            transition: all 0.3s ease;
          "
          ${isActive ? 'disabled' : ''}
        >
          ${page}
        </button>
      `;
    }).join('') + `
      <span style="color: var(--text-secondary); font-size: 0.85rem; margin-left: 12px; white-space: nowrap; opacity: 0.8;">
        ${startItem}-${endItem} de ${totalItems}
      </span>
    `;
  }

  goToPage(page) {
    const itemsPerPage = this.getItemsPerPage();
    const totalPages = Math.ceil(this.filteredRepuestos.length / itemsPerPage);
    if (page === 'last') {
      this.currentPage = totalPages;
    } else {
      this.currentPage = Math.max(1, Math.min(page, totalPages));
    }
    this.renderInventario();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  nextPage() {
    const itemsPerPage = this.getItemsPerPage();
    const totalPages = Math.ceil(this.filteredRepuestos.length / itemsPerPage);
    if (this.currentPage < totalPages) {
      this.currentPage++;
      this.renderInventario();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  previousPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
      this.renderInventario();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }

  async openModal(mode, id = null) {
    console.log(`\n📝 ========== ABRIENDO MODAL ==========`);
    console.log(`Modo: ${mode}`);
    console.log(`ID recibido: ${id} (tipo: ${typeof id})`);
    console.log(`Total repuestos en memoria: ${this.repuestos.length}`);
    
    this.currentEditingId = id;
    this.currentMultimedia = [];
    this.currentDocuments = [];
    
    document.getElementById('modalTitle').textContent = mode === 'edit' ? 'Editar Repuesto' : 'Agregar Repuesto';
    document.getElementById('repuestoForm').reset();
    document.getElementById('imagePreview').innerHTML = '';
    document.getElementById('documentsList').innerHTML = '';
    
    // 🔧 RESETEAR BOTÓN DE GUARDAR (evitar que quede en estado "Guardando...")
    const btnGuardar = document.getElementById('btnGuardarRepuesto');
    const btnText = btnGuardar?.querySelector('.btn-text');
    const btnLoading = btnGuardar?.querySelector('.btn-loading');
    
    if (btnGuardar && btnText && btnLoading) {
      btnGuardar.disabled = false;
      btnGuardar.style.opacity = '1';
      btnGuardar.style.cursor = 'pointer';
      btnText.style.display = 'inline';
      btnLoading.style.display = 'none';
    }
    
    // Inicializar ubicaciones múltiples
    this.ubicacionesActuales = [];
    
    if (mode === 'edit' && id) {
      console.log(`\n⌕ Buscando repuesto con ID: "${id}" (tipo: ${typeof id})`);
      console.log(`Primeros 5 IDs disponibles:`, this.repuestos.slice(0, 5).map(r => `"${r.id}" (${typeof r.id})`));
      
      // BÚSQUEDA MULTI-FORMATO: Probar diferentes comparaciones
      let repuesto = this.repuestos.find(r => {
        // Normalizar ambos IDs a string para comparar
        const idStr = String(id).trim();
        const rIdStr = String(r.id).trim();
        
        // Comparación estricta
        if (r.id === id) return true;
        
        // Comparación tipo-flexible
        if (r.id == id) return true;
        
        // Comparación de strings
        if (rIdStr === idStr) return true;
        
        // Comparación sin espacios/caracteres especiales
        if (rIdStr.replace(/\s+/g, '') === idStr.replace(/\s+/g, '')) return true;
        
        return false;
      });
      
      // Si no se encuentra, intentar búsqueda por índice (último recurso)
      if (!repuesto && this.repuestos.length < 100) {
        console.warn(`⚠️ ID no encontrado, mostrando todos los IDs disponibles:`);
        this.repuestos.forEach((r, idx) => {
          console.log(`  [${idx}] ID: "${r.id}" (${typeof r.id}) - ${r.nombre}`);
        });
      }
      
      if (repuesto) {
        console.log(`✅ ¡REPUESTO ENCONTRADO!`);
        console.log(`   Nombre: ${repuesto.nombre}`);
        console.log(`   ID: ${repuesto.id}`);
        console.log(`   Multimedia: ${repuesto.multimedia?.length || 0} items`);
        
        document.getElementById('repuestoId').value = repuesto.id;
        document.getElementById('codSAP').value = repuesto.codSAP || '';
        document.getElementById('codProv').value = repuesto.codProv || '';
        document.getElementById('tipo').value = repuesto.tipo || '';
        document.getElementById('categoria').value = repuesto.categoria || '';
        document.getElementById('nombre').value = repuesto.nombre || '';
        
        // CARGAR UBICACIONES (soporta múltiples ubicaciones o formato antiguo)
        if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones) && repuesto.ubicaciones.length > 0) {
          // Nuevo formato: múltiples ubicaciones
          this.ubicacionesActuales = repuesto.ubicaciones.map(ub => ({
            id: Date.now() + Math.random(),
            areaGeneral: ub.areaGeneral || '',
            subArea: ub.subArea || '',
            sistemaEquipo: ub.sistemaEquipo || '',
            subSistema: ub.subSistema || '',
            seccion: ub.seccion || '',
            detalle: ub.detalle || ''
          }));
        } else {
          // Formato antiguo: convertir a array de una ubicación
          this.ubicacionesActuales = [{
            id: Date.now(),
            areaGeneral: repuesto.areaGeneral || repuesto.area || '',
            subArea: repuesto.subArea || '',
            sistemaEquipo: repuesto.sistemaEquipo || repuesto.equipo || '',
            subSistema: repuesto.subSistema || repuesto.sistema || '',
            seccion: repuesto.seccion || '',
            detalle: repuesto.detalle || repuesto.detalleUbicacion || ''
          }];
        }
        
        // 🔄 SWITCH: Usar versión con cascada o versión original
        if (this.usarVersionCascada) {
          this.renderUbicacionesCascada();
        } else {
          this.renderUbicaciones();
        }
        
        document.getElementById('cantidad').value = repuesto.cantidad || 0;
        document.getElementById('cantidadInstalada').value = repuesto.cantidadInstalada || 0;
        document.getElementById('minimo').value = repuesto.minimo || repuesto.stockMinimo || 5;
        document.getElementById('optimo').value = repuesto.optimo || 10;
        document.getElementById('precio').value = repuesto.precio || 0;
        document.getElementById('datosTecnicos').value = repuesto.datosTecnicos || '';
        
        const multimedia = repuesto.multimedia || [];
        
        if (multimedia.length > 0) {
          // 🧹 FILTRAR base64 si estamos en modo FileSystem
          const isFileSystemMode = fsManager && fsManager.isFileSystemMode;
          
          this.currentMultimedia = multimedia.filter(m => {
            if (m.type !== 'image' && m.type !== 'video') return false;
            
            // Si está en modo FileSystem, ELIMINAR base64
            if (isFileSystemMode && m.url && m.url.startsWith('data:image')) {
              console.log(`🗑️ Filtrando base64 antiguo de: ${repuesto.nombre}`);
              return false;
            }
            
            return true;
          });
          
          this.currentDocuments = multimedia.filter(m => m.type === 'document');
          
          console.log(`🖼️ Cargados: ${this.currentMultimedia.length} imágenes, ${this.currentDocuments.length} documentos`);
          
          if (isFileSystemMode && this.currentMultimedia.length === 0 && multimedia.some(m => m.type === 'image')) {
            console.log('INFO Todas las imágenes eran base64 y fueron filtradas. Agrega nuevas imágenes.');
          }
          
          await this.updateMultimediaPreview();
        } else {
          console.log('📭 Sin multimedia existente');
        }
      } else {
        console.error(`❌ ¡REPUESTO NO ENCONTRADO!`);
        console.error(`   ID buscado: "${id}" (tipo: ${typeof id})`);
        console.error(`   IDs existentes (primeros 10):`, this.repuestos.slice(0, 10).map(r => `"${r.id}" (${typeof r.id})`));
        this.showToast('❌ Error: Repuesto no encontrado', 'error');
      }
    } else {
      console.log('🆕 Modo AGREGAR nuevo repuesto');
      // Inicializar con una ubicación vacía
      this.agregarUbicacion();
    }
    
    document.getElementById('modal').classList.add('active');
    this.addEscapeListener();
    this.setupEnterNavigation();
    
    // Ajustar ancho del modal según ubicaciones (dar tiempo a que se renderice)
    setTimeout(() => this.ajustarAnchoModal(), 100);
    
    console.log('========== MODAL ABIERTO ==========\n');
  }

  closeModal() {
    document.getElementById('modal').classList.remove('active');
    this.removeEscapeListener();
    this.removeEnterNavigation();
  }
  
  setupEnterNavigation() {
    const form = document.getElementById('repuestoForm');
    if (!form) return;
    
    // Obtener todos los elementos focusables del formulario
    const getFocusableElements = () => {
      return Array.from(form.querySelectorAll(
        'input:not([type="hidden"]):not([disabled]), select:not([disabled]), textarea:not([disabled])'
      )).filter(el => el.offsetParent !== null); // Solo elementos visibles
    };
    
    // Handler para Enter
    this.enterNavigationHandler = (e) => {
      // Solo actuar si es la tecla Enter
      if (e.key !== 'Enter') return;
      
      // Si es un textarea, permitir saltos de línea con Enter
      if (e.target.tagName === 'TEXTAREA') return;
      
      // Prevenir el submit del formulario
      e.preventDefault();
      
      const focusableElements = getFocusableElements();
      const currentIndex = focusableElements.indexOf(e.target);
      
      if (currentIndex > -1 && currentIndex < focusableElements.length - 1) {
        // Ir al siguiente elemento
        focusableElements[currentIndex + 1].focus();
      } else {
        // Si es el último campo, mantener el foco (no hacer submit)
        e.target.blur();
      }
    };
    
    // Agregar listener al formulario
    form.addEventListener('keydown', this.enterNavigationHandler);
  }
  
  removeEnterNavigation() {
    const form = document.getElementById('repuestoForm');
    if (form && this.enterNavigationHandler) {
      form.removeEventListener('keydown', this.enterNavigationHandler);
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // FUNCIÓN ELIMINADA: mostrarJerarquia() VIEJA + construirUbicacionCompleta()
  // Ahora se usa la versión con dendrograma SVG (línea ~6577)
  // ═══════════════════════════════════════════════════════════════

  // Actualizar preview de ubicación en el formulario
  updateUbicacionPreview() {
    const area = document.getElementById('area').value.trim();
    const equipo = document.getElementById('equipo').value.trim();
    const sistema = document.getElementById('sistema').value;
    const detalle = document.getElementById('detalleUbicacion').value.trim();

    const preview = document.getElementById('ubicacionPreview');
    const previewText = document.getElementById('ubicacionPreviewText');

    const partes = [];
    if (area) partes.push(area);
    if (equipo) partes.push(equipo);
    if (sistema) partes.push(sistema);
    if (detalle) partes.push(detalle);

    if (partes.length > 0) {
      previewText.innerHTML = partes.map((parte, index) => {
        const icons = ['🏭', '⚙️', '🔧', '📌'];
        const icon = icons[index] || '•';
        return `<span style="display: inline-flex; align-items: center; gap: 4px;"><span>${icon}</span><span>${parte}</span></span>`;
      }).join(' <span style="color: var(--primary); font-weight: bold;">›</span> ');
      preview.style.display = 'block';
    } else {
      preview.style.display = 'none';
    }
  }

  // Cargar sistemas según el equipo seleccionado (predefinidos + personalizados)
  cargarSistemasPorEquipo(equipo) {
    const datalist = document.getElementById('sistemaDatalist');
    if (!datalist) return;

    // Obtener sistemas predefinidos del catálogo
    let predefinidos = this.sistemaPorEquipo[equipo] || this.sistemaPorEquipo['default'];
    
    // Obtener sistemas personalizados del equipo (si existen)
    let personalizados = this.customSistemas[equipo] || [];
    
    // Combinar ambos arrays y eliminar duplicados
    let sistemasCompletos = [...predefinidos, ...personalizados];
    sistemasCompletos = [...new Set(sistemasCompletos)]; // Eliminar duplicados
    
    // Ordenar alfabéticamente (opcional, mantiene "Otro" al final si existe)
    sistemasCompletos.sort((a, b) => {
      if (a === 'Otro') return 1;
      if (b === 'Otro') return -1;
      return a.localeCompare(b, 'es');
    });

    // Limpiar y llenar opciones del datalist
    datalist.innerHTML = '';
    sistemasCompletos.forEach(sistema => {
      const option = document.createElement('option');
      option.value = sistema;
      datalist.appendChild(option);
    });
    
    console.log(`✅ Sistemas cargados para ${equipo}: ${sistemasCompletos.length} (${predefinidos.length} predefinidos + ${personalizados.length} personalizados)`);
  }

  async compressImageToBlob(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          if (width > maxWidth || height > maxWidth) {
            if (width > height) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            } else {
              width = (width * maxWidth) / height;
              height = maxWidth;
            }
          }

          canvas.width = width;
          canvas.height = height;

          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);

          // Convertir a Blob WebP
          canvas.toBlob((blob) => {
            if (blob) {
              console.log(`Blob WebP creado: ${(blob.size / 1024).toFixed(1)}KB`);
              resolve(blob);
            } else {
              console.error('Error creando blob');
              resolve(null);
            }
          }, 'image/webp', quality);
        };
        img.onerror = () => {
          console.error('Error cargando imagen para comprimir');
          resolve(null);
        };
        img.src = e.target.result;
      };
      reader.onerror = () => {
        console.error('Error leyendo archivo');
        resolve(null);
      };
      reader.readAsDataURL(file);
    });
  }

  async compressImage(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          // Redimensionar manteniendo aspecto
          if (width > maxWidth || height > maxWidth) {
            if (width > height) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            } else {
              width = (width * maxWidth) / height;
              height = maxWidth;
            }
          }

          canvas.width = width;
          canvas.height = height;

          const ctx = canvas.getContext('2d');
          
          // MEJORA 1: Optimización de renderizado
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // MEJORA 2: Fondo blanco para transparencias
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          
          // MEJORA 3: Dibujar imagen con suavizado
          ctx.drawImage(img, 0, 0, width, height);

          // MEJORA 4: Intentar WebP primero (mejor compresión)
          let compressedUrl = null;
          let format = 'webp';
          
          // Detectar soporte de WebP
          try {
            compressedUrl = canvas.toDataURL('image/webp', quality);
            
            // Si WebP no funciona o es muy grande, probar JPEG
            if (!compressedUrl.startsWith('data:image/webp') || compressedUrl.length > 120000) {
              format = 'jpeg';
              compressedUrl = canvas.toDataURL('image/jpeg', quality);
            }
          } catch (e) {
            // Fallback a JPEG si WebP no está soportado
            format = 'jpeg';
            compressedUrl = canvas.toDataURL('image/jpeg', quality);
          }

          // MEJORA 5: Optimización adaptativa de calidad
          let currentQuality = quality;
          let iterations = 0;
          const targetSize = 100000; // ~100KB objetivo
          
          while (compressedUrl.length > targetSize && currentQuality > 0.5 && iterations < 5) {
            currentQuality -= 0.08; // Reducción más gradual
            compressedUrl = canvas.toDataURL(`image/${format}`, currentQuality);
            iterations++;
          }
          
          // Log para debugging
          const finalSizeKB = (compressedUrl.length / 1024).toFixed(1);
          console.log(`Imagen comprimida: ${format.toUpperCase()}, ${finalSizeKB}KB, calidad: ${(currentQuality * 100).toFixed(0)}%`);

          resolve(compressedUrl);
        };
        img.onerror = () => {
          console.error('Error cargando imagen para comprimir');
          resolve(null);
        };
        img.src = e.target.result;
      };
      reader.onerror = () => {
        console.error('Error leyendo archivo');
        resolve(null);
      };
      reader.readAsDataURL(file);
    });
  }

  // ========================================
  // OPTIMIZADOR DE IMÁGENES INTERACTIVO
  // ========================================
  currentImageFile = null;
  currentOptimizeSize = 1200;
  currentQuality = 0.85;
  
  async handleImageWithOptimizer(event) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;
    
    // Si hay múltiples archivos, procesarlos uno por uno
    for (const file of files) {
      await this.showOptimizerModal(file);
    }
    
    // Limpiar el input para permitir seleccionar las mismas imágenes
    event.target.value = '';
  }
  
  async showOptimizerModal(file) {
    this.currentImageFile = file;
    
    return new Promise((resolve) => {
      const modal = document.getElementById('optimizerModal');
      const originalImg = document.getElementById('optimizerOriginal');
      const optimizedImg = document.getElementById('optimizerOptimized');
      const originalSize = document.getElementById('originalSize');
      const originalDimensions = document.getElementById('originalDimensions');
      
      modal.classList.add('active');
      
      // Cargar imagen original
      const reader = new FileReader();
      reader.onload = async (e) => {
        const img = new Image();
        img.onload = async () => {
          originalImg.src = e.target.result;
          originalSize.textContent = `Tamaño: ${(file.size / 1024).toFixed(1)} KB`;
          originalDimensions.textContent = `${img.width} × ${img.height} px`;
          
          // Generar preview optimizada inicial
          await this.updateOptimizedPreview(e.target.result, img.width, img.height);
          
          this.optimizerResolve = resolve;
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });
  }
  
  async updateOptimizedPreview(originalDataUrl, originalWidth, originalHeight) {
    const optimizedImg = document.getElementById('optimizerOptimized');
    const optimizedSize = document.getElementById('optimizedSize');
    const optimizedDimensions = document.getElementById('optimizedDimensions');
    const savingsBadge = document.getElementById('savingsBadge');
    
    // Crear canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      // Calcular nuevas dimensiones
      let width = originalWidth;
      let height = originalHeight;
      
      if (this.currentOptimizeSize !== 'original') {
        const maxSize = this.currentOptimizeSize;
        if (width > maxSize || height > maxSize) {
          if (width > height) {
            height = (height / width) * maxSize;
            width = maxSize;
          } else {
            width = (width / height) * maxSize;
            height = maxSize;
          }
        }
      }
      
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      
      // Convertir a WebP con calidad especificada
      const optimizedDataUrl = canvas.toDataURL('image/webp', this.currentQuality);
      optimizedImg.src = optimizedDataUrl;
      
      // Calcular tamaños
      const optimizedSizeBytes = optimizedDataUrl.length * 0.75; // Aproximado
      const originalSizeBytes = this.currentImageFile.size;
      const savings = ((originalSizeBytes - optimizedSizeBytes) / originalSizeBytes * 100).toFixed(1);
      
      optimizedSize.textContent = `Tamaño: ${(optimizedSizeBytes / 1024).toFixed(1)} KB`;
      optimizedDimensions.textContent = `${Math.round(width)} × ${Math.round(height)} px`;
      savingsBadge.innerHTML = `Ahorro: <strong>${savings}%</strong>`;
      savingsBadge.style.background = savings > 50 ? 'var(--success)' : savings > 30 ? 'var(--warning)' : 'var(--danger)';
      
      // Guardar para uso posterior
      this.currentOptimizedDataUrl = optimizedDataUrl;
    };
    
    img.src = originalDataUrl;
  }
  
  setOptimizeSize(size) {
    this.currentOptimizeSize = size;
    
    // Actualizar botones activos
    document.querySelectorAll('.size-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.size == size) {
        btn.classList.add('active');
      }
    });
    
    // Regenerar preview
    const originalImg = document.getElementById('optimizerOriginal');
    if (originalImg.src) {
      const img = new Image();
      img.onload = () => {
        this.updateOptimizedPreview(originalImg.src, img.width, img.height);
      };
      img.src = originalImg.src;
    }
  }
  
  updateQuality(value) {
    this.currentQuality = value / 100;
    document.getElementById('qualityValue').textContent = value + '%';
    
    // Regenerar preview
    const originalImg = document.getElementById('optimizerOriginal');
    if (originalImg.src) {
      const img = new Image();
      img.onload = () => {
        this.updateOptimizedPreview(originalImg.src, img.width, img.height);
      };
      img.src = originalImg.src;
    }
  }
  
  async applyOptimization() {
    const modal = document.getElementById('optimizerModal');
    modal.style.display = 'none';
    
    // Convertir dataURL a Blob
    const blob = await this.dataURLtoBlob(this.currentOptimizedDataUrl);
    
    // Agregar a multimedia
    if (!this.currentMultimedia) this.currentMultimedia = [];
    
    const isFileSystemMode = fsManager && fsManager.isFileSystemMode;
    
    if (isFileSystemMode) {
      // Guardar en FileSystem
      const timestamp = Date.now();
      const codSAP = document.getElementById('codSAP')?.value || 'SAP';
      const nombreRepuesto = document.getElementById('nombre')?.value || 'REPUESTO';
      const imageIndex = this.currentMultimedia.length + 1;
      
      const cleanCodSAP = codSAP.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
      const cleanNombre = nombreRepuesto.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
      const filename = `${timestamp}_${cleanCodSAP}_${cleanNombre}_foto${imageIndex}.webp`;
      
      const imagePath = await this.fsManager.saveImage(blob, filename);
      
      if (imagePath) {
        this.currentMultimedia.push({
          type: 'image',
          url: imagePath,
          name: this.currentImageFile.name,
          size: blob.size,
          isFileSystem: true
        });
      }
    } else {
      // Guardar en IndexedDB
      const blobUrl = URL.createObjectURL(blob);
      this.currentMultimedia.push({
        type: 'image',
        url: this.currentOptimizedDataUrl,
        name: this.currentImageFile.name,
        size: blob.size,
        blob: blob
      });
    }
    
    this.updateImagePreview();
    this.showToast(`Imagen optimizada agregada (${(blob.size / 1024).toFixed(1)} KB)`, 'success');
    
    if (this.optimizerResolve) {
      this.optimizerResolve();
    }
  }
  
  skipOptimization() {
    const modal = document.getElementById('optimizerModal');
    modal.style.display = 'none';
    
    // Usar imagen original sin optimizar
    const reader = new FileReader();
    reader.onload = async (e) => {
      if (!this.currentMultimedia) this.currentMultimedia = [];
      
      const isFileSystemMode = fsManager && fsManager.isFileSystemMode;
      
      if (isFileSystemMode) {
        const timestamp = Date.now();
        const codSAP = document.getElementById('codSAP')?.value || 'SAP';
        const nombreRepuesto = document.getElementById('nombre')?.value || 'REPUESTO';
        const imageIndex = this.currentMultimedia.length + 1;
        
        const cleanCodSAP = codSAP.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
        const cleanNombre = nombreRepuesto.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
        const ext = this.currentImageFile.name.split('.').pop();
        const filename = `${timestamp}_${cleanCodSAP}_${cleanNombre}_foto${imageIndex}.${ext}`;
        
        const imagePath = await this.fsManager.saveImage(this.currentImageFile, filename);
        
        if (imagePath) {
          this.currentMultimedia.push({
            type: 'image',
            url: imagePath,
            name: this.currentImageFile.name,
            size: this.currentImageFile.size,
            isFileSystem: true
          });
        }
      } else {
        this.currentMultimedia.push({
          type: 'image',
          url: e.target.result,
          name: this.currentImageFile.name,
          size: this.currentImageFile.size,
          blob: this.currentImageFile
        });
      }
      
      this.updateImagePreview();
      this.showToast('Imagen original agregada', 'info');
      
      if (this.optimizerResolve) {
        this.optimizerResolve();
      }
    };
    reader.readAsDataURL(this.currentImageFile);
  }
  
  closeOptimizer() {
    const modal = document.getElementById('optimizerModal');
    modal.classList.remove('active');
    
    if (this.optimizerResolve) {
      this.optimizerResolve();
    }
  }
  
  dataURLtoBlob(dataURL) {
    return new Promise((resolve) => {
      const arr = dataURL.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      resolve(new Blob([u8arr], { type: mime }));
    });
  }
  
  updateImagePreview() {
    const preview = document.getElementById('imagePreview');
    if (!this.currentMultimedia || this.currentMultimedia.filter(m => m.type === 'image').length === 0) {
      preview.innerHTML = '';
      return;
    }
    
    const images = this.currentMultimedia.filter(m => m.type === 'image');
    preview.innerHTML = images.map((media, index) => `
      <div class="preview-item">
        <img src="${media.url}" alt="Preview ${index + 1}">
        <button type="button" class="preview-delete" onclick="app.removeMultimedia(${index})">×</button>
        <div class="preview-info">${(media.size / 1024).toFixed(1)} KB</div>
      </div>
    `).join('');
  }

  async handleMultimedia(event, type) {
    const files = Array.from(event.target.files);
    if (files.length === 0) return;

    if (type === 'image') {
      if (!this.currentMultimedia) this.currentMultimedia = [];
      
      const preview = document.getElementById('imagePreview');
      const isFileSystemMode = fsManager && fsManager.isFileSystemMode;
      const isMobileMode = this.storageMode === 'indexeddb';
      
      // Mensaje según el modo de almacenamiento
      let modeMessage = 'Optimizando imágenes...';
      if (isFileSystemMode) modeMessage = 'Guardando en carpeta...';
      else if (isMobileMode) modeMessage = '📱 Guardando en IndexedDB...';
      
      preview.innerHTML = `<div style="padding: 16px; color: var(--primary); font-weight: 600;">⏳ ${modeMessage}</div>`;

      if (files.length > 5) {
        this.showToast(`Procesando ${files.length} imágenes...`, 'info');
      }

      console.log(`\n${'='.repeat(60)}`);
      console.log(`📁 Procesando ${files.length} imágenes nuevas`);
      console.log(`📌 Modo de almacenamiento: ${this.storageMode.toUpperCase()}`);
      console.log(`📌 FileSystem activo: ${isFileSystemMode ? 'SÍ' : 'NO'}`);
      console.log(`📌 Imágenes existentes: ${this.currentMultimedia.length}`);

      let totalOriginalSize = 0;
      let totalCompressedSize = 0;
      let successCount = 0;

      for (const file of files) {
        try {
          console.log(`🖼️ ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
          totalOriginalSize += file.size;
          
          // ===================================================================
          // MODO 1: FILESYSTEM (PC con Edge - Almacenamiento ilimitado)
          // SIMPLIFICADO: Todo en carpeta plana con nombres descriptivos
          // ===================================================================
          if (isFileSystemMode) {
            const compressedBlob = await this.compressImageToBlob(file);
            if (compressedBlob) {
              // Generar nombre descriptivo
              const timestamp = Date.now();
              const codSAP = document.getElementById('codSAP')?.value || 'SAP';
              const nombreRepuesto = document.getElementById('nombre')?.value || 'REPUESTO';
              const imageIndex = this.currentMultimedia.length + 1;
              
              // Nombre: timestamp_CODSAP_nombre_foto1.webp
              const cleanCodSAP = codSAP.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
              const cleanNombre = nombreRepuesto.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
              const filename = `${timestamp}_${cleanCodSAP}_${cleanNombre}_foto${imageIndex}.webp`;
              
              // Guardar directamente en carpeta raíz de imágenes
              const imagePath = await this.fsManager.saveImage(compressedBlob, filename);
              console.log(`✅ FileSystem: ${filename} (${(compressedBlob.size / 1024).toFixed(0)}KB)`);
              
              let fullPath = imagePath;
              
              if (imagePath) {
                // 🔧 EVITAR DUPLICADOS: Verificar si la imagen ya existe
                const yaExiste = this.currentMultimedia.some(img => img.url === imagePath);
                
                if (!yaExiste) {
                  this.currentMultimedia.push({
                    type: 'image',
                    url: imagePath,
                    name: file.name,
                    size: compressedBlob.size,
                    isFileSystem: true
                  });
                  totalCompressedSize += compressedBlob.size;
                  successCount++;
                  console.log(`✅ Imagen agregada: ${imagePath}`);
                } else {
                  console.log(`⚠️ Imagen ya existe, ignorando: ${imagePath}`);
                }
              }
            }
          } 
          // ===================================================================
          // MODO 2: INDEXEDDB (Móvil - Límite ~50-100MB)
          // ===================================================================
          else if (isMobileMode) {
            const compressedBlob = await this.compressImageToBlob(file);
            if (compressedBlob) {
              const timestamp = Date.now();
              const cleanName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
              const imageId = `img_${timestamp}_${cleanName}`;
              const repuestoId = this.currentEditingId || 'temp';
              
              // Guardar en IndexedDB
              await indexedDBManager.saveImage(imageId, repuestoId, compressedBlob);
              
              // 🔧 EVITAR DUPLICADOS: Verificar si la imagen ya existe
              const yaExiste = this.currentMultimedia.some(img => img.url === imageId);
              
              if (!yaExiste) {
                this.currentMultimedia.push({
                  type: 'image',
                  url: imageId, // ID para recuperar de IndexedDB
                  name: file.name,
                  size: compressedBlob.size,
                  isIndexedDB: true
                });
                totalCompressedSize += compressedBlob.size;
                successCount++;
                console.log(`✅ IndexedDB: ${imageId} (${(compressedBlob.size / 1024).toFixed(0)}KB)`);
              } else {
                console.log(`⚠️ Imagen ya existe en IndexedDB, ignorando: ${imageId}`);
              }
            }
          } 
          // ===================================================================
          // MODO 3: LOCALSTORAGE (Fallback - Límite ~5-10MB)
          // ===================================================================
          else {
            const compressedUrl = await this.compressImage(file);
            
            if (compressedUrl) {
              // 🔧 EVITAR DUPLICADOS: Verificar si la imagen ya existe (comparar por nombre ya que URL es base64)
              const yaExiste = this.currentMultimedia.some(img => img.name === file.name && img.type === 'image');
              
              if (!yaExiste) {
                totalCompressedSize += compressedUrl.length;
                
                this.currentMultimedia.push({
                  type: 'image',
                  url: compressedUrl,
                  name: file.name,
                  size: compressedUrl.length
                });
                successCount++;
                console.log(`✅ LocalStorage: ${(compressedUrl.length / 1024).toFixed(0)}KB`);
              } else {
                console.log(`⚠️ Imagen ya existe en LocalStorage, ignorando: ${file.name}`);
              }
            }
          }
        } catch (error) {
          console.error('❌ Error procesando imagen:', error);
          this.showToast(`❌ Error con ${file.name}`, 'error');
        }
      }
      
      // Calcular reducción de tamaño
      const reduction = ((1 - totalCompressedSize / totalOriginalSize) * 100).toFixed(0);
      const finalSizeMB = (totalCompressedSize / (1024 * 1024)).toFixed(2);
      
      console.log(`📊 ${(totalOriginalSize / (1024 * 1024)).toFixed(2)}MB → ${finalSizeMB}MB (-${reduction}%)`);
      console.log(`✅ ${successCount}/${files.length} guardadas - Total: ${this.currentMultimedia.length}`);
      console.log(`${'='.repeat(60)}\n`);
      
      // Limpiar input para permitir mismos archivos
      event.target.value = '';
      
      await this.updateMultimediaPreview();
      
      const modeLabel = isMobileMode ? '📱 Móvil' : isFileSystemMode ? '💻 PC' : '💾 Local';
      this.showToast(`✅ ${successCount} imagen(es) guardadas [${modeLabel}] - Total: ${this.currentMultimedia.length}`, 'success');
    } else if (type === 'document') {
      if (!this.currentDocuments) this.currentDocuments = [];
      
      console.log(`Procesando ${files.length} documentos`);
      console.log(`📌 Documentos existentes: ${this.currentDocuments.length}`);
      
      let pendingLoads = files.length;
      let addedCount = 0;
      
      files.forEach(file => {
        if (file.size > 4 * 1024 * 1024) {
          this.showToast(`❌ ${file.name} muy grande (máx 4MB)`, 'error');
          pendingLoads--;
          return;
        }

        console.log(`📎 ${file.name} (${(file.size / 1024).toFixed(0)}KB)`);
        const reader = new FileReader();
        reader.onload = (e) => {
          this.currentDocuments.push({
            type: 'document',
            url: e.target.result,
            name: file.name,
            size: file.size,
            mimeType: file.type
          });
          addedCount++;
          console.log(`✅ Documento agregado: ${file.name}`);
          pendingLoads--;
          
          if (pendingLoads === 0) {
            console.log(`✅ Total: ${this.currentDocuments.length} documentos`);
            this.showToast(`✅ ${addedCount} documento(s) agregado(s) - Total: ${this.currentDocuments.length}`, 'success');
          }
        };
        reader.readAsDataURL(file);
      });
      
      // Limpiar input
      event.target.value = '';
    }
  }

  async updateMultimediaPreview(message = null) {
    const preview = document.getElementById('imagePreview');
    if (!preview) {
      console.warn('⚠️ Elemento imagePreview no encontrado');
      return;
    }

    if (message) {
      preview.innerHTML = `<div style="padding: 16px; color: var(--primary); font-weight: 600;">⏳ ${message}</div>`;
      return;
    }

    if (!this.currentMultimedia || this.currentMultimedia.length === 0) {
      console.log('📭 No hay imágenes para mostrar');
      preview.innerHTML = '';
      return;
    }

    console.log(`🖼️ Mostrando ${this.currentMultimedia.length} imágenes en preview`);

    // 🔥 CARGAR IMÁGENES ASÍNCRONAMENTE DESDE FILESYSTEM
    const imagePromises = this.currentMultimedia.map(async (media, idx) => {
      const imageUrl = await this.getImageUrl(media);
      
      if (!imageUrl) {
        console.warn(`⚠️ No se pudo cargar imagen del índice ${idx}`);
        return null;
      }
      
      const sizeKB = media.size ? (media.size / 1024).toFixed(0) : '??';
      
      // Detectar formato basado en la URL o ruta
      let format = 'JPEG';
      let badgeColor = 'var(--info)';
      
      if (imageUrl.includes('.webp') || media.url?.includes('.webp')) {
        format = 'WebP';
        badgeColor = 'var(--success)';
      } else if (imageUrl.startsWith('data:image/webp')) {
        format = 'WebP';
        badgeColor = 'var(--success)';
      } else if (imageUrl.startsWith('blob:')) {
        format = 'WebP';
        badgeColor = 'var(--success)';
      }
      
      return `
      <div style="position: relative; display: inline-block; margin: 5px;">
        <img src="${imageUrl}" style="width: 120px; height: 120px; object-fit: cover; border-radius: 8px; border: 2px solid var(--gray-300); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
        <button onclick="app.removeMultimedia(${idx})" type="button" style="position: absolute; top: 4px; right: 4px; background: var(--danger); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 18px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">×</button>
        <div style="position: absolute; bottom: 4px; left: 4px; right: 4px; background: rgba(0,0,0,0.8); color: white; padding: 4px 6px; border-radius: 4px; font-size: 0.7rem; display: flex; justify-content: space-between; align-items: center;">
          <span style="font-weight: 600;">${sizeKB}KB</span>
          <span style="background: ${badgeColor}; padding: 2px 6px; border-radius: 3px; font-size: 0.65rem; font-weight: 700;">${format}</span>
        </div>
      </div>
      `;
    });

    // Esperar a que todas las imágenes se carguen
    const htmlParts = await Promise.all(imagePromises);
    preview.innerHTML = htmlParts.filter(part => part !== null).join('');
  }

  async removeMultimedia(index) {
    if (this.currentMultimedia && this.currentMultimedia[index]) {
      const media = this.currentMultimedia[index];
      
      // 🗑️ Si es FileSystem, eliminar el archivo físico
      if (media.isFileSystem && media.url && fsManager.isFileSystemMode) {
        console.log(`🗑️ Eliminando imagen física: ${media.url}`);
        const deleted = await fsManager.deleteImage(media.url);
        if (deleted) {
          console.log(`✅ Imagen eliminada del disco`);
        } else {
          console.warn(`⚠️ No se pudo eliminar la imagen física (puede no existir)`);
        }
      }
      
      // Eliminar del array
      this.currentMultimedia.splice(index, 1);
      await this.updateMultimediaPreview();
      this.showToast('🗑️ Imagen eliminada', 'success');
    }
  }

  async saveRepuesto(e) {
    e.preventDefault();
    
    // 🔒 BLOQUEAR BOTÓN Y MOSTRAR LOADING
    const btnGuardar = document.getElementById('btnGuardarRepuesto');
    const btnText = btnGuardar.querySelector('.btn-text');
    const btnLoading = btnGuardar.querySelector('.btn-loading');
    
    btnGuardar.disabled = true;
    btnGuardar.style.opacity = '0.7';
    btnGuardar.style.cursor = 'wait';
    btnText.style.display = 'none';
    btnLoading.style.display = 'inline-flex';
    btnLoading.style.alignItems = 'center';
    
    try {
      console.log('\n🔵 ========== GUARDANDO REPUESTO ==========');
      const id = this.currentEditingId || Date.now().toString() + Math.random();
      
      const multimediaTotal = [...(this.currentMultimedia || []), ...(this.currentDocuments || [])];
      console.log(`📸 Multimedia a guardar: ${multimediaTotal.length} items (${this.currentMultimedia?.length || 0} imágenes, ${this.currentDocuments?.length || 0} documentos)`);
      
      //  GUARDAR UBICACIONES ANTIGUAS (para detectar cambios y mover imágenes)
      let ubicacionesAntiguas = null;
      if (this.currentEditingId) {
        const repuestoAnterior = this.repuestos.find(r => r.id === this.currentEditingId);
        if (repuestoAnterior && repuestoAnterior.ubicaciones) {
          ubicacionesAntiguas = JSON.parse(JSON.stringify(repuestoAnterior.ubicaciones));
          console.log('📂 Ubicaciones antiguas guardadas:', ubicacionesAntiguas[0]?.areaGeneral);
        }
      }
    
    // 🔧 ACTUALIZAR ubicacionesActuales desde el DOM (por si los listeners fallaron)
    console.log('🔧 Sincronizando ubicaciones desde el DOM...');
    this.ubicacionesActuales.forEach((ub, idx) => {
      const inputs = document.querySelectorAll(`[data-ubicacion-id="${ub.id}"]`);
      inputs.forEach(input => {
        const field = input.dataset.field;
        const value = input.value;
        ub[field] = value;
        console.log(`  📝 Ubicación ${idx + 1} - ${field}: "${value}"`);
      });
    });
    
    // DEBUG: Mostrar ubicaciones antes de validar
    console.log('\n📍 UBICACIONES ACTUALES DESPUÉS DE SINCRONIZAR:');
    this.ubicacionesActuales.forEach((ub, idx) => {
      console.log(`  Ubicación ${idx + 1}:`, {
        areaGeneral: ub.areaGeneral,
        subArea: ub.subArea,
        sistemaEquipo: ub.sistemaEquipo,
        subSistema: ub.subSistema,
        seccion: ub.seccion,
        detalle: ub.detalle
      });
    });
    
    // VALIDAR QUE HAY AL MENOS UNA UBICACIÓN CON ÁREA GENERAL
    const ubicacionesValidas = this.ubicacionesActuales.filter(ub => ub.areaGeneral && ub.areaGeneral.trim() !== '');
    console.log(`\n✅ Ubicaciones válidas: ${ubicacionesValidas.length} de ${this.ubicacionesActuales.length}`);
    
    if (ubicacionesValidas.length === 0) {
      // 🔓 RE-HABILITAR BOTÓN SI HAY ERROR
      btnGuardar.disabled = false;
      btnGuardar.style.opacity = '1';
      btnGuardar.style.cursor = 'pointer';
      btnText.style.display = 'inline';
      btnLoading.style.display = 'none';
      
      this.showToast('❌ Debes especificar al menos un Área General', 'error');
      return;
    }
    
    // Limpiar ubicaciones (remover campos vacíos)
    const ubicacionesLimpias = ubicacionesValidas.map((ub, idx) => {
      const ubicacion = {};
      console.log(`🧹 Limpiando ubicación ${idx + 1}:`);
      if (ub.areaGeneral) {
        ubicacion.areaGeneral = ub.areaGeneral.trim();
        console.log(`  ✓ areaGeneral: "${ubicacion.areaGeneral}"`);
      }
      if (ub.subArea && ub.subArea.trim()) {
        ubicacion.subArea = ub.subArea.trim();
        console.log(`  ✓ subArea: "${ubicacion.subArea}"`);
      }
      if (ub.sistemaEquipo && ub.sistemaEquipo.trim()) {
        ubicacion.sistemaEquipo = ub.sistemaEquipo.trim();
        console.log(`  ✓ sistemaEquipo: "${ubicacion.sistemaEquipo}"`);
      }
      if (ub.subSistema && ub.subSistema.trim()) {
        ubicacion.subSistema = ub.subSistema.trim();
        console.log(`  ✓ subSistema: "${ubicacion.subSistema}"`);
      }
      if (ub.seccion && ub.seccion.trim()) {
        ubicacion.seccion = ub.seccion.trim();
        console.log(`  ✓ seccion: "${ubicacion.seccion}"`);
      }
      if (ub.subSeccion && ub.subSeccion.trim()) {
        ubicacion.subSeccion = ub.subSeccion.trim();
        console.log(`  ✓ subSeccion: "${ubicacion.subSeccion}"`);
      }
      if (ub.detalle && ub.detalle.trim()) {
        ubicacion.detalle = ub.detalle.trim();
        console.log(`  ✓ detalle: "${ubicacion.detalle}"`);
      }
      
      // 🗺️ CRÍTICO: Preservar datos del mapa si existen
      if (ub.mapId) {
        ubicacion.mapId = ub.mapId;
        console.log(`  🗺️ mapId preservado: ${ubicacion.mapId}`);
      }
      if (ub.areaId) {
        ubicacion.areaId = ub.areaId;
        console.log(`  📍 areaId preservado: ${ubicacion.areaId}`);
      }
      if (ub.markerX !== undefined) {
        ubicacion.markerX = ub.markerX;
        console.log(`  📌 markerX preservado: ${ubicacion.markerX}`);
      }
      if (ub.markerY !== undefined) {
        ubicacion.markerY = ub.markerY;
        console.log(`  📌 markerY preservado: ${ubicacion.markerY}`);
      }
      if (ub.descripcion && ub.descripcion.trim()) {
        ubicacion.descripcion = ub.descripcion.trim();
        console.log(`  💬 descripcion preservada: "${ubicacion.descripcion}"`);
      }
      
      return ubicacion;
    });
    
    console.log('💾 UBICACIONES LIMPIAS A GUARDAR:', JSON.stringify(ubicacionesLimpias, null, 2));
    
    // 🧠 APRENDIZAJE AUTOMÁTICO: Agregar nuevas opciones a las listas
    // Nota: 'detalle' no se aprende porque es texto libre
    ubicacionesLimpias.forEach(ubicacion => {
      if (ubicacion.areaGeneral) this.aprenderNuevaOpcion('areaGeneral', ubicacion.areaGeneral);
      if (ubicacion.subArea) this.aprenderNuevaOpcion('subArea', ubicacion.subArea);
      if (ubicacion.sistemaEquipo) this.aprenderNuevaOpcion('sistemaEquipo', ubicacion.sistemaEquipo);
      if (ubicacion.subSistema) this.aprenderNuevaOpcion('subSistema', ubicacion.subSistema);
      if (ubicacion.seccion) this.aprenderNuevaOpcion('seccion', ubicacion.seccion);
      if (ubicacion.subSeccion) this.aprenderNuevaOpcion('subSeccion', ubicacion.subSeccion);
    });
    
    // 🔄 SINCRONIZACIÓN AUTOMÁTICA: Agregar ubicaciones al árbol de jerarquía
    this.sincronizarJerarquiaDesdeUbicaciones(ubicacionesLimpias);
    
    // 🔄 SINCRONIZACIÓN: Aprender también campos de autocomplete (tipo, codProv)
    const tipoValue = document.getElementById('tipo').value.trim();
    const codProvValue = document.getElementById('codProv').value.trim();
    
    if (tipoValue && !this.autocompleteData.tipo.includes(tipoValue)) {
      this.autocompleteData.tipo.push(tipoValue);
      this.autocompleteData.tipo.sort();
      localStorage.setItem('autocompleteData', JSON.stringify(this.autocompleteData));
      console.log(`✅ Nuevo tipo aprendido: ${tipoValue}`);
      
      // Actualizar UI si configuración está visible
      if (this.currentTab === 'configuracion') {
        this.renderListasGestion();
        console.log(`🔄 UI de configuración actualizada automáticamente`);
      }
    }
    
    if (codProvValue && !this.autocompleteData.codProv.includes(codProvValue)) {
      this.autocompleteData.codProv.push(codProvValue);
      this.autocompleteData.codProv.sort();
      localStorage.setItem('autocompleteData', JSON.stringify(this.autocompleteData));
      console.log(`✅ Nuevo código proveedor aprendido: ${codProvValue}`);
      
      // Actualizar UI si configuración está visible
      if (this.currentTab === 'configuracion') {
        this.renderListasGestion();
        console.log(`🔄 UI de configuración actualizada automáticamente`);
      }
    }
    
    const data = {
      id: id,
      codSAP: document.getElementById('codSAP').value,
      codProv: document.getElementById('codProv').value,
      tipo: document.getElementById('tipo').value,
      categoria: document.getElementById('categoria').value,
      nombre: document.getElementById('nombre').value,
      
      // UBICACIONES MÚLTIPLES (nuevo sistema)
      ubicaciones: ubicacionesLimpias,
      planta: this.plantaBase, // Empresa siempre fija
      
      // COMPATIBILIDAD: Guardar primera ubicación en formato antiguo
      areaGeneral: ubicacionesLimpias[0].areaGeneral || '',
      subArea: ubicacionesLimpias[0].subArea || '',
      sistemaEquipo: ubicacionesLimpias[0].sistemaEquipo || '',
      subSistema: ubicacionesLimpias[0].subSistema || '',
      seccion: ubicacionesLimpias[0].seccion || '',
      detalle: ubicacionesLimpias[0].detalle || '',
      area: ubicacionesLimpias[0].areaGeneral || '',
      equipo: ubicacionesLimpias[0].sistemaEquipo || '',
      sistema: ubicacionesLimpias[0].subSistema || '',
      detalleUbicacion: ubicacionesLimpias[0].detalle || '',
      
      cantidad: parseInt(document.getElementById('cantidad').value) || 0,
      cantidadInstalada: parseInt(document.getElementById('cantidadInstalada').value) || 0,
      minimo: parseInt(document.getElementById('minimo').value) || 5,
      optimo: parseInt(document.getElementById('optimo').value) || 10,
      precio: parseFloat(document.getElementById('precio').value) || 0,
      datosTecnicos: document.getElementById('datosTecnicos').value.trim() || '',
      multimedia: multimediaTotal,
      ultimaModificacion: new Date().toISOString(),
      ultimoConteo: null
    };
    
    console.log(`📍 Guardando ${ubicacionesLimpias.length} ubicación(es) para: ${data.nombre}`);

    if (this.currentEditingId) {
      const index = this.repuestos.findIndex(r => r.id === this.currentEditingId);
      if (index !== -1) {
        console.log(`✏️ Actualizando repuesto existente: ${data.nombre}`);
        // Preservar fecha de último conteo si existe
        const repuestoAnterior = this.repuestos[index];
        data.ultimoConteo = repuestoAnterior.ultimoConteo || null;
        this.repuestos[index] = data;
        this.showToast(`✅ Repuesto actualizado con ${multimediaTotal.length} archivo(s)`, 'success');
        
        // 📦 MOVER IMÁGENES SI CAMBIÓ LA UBICACIÓN
        if (ubicacionesAntiguas && fsManager.isFileSystemMode && this.renombrarImagenesAutomaticamente) {
          const areaAntigua = ubicacionesAntiguas[0]?.areaGeneral;
          const areaNueva = ubicacionesLimpias[0]?.areaGeneral;
          
          if (areaAntigua && areaNueva && areaAntigua !== areaNueva) {
            console.log(`🚚 Detectado cambio de área: "${areaAntigua}" → "${areaNueva}"`);
            console.log('   Iniciando movimiento automático de imágenes...');
            await this.moverImagenSiCambiaUbicacion(data, ubicacionesAntiguas, ubicacionesLimpias);
            // Actualizar repuesto con URLs nuevas
            this.repuestos[index] = data;
            await this.saveData();
          }
        }
      }
    } else {
      console.log(`➕ Agregando nuevo repuesto: ${data.nombre}`);
      this.repuestos.unshift(data); // Agregar al inicio para que aparezca primero
      this.showToast(`✅ Repuesto agregado con ${multimediaTotal.length} archivo(s)`, 'success');
    }

    // ⏳ ESPERAR a que se guarde en disco antes de continuar
    await this.saveData();
    this.updateAutocompleteData();
    await this.render();
    this.renderFilters();
    this.closeModal();
    console.log('✅ Guardado completo\n');
    
    } catch (error) {
      console.error('❌ Error guardando repuesto:', error);
      this.showToast('❌ Error al guardar: ' + error.message, 'error');
      
      // 🔓 RE-HABILITAR BOTÓN EN CASO DE ERROR
      btnGuardar.disabled = false;
      btnGuardar.style.opacity = '1';
      btnGuardar.style.cursor = 'pointer';
      btnText.style.display = 'inline';
      btnLoading.style.display = 'none';
    }
  }

  async deleteRepuesto(id) {
    if (!confirm('¿Eliminar este repuesto?')) return;
    
    // 🗑️ Buscar el repuesto para eliminar sus imágenes físicas
    const repuesto = this.repuestos.find(r => r.id === id);
    
    if (repuesto && repuesto.multimedia && fsManager.isFileSystemMode) {
      // Filtrar solo imágenes de FileSystem
      const imagenesFileSystem = repuesto.multimedia
        .filter(m => m.type === 'image' && m.isFileSystem && m.url)
        .map(m => m.url);
      
      if (imagenesFileSystem.length > 0) {
        console.log(`🗑️ Eliminando ${imagenesFileSystem.length} imágenes del producto "${repuesto.nombre}"...`);
        const result = await fsManager.deleteMultipleImages(imagenesFileSystem);
        console.log(`✅ Limpieza completada: ${result.deleted} eliminadas, ${result.failed} fallidas`);
      }
    }
    
    // Eliminar repuesto del array
    this.repuestos = this.repuestos.filter(r => r.id !== id);
    await this.saveData();
    await this.render();
    this.renderFilters();
    this.showToast('🗑️ Repuesto e imágenes eliminados', 'success');
  }

  updateAutocompleteData() {
    const codProvs = new Set();
    const tipos = new Set();
    const areasGenerales = new Set();
    const subAreas = new Set();
    const sistemasEquipos = new Set();
    const subSistemas = new Set();
    const secciones = new Set();
    const subSecciones = new Set();
    const detalles = new Set();

    this.repuestos.forEach(r => {
      if (r.codProv) codProvs.add(r.codProv);
      if (r.tipo) tipos.add(r.tipo);
      
      const areaGeneral = r.areaGeneral || r.area;
      if (areaGeneral) areasGenerales.add(areaGeneral);
      
      if (r.subArea) subAreas.add(r.subArea);
      
      const sistemaEquipo = r.sistemaEquipo || r.equipo;
      if (sistemaEquipo) sistemasEquipos.add(sistemaEquipo);
      
      const subSistema = r.subSistema || r.sistema;
      if (subSistema) subSistemas.add(subSistema);
      
      if (r.seccion) secciones.add(r.seccion);
      
      if (r.subSeccion) subSecciones.add(r.subSeccion);
      
      const detalle = r.detalle || r.detalleUbicacion;
      if (detalle) detalles.add(detalle);
    });

    this.autocompleteData = {
      codProv: Array.from(codProvs).sort(),
      tipo: Array.from(tipos).sort(),
      areaGeneral: Array.from(areasGenerales).sort(),
      subArea: Array.from(subAreas).sort(),
      sistemaEquipo: Array.from(sistemasEquipos).sort(),
      subSistema: Array.from(subSistemas).sort(),
      seccion: Array.from(secciones).sort(),
      subSeccion: Array.from(subSecciones).sort(),
      detalle: Array.from(detalles).sort()
    };
    
    // Actualizar vista de listas en configuración si está visible
    this.renderListasGestion();
  }

  renderListasGestion() {
    const listas = [
      { id: 'tipo', nombre: 'Tipo', field: 'tipo', esJerarquia: false },
      { id: 'areaGeneral', nombre: 'Área General', field: 'areaGeneral', esJerarquia: true },
      { id: 'subArea', nombre: 'Sub-Área', field: 'subArea', esJerarquia: true },
      { id: 'sistemaEquipo', nombre: 'Sistema/Equipo', field: 'sistemaEquipo', esJerarquia: true },
      { id: 'subSistema', nombre: 'Sub-Sistema', field: 'subSistema', esJerarquia: true },
      { id: 'seccion', nombre: 'Sección', field: 'seccion', esJerarquia: true },
      { id: 'subSeccion', nombre: 'Sub-Sección', field: 'subSeccion', esJerarquia: true }
      // Nota: 'detalle' se omite porque es campo de texto libre
    ];

    listas.forEach(lista => {
      const container = document.getElementById(`lista${lista.id.charAt(0).toUpperCase() + lista.id.slice(1)}`);
      if (!container) return;
      
      // Obtener datos de la fuente correcta
      const datos = lista.esJerarquia 
        ? (this.opcionesJerarquia[lista.field] || [])
        : (this.autocompleteData[lista.field] || []);
      
      if (datos.length === 0) {
        container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 10px;">No hay ${lista.nombre.toLowerCase()}s registrados</div>`;
      } else {
        container.innerHTML = datos.map((item, index) => `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: var(--bg-secondary); margin-bottom: 4px; border-radius: 4px;">
            <span style="color: var(--text-primary); font-size: 0.9rem; flex: 1;">${item}</span>
            <div style="display: flex; gap: 4px;">
              <button onclick="app.editarItemLista('${lista.field}', ${index}, '${item.replace(/'/g, "\\'")}')" 
                      style="background: var(--info); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">
                Editar
              </button>
              <button onclick="app.eliminarItemLista('${lista.field}', '${item.replace(/'/g, "\\'")}')" 
                      style="background: var(--danger); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">
                Eliminar
              </button>
            </div>
          </div>
        `).join('');
      }
    });

    // 🗺️ NUEVO: Renderizar categorías de áreas del mapa
    this.renderCategoriasAreasConfig();
    
    // 🆕 Renderizar árbol jerárquico organizacional
    this.renderJerarquiaTree();
  }

  // 🗺️ NUEVO: Renderizar categorías de áreas en configuración
  renderCategoriasAreasConfig() {
    const container = document.getElementById('listaCategoriasAreas');
    const mensajeVacio = document.getElementById('mensajeNoCategoriasAreas');
    if (!container) return;

    // Obtener categorías desde mapController
    const categorias = typeof mapController !== 'undefined' && mapController.categories 
      ? mapController.categories 
      : {};

    const categoriasArray = Object.entries(categorias).map(([key, value]) => ({
      id: key,
      icon: value.icon,
      name: value.name,
      color: value.color,
      description: value.description
    }));

    if (categoriasArray.length === 0) {
      container.style.display = 'none';
      if (mensajeVacio) mensajeVacio.style.display = 'block';
    } else {
      container.style.display = 'grid';
      if (mensajeVacio) mensajeVacio.style.display = 'none';
      
      container.innerHTML = categoriasArray.map(cat => `
        <div style="display: flex; align-items: center; gap: 16px; padding: 16px; background: var(--bg-primary); border-radius: 8px; border-left: 4px solid ${cat.color}; transition: all 0.2s; position: relative; overflow: hidden;">
          <!-- Fondo con color de categoría (sutil) -->
          <div style="position: absolute; top: 0; right: 0; bottom: 0; width: 60px; background: linear-gradient(90deg, transparent, ${cat.color}20); pointer-events: none;"></div>
          
          <!-- Icono y color -->
          <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; min-width: 60px; position: relative; z-index: 1;">
            <span style="font-size: 2rem; line-height: 1;">${cat.icon}</span>
            <div style="width: 40px; height: 24px; background: ${cat.color}; border-radius: 6px; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
          </div>
          
          <!-- Información -->
          <div style="flex: 1; min-width: 0; position: relative; z-index: 1;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
              <span style="color: var(--text-primary); font-weight: 700; font-size: 1rem;">${cat.name}</span>
              <span style="color: var(--text-muted); font-size: 0.7rem; font-family: monospace; background: var(--bg-secondary); padding: 2px 6px; border-radius: 4px;">${cat.color}</span>
            </div>
            <p style="color: var(--text-secondary); font-size: 0.8rem; margin: 0; line-height: 1.4;">${cat.description}</p>
          </div>
          
          <!-- Botones de acción -->
          <div style="display: flex; gap: 6px; position: relative; z-index: 1;">
            <button onclick="app.editarCategoria('${cat.id}')" 
                    title="Editar categoría"
                    style="background: var(--info); color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
              <span>✏️</span> Editar
            </button>
            <button onclick="app.eliminarCategoria('${cat.id}')" 
                    title="Eliminar categoría"
                    style="background: var(--danger); color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
              <span>🗑️</span> Eliminar
            </button>
          </div>
        </div>
      `).join('');
    }
  }

  agregarItemLista(tipo) {
    const nombres = {
      'tipo': 'Tipo',
      'areaGeneral': 'AreaGeneral',
      'subArea': 'SubArea',
      'sistemaEquipo': 'SistemaEquipo',
      'subSistema': 'SubSistema',
      'seccion': 'Seccion',
      'detalle': 'Detalle'
    };
    
    const inputId = 'nuevo' + nombres[tipo];
    const input = document.getElementById(inputId);
    
    if (!input) return;
    
    const valor = input.value.trim();
    if (!valor) {
      this.showToast('❌ Ingresa un valor', 'error');
      return;
    }

    // Si es un nivel de jerarquía (excepto detalle), usar las nuevas funciones
    if (['areaGeneral', 'subArea', 'sistemaEquipo', 'subSistema', 'seccion'].includes(tipo)) {
      const result = this.agregarOpcionJerarquia(tipo, valor);
      if (result) {
        input.value = '';
        this.renderListasGestion();
      }
      return;
    }

    // Para otros tipos (como 'tipo'), usar el sistema anterior
    const lista = this.autocompleteData[tipo] || [];
    if (lista.includes(valor)) {
      this.showToast('⚠️ Este valor ya existe', 'warning');
      return;
    }

    if (!this.autocompleteData[tipo]) {
      this.autocompleteData[tipo] = [];
    }
    this.autocompleteData[tipo].push(valor);
    this.autocompleteData[tipo].sort();
    
    localStorage.setItem('autocompleteData', JSON.stringify(this.autocompleteData));
    
    input.value = '';
    this.renderListasGestion();
    this.showToast(`✅ ${valor} agregado correctamente`, 'success');
  }

  editarItemLista(tipo, index, valorActual) {
    const nuevoValor = prompt(`Editar valor:`, valorActual);
    
    if (!nuevoValor || nuevoValor.trim() === '') {
      return;
    }

    const valorTrim = nuevoValor.trim();
    
    // Si es un nivel de jerarquía (excepto detalle), usar opcionesJerarquia
    if (['areaGeneral', 'subArea', 'sistemaEquipo', 'subSistema', 'seccion'].includes(tipo)) {
      if (this.opcionesJerarquia[tipo].includes(valorTrim) && valorTrim !== valorActual) {
        this.showToast('⚠️ Este valor ya existe', 'warning');
        return;
      }
      
      // Actualizar en repuestos existentes
      let modificados = 0;
      this.repuestos.forEach(repuesto => {
        if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones)) {
          repuesto.ubicaciones.forEach(ubicacion => {
            if (ubicacion[tipo] === valorActual) {
              ubicacion[tipo] = valorTrim;
              modificados++;
            }
          });
        }
      });
      
      // Actualizar en la lista
      this.opcionesJerarquia[tipo][index] = valorTrim;
      this.opcionesJerarquia[tipo].sort();
      this.saveOpcionesPersonalizadas();
      
      if (modificados > 0) {
        this.guardarDatos();
        this.showToast(`✅ Valor actualizado en ${modificados} ubicación(es)`, 'success');
      } else {
        this.showToast(`✅ Valor actualizado: ${valorTrim}`, 'success');
      }
      
      this.renderListasGestion();
      return;
    }
    
    // Para otros tipos (tipo, codProv, etc.)
    if (this.autocompleteData[tipo].includes(valorTrim) && valorTrim !== valorActual) {
      this.showToast('⚠️ Este valor ya existe', 'warning');
      return;
    }

    this.autocompleteData[tipo][index] = valorTrim;
    this.autocompleteData[tipo].sort();
    
    localStorage.setItem('autocompleteData', JSON.stringify(this.autocompleteData));
    
    this.renderListasGestion();
    this.showToast(`✅ Valor actualizado: ${valorTrim}`, 'success');
  }

  eliminarItemLista(tipo, valor) {
    const nombres = {
      'tipo': 'Tipos',
      'areaGeneral': 'Áreas Generales',
      'subArea': 'Sub-Áreas',
      'sistemaEquipo': 'Sistemas/Equipos',
      'subSistema': 'Sub-Sistemas',
      'seccion': 'Secciones',
      'detalle': 'Detalles'
    };

    if (!confirm(`¿Eliminar "${valor}" de la lista de ${nombres[tipo]}?\n\n⚠️ Esta opción también se eliminará de todos los repuestos que la usen.`)) {
      return;
    }

    // Si es un nivel de jerarquía (excepto detalle), usar las nuevas funciones
    if (['areaGeneral', 'subArea', 'sistemaEquipo', 'subSistema', 'seccion'].includes(tipo)) {
      const result = this.eliminarOpcionJerarquia(tipo, valor);
      if (result) {
        this.renderListasGestion();
      }
      return;
    }

    // Para otros tipos (como 'tipo'), usar el sistema anterior
    const index = this.autocompleteData[tipo].indexOf(valor);
    if (index > -1) {
      this.autocompleteData[tipo].splice(index, 1);
    }

    localStorage.setItem('autocompleteData', JSON.stringify(this.autocompleteData));
    
    this.renderListasGestion();
    this.showToast(`✅ ${valor} eliminado`, 'success');
  }

  // 🆕 ========================================
  // FUNCIONES DE GESTIÓN DE JERARQUÍA ANIDADA
  // ========================================
  
  renderJerarquiaTree() {
    const container = document.getElementById('jerarquiaTreeContainer');
    if (!container) {
      console.error('❌ No se encontró el contenedor jerarquiaTreeContainer');
      return;
    }
    
    if (!this.jerarquiaAnidada) {
      console.error('❌ jerarquiaAnidada no está definida');
      container.innerHTML = '<p style="color: var(--danger); padding: 20px;">Error: No se pudo cargar la jerarquía. Verifica la consola.</p>';
      return;
    }
    
    console.log('✅ Renderizando árbol jerárquico:', this.jerarquiaAnidada);
    
    try {
      const html = this.buildTreeHTML();
      container.innerHTML = html;
      console.log('✅ Árbol renderizado correctamente');
    } catch (error) {
      console.error('❌ Error renderizando árbol:', error);
      container.innerHTML = `<p style="color: var(--danger); padding: 20px;">Error renderizando árbol: ${error.message}</p>`;
    }
  }
  
  buildTreeHTML() {
    if (!this.jerarquiaAnidada) {
      console.error('❌ jerarquiaAnidada es null o undefined');
      return '<p>Error: No hay datos de jerarquía</p>';
    }
    
    const { empresa, areas } = this.jerarquiaAnidada;
    
    if (!empresa || !areas) {
      console.error('❌ Faltan propiedades en jerarquiaAnidada:', this.jerarquiaAnidada);
      return '<p>Error: Estructura de jerarquía incompleta</p>';
    }
    
    console.log('✅ Construyendo HTML con:', { empresa: empresa.nombre, numAreas: areas.length });
    
    // Helper para escapar HTML
    const escapeHtml = (text) => {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    };
    
    let html = '<div class="jerarquia-tree" style="font-family: monospace; font-size: 0.9rem;">';
    
    // N1: Empresa (único, no expandible)
    html += `
      <div class="tree-node" style="margin-bottom: 16px; padding: 10px; background: var(--bg-secondary); border-radius: 6px; border-left: 4px solid #6366f1;">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="color: var(--text-primary); font-weight: 600;">${escapeHtml(empresa.nombre)}</span>
          </div>
          <button class="tree-action-btn" onclick="app.editarNodoJerarquia('empresa', null)" 
                  style="opacity: 0; transition: opacity 0.2s; background: var(--info); color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem;"
                  onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
            ✏️ Editar
          </button>
        </div>
      </div>
    `;
    
    // N2: Áreas
    html += `
      <div class="tree-node-hover" style="margin-left: 0px; margin-bottom: 4px; padding: 8px; background: var(--bg-primary); border-radius: 6px;">
        ${areas.map((area, aIdx) => this.buildAreaHTML(area, aIdx, escapeHtml)).join('')}
        <div class="tree-actions">
          <button onclick="app.agregarNodoJerarquia('area', null)" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 0.75rem; margin-top: 6px;">
            + Área
          </button>
        </div>
      </div>
    `;
    
    html += '</div>';
    return html;
  }
  
  buildAreaHTML(area, aIdx, escapeHtml) {
    const childrenId = `area_children_${aIdx}`;
    const subAreasCount = area.subAreas ? area.subAreas.length : 0;
    
    // Obtener estado guardado (closed por defecto)
    const isOpen = this.getTreeNodeState(childrenId) === 'open';
    const displayStyle = isOpen ? 'block' : 'none';
    
    return `
      <div style="margin-bottom: 4px; padding-left: 0px;">
        <div class="tree-node-hover" style="display: flex; align-items: center; gap: 8px; padding: 6px; background: var(--bg-secondary); border-radius: 4px;">
          <span style="flex: 1; color: var(--text-primary); font-weight: 500; cursor: pointer;" onclick="app.toggleTreeChildren('${childrenId}')">${escapeHtml(area.nombre)}</span>
          <div class="tree-actions" style="gap: 4px;">
            <button onclick="app.editarNodoJerarquia('area', ${aIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 0.7rem;">Editar</button>
            <button onclick="app.eliminarNodoJerarquia('area', ${aIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 0.7rem;">Eliminar</button>
            <button onclick="app.agregarNodoJerarquia('subArea', ${aIdx})" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 0.7rem;">+ Sub-Área</button>
          </div>
        </div>
        <div id="${childrenId}" style="display: ${displayStyle}; margin-top: 4px; margin-left: 20px;">
          ${area.subAreas && area.subAreas.length > 0 
            ? area.subAreas.map((subArea, saIdx) => this.buildSubAreaHTML(subArea, aIdx, saIdx, escapeHtml)).join('')
            : '<div style="color: var(--text-secondary); font-size: 0.75rem; padding: 4px; font-style: italic;">Sin sub-áreas</div>'
          }
        </div>
      </div>
    `;
  }
  
  buildSubAreaHTML(subArea, aIdx, saIdx, escapeHtml) {
    const childrenId = `subarea_children_${aIdx}_${saIdx}`;
    const sistemasCount = subArea.sistemas ? subArea.sistemas.length : 0;
    
    // Obtener estado guardado (closed por defecto)
    const isOpen = this.getTreeNodeState(childrenId) === 'open';
    const displayStyle = isOpen ? 'block' : 'none';
    
    return `
      <div style="margin-bottom: 3px; padding-left: 0px;">
        <div class="tree-node-hover" style="display: flex; align-items: center; gap: 6px; padding: 4px; background: var(--bg-tertiary); border-radius: 3px;">
          <span style="flex: 1; color: var(--text-primary); font-size: 0.85rem; cursor: pointer;" onclick="app.toggleTreeChildren('${childrenId}')">${escapeHtml(subArea.nombre)}</span>
          <div class="tree-actions" style="gap: 3px;">
            <button onclick="app.editarNodoJerarquia('subArea', ${aIdx}, ${saIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 1px 5px; border-radius: 2px; cursor: pointer; font-size: 0.65rem;">Editar</button>
            <button onclick="app.eliminarNodoJerarquia('subArea', ${aIdx}, ${saIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 1px 5px; border-radius: 2px; cursor: pointer; font-size: 0.65rem;">Eliminar</button>
            <button onclick="app.agregarNodoJerarquia('sistema', ${aIdx}, ${saIdx})" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 1px 5px; border-radius: 2px; cursor: pointer; font-size: 0.65rem;">+ Sistema</button>
          </div>
        </div>
        <div id="${childrenId}" style="display: ${displayStyle}; margin-top: 3px; margin-left: 16px;">
          ${subArea.sistemas && subArea.sistemas.length > 0
            ? subArea.sistemas.map((sistema, sIdx) => this.buildSistemaHTML(sistema, aIdx, saIdx, sIdx, escapeHtml)).join('')
            : '<div style="color: var(--text-secondary); font-size: 0.7rem; padding: 3px; font-style: italic;">Sin sistemas</div>'
          }
        </div>
      </div>
    `;
  }
  
  buildSistemaHTML(sistema, aIdx, saIdx, sIdx, escapeHtml) {
    const childrenId = `sistema_children_${aIdx}_${saIdx}_${sIdx}`;
    const subSistemasCount = sistema.subSistemas ? sistema.subSistemas.length : 0;
    
    // Obtener estado guardado (closed por defecto)
    const isOpen = this.getTreeNodeState(childrenId) === 'open';
    const displayStyle = isOpen ? 'block' : 'none';
    
    return `
      <div style="margin-bottom: 2px; padding-left: 0px;">
        <div class="tree-node-hover" style="display: flex; align-items: center; gap: 4px; padding: 3px 6px; background: var(--bg-secondary); border-radius: 3px;">
          <span style="flex: 1; color: var(--text-primary); font-size: 0.75rem; cursor: pointer;" onclick="app.toggleTreeChildren('${childrenId}')">• ${escapeHtml(sistema.nombre)}</span>
          <div class="tree-actions" style="gap: 2px;">
            <button onclick="app.editarNodoJerarquia('sistema', ${aIdx}, ${saIdx}, ${sIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 1px 4px; border-radius: 2px; cursor: pointer; font-size: 0.6rem;">Editar</button>
            <button onclick="app.eliminarNodoJerarquia('sistema', ${aIdx}, ${saIdx}, ${sIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 1px 4px; border-radius: 2px; cursor: pointer; font-size: 0.6rem;">Eliminar</button>
            <button onclick="app.agregarNodoJerarquia('subSistema', ${aIdx}, ${saIdx}, ${sIdx})" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 1px 4px; border-radius: 2px; cursor: pointer; font-size: 0.6rem;">+ Sub-Sistema</button>
          </div>
        </div>
        <div id="${childrenId}" style="display: ${displayStyle}; margin-top: 2px; margin-left: 12px;">
          ${sistema.subSistemas && sistema.subSistemas.length > 0
            ? sistema.subSistemas.map((subSistema, ssIdx) => this.buildSubSistemaHTML(subSistema, aIdx, saIdx, sIdx, ssIdx, escapeHtml)).join('')
            : '<div style="color: var(--text-secondary); font-size: 0.65rem; padding: 2px; font-style: italic;">Sin sub-sistemas</div>'
          }
        </div>
      </div>
    `;
  }
  
  buildSubSistemaHTML(subSistema, aIdx, saIdx, sIdx, ssIdx, escapeHtml) {
    const childrenId = `subsistema_children_${aIdx}_${saIdx}_${sIdx}_${ssIdx}`;
    const seccionesCount = subSistema.secciones ? subSistema.secciones.length : 0;
    
    // Obtener estado guardado (closed por defecto)
    const isOpen = this.getTreeNodeState(childrenId) === 'open';
    const displayStyle = isOpen ? 'block' : 'none';
    
    return `
      <div style="margin-bottom: 2px; padding-left: 0px;">
        <div class="tree-node-hover" style="display: flex; align-items: center; gap: 4px; padding: 2px 5px; background: var(--bg-tertiary); border-radius: 2px;">
          <span style="flex: 1; color: var(--text-primary); font-size: 0.7rem; cursor: pointer;" onclick="app.toggleTreeChildren('${childrenId}')">◦ ${escapeHtml(subSistema.nombre)}</span>
          <div class="tree-actions" style="gap: 2px;">
            <button onclick="app.editarNodoJerarquia('subSistema', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.55rem;">Editar</button>
            <button onclick="app.eliminarNodoJerarquia('subSistema', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.55rem;">Eliminar</button>
            <button onclick="app.agregarNodoJerarquia('seccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx})" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.55rem;">+ Sección</button>
          </div>
        </div>
        <div id="${childrenId}" style="display: ${displayStyle}; margin-top: 2px; margin-left: 10px;">
          ${subSistema.secciones && subSistema.secciones.length > 0
            ? subSistema.secciones.map((seccion, secIdx) => this.buildSeccionHTML(seccion, aIdx, saIdx, sIdx, ssIdx, secIdx, escapeHtml)).join('')
            : '<div style="color: var(--text-secondary); font-size: 0.6rem; padding: 2px; font-style: italic;">Sin secciones</div>'
          }
        </div>
      </div>
    `;
  }
  
  buildSeccionHTML(seccion, aIdx, saIdx, sIdx, ssIdx, secIdx, escapeHtml) {
    const childrenId = `seccion_children_${aIdx}_${saIdx}_${sIdx}_${ssIdx}_${secIdx}`;
    const subSeccionesCount = seccion.subSecciones ? seccion.subSecciones.length : 0;
    
    // Obtener estado guardado (closed por defecto)
    const isOpen = this.getTreeNodeState(childrenId) === 'open';
    const displayStyle = isOpen ? 'block' : 'none';
    
    return `
      <div style="margin-bottom: 1px; padding-left: 0px;">
        <div class="tree-node-hover" style="display: flex; align-items: center; gap: 3px; padding: 2px 4px; background: var(--bg-secondary); border-radius: 2px;">
          <span style="flex: 1; color: var(--text-primary); font-size: 0.65rem; cursor: pointer;" onclick="app.toggleTreeChildren('${childrenId}')">▪ ${escapeHtml(seccion.nombre)}</span>
          <div class="tree-actions" style="gap: 1px;">
            <button onclick="app.editarNodoJerarquia('seccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx}, ${secIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.5rem;">Editar</button>
            <button onclick="app.eliminarNodoJerarquia('seccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx}, ${secIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.5rem;">Eliminar</button>
            <button onclick="app.agregarNodoJerarquia('subSeccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx}, ${secIdx})" style="background: none; border: 1px solid var(--success); color: var(--success); padding: 0px 3px; border-radius: 2px; cursor: pointer; font-size: 0.5rem;">+ Sub-Sección</button>
          </div>
        </div>
        <div id="${childrenId}" style="display: ${displayStyle}; margin-top: 1px; margin-left: 8px;">
          ${seccion.subSecciones && seccion.subSecciones.length > 0
            ? seccion.subSecciones.map((subSeccion, sSecIdx) => this.buildSubSeccionHTML(subSeccion, aIdx, saIdx, sIdx, ssIdx, secIdx, sSecIdx, escapeHtml)).join('')
            : '<div style="color: var(--text-secondary); font-size: 0.55rem; padding: 1px; font-style: italic;">Sin sub-secciones</div>'
          }
        </div>
      </div>
    `;
  }
  
  buildSubSeccionHTML(subSeccion, aIdx, saIdx, sIdx, ssIdx, secIdx, sSecIdx, escapeHtml) {
    return `
      <div class="tree-node-hover" style="margin-bottom: 1px; padding: 1px 3px; background: var(--bg-tertiary); border-radius: 2px; display: flex; align-items: center; gap: 2px;">
        <span style="flex: 1; color: var(--text-primary); font-size: 0.6rem;">- ${escapeHtml(subSeccion.nombre)}</span>
        <div class="tree-actions" style="gap: 1px;">
          <button onclick="app.editarNodoJerarquia('subSeccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx}, ${secIdx}, ${sSecIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 2px; border-radius: 1px; cursor: pointer; font-size: 0.5rem;">Editar</button>
          <button onclick="app.eliminarNodoJerarquia('subSeccion', ${aIdx}, ${saIdx}, ${sIdx}, ${ssIdx}, ${secIdx}, ${sSecIdx})" style="background: none; border: 1px solid var(--border-color); color: var(--text-primary); padding: 0px 2px; border-radius: 1px; cursor: pointer; font-size: 0.5rem;">Eliminar</button>
        </div>
      </div>
    `;
  }
  
  toggleTreeNode(nodeId) {
    const node = document.getElementById(nodeId);
    if (!node) return;
    
    const toggle = document.querySelector(`[onclick*="'${nodeId}'"]`);
    if (node.style.display === 'none') {
      node.style.display = 'block';
      if (toggle) toggle.textContent = '▼';
    } else {
      node.style.display = 'none';
      if (toggle) toggle.textContent = '▶';
    }
  }
  
  toggleTreeChildren(childrenId) {
    const children = document.getElementById(childrenId);
    if (!children) return;
    
    if (children.style.display === 'none') {
      children.style.display = 'block';
      // Guardar estado expandido
      localStorage.setItem('tree-' + childrenId, 'open');
    } else {
      children.style.display = 'none';
      // Guardar estado colapsado
      localStorage.setItem('tree-' + childrenId, 'closed');
    }
  }
  
  /**
   * 🔄 SINCRONIZAR JERARQUÍA DESDE UBICACIONES
   * Agrega automáticamente nodos al árbol de jerarquía cuando se guarda un repuesto
   */
  sincronizarJerarquiaDesdeUbicaciones(ubicaciones) {
    if (!ubicaciones || ubicaciones.length === 0) {
      console.log('⚠️ No hay ubicaciones para sincronizar');
      return;
    }
    
    if (!this.jerarquiaAnidada || !this.jerarquiaAnidada.areas) {
      console.log('⚠️ jerarquiaAnidada no está inicializada');
      return;
    }
    
    console.log('🔄 Iniciando sincronización de jerarquía...', ubicaciones);
    let cambiosRealizados = false;
    
    ubicaciones.forEach((ubicacion, idx) => {
      console.log(`\n📍 Procesando ubicación ${idx + 1}:`, ubicacion);
      
      // Nivel 2: Área General (OBLIGATORIO)
      if (!ubicacion.areaGeneral) {
        console.log('  ⚠️ Sin área general, saltando');
        return;
      }
      
      let area = this.jerarquiaAnidada.areas.find(a => a.nombre === ubicacion.areaGeneral);
      if (!area) {
        area = {
          id: `area_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.areaGeneral,
          subAreas: []
        };
        this.jerarquiaAnidada.areas.push(area);
        console.log(`  ✅ Área creada: "${ubicacion.areaGeneral}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Área ya existe: "${ubicacion.areaGeneral}"`);
      }
      
      // Nivel 3: Sub-Área (OPCIONAL)
      if (!ubicacion.subArea) {
        console.log('  ℹ️ Sin sub-área, deteniendo en nivel 2');
        return;
      }
      
      if (!area.subAreas) area.subAreas = [];
      let subArea = area.subAreas.find(sa => sa.nombre === ubicacion.subArea);
      if (!subArea) {
        subArea = {
          id: `subarea_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.subArea,
          sistemas: []
        };
        area.subAreas.push(subArea);
        console.log(`  ✅ Sub-Área creada: "${ubicacion.subArea}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Sub-Área ya existe: "${ubicacion.subArea}"`);
      }
      
      // Nivel 4: Sistema (OPCIONAL)
      if (!ubicacion.sistemaEquipo) {
        console.log('  ℹ️ Sin sistema, deteniendo en nivel 3');
        return;
      }
      
      if (!subArea.sistemas) subArea.sistemas = [];
      let sistema = subArea.sistemas.find(s => s.nombre === ubicacion.sistemaEquipo);
      if (!sistema) {
        sistema = {
          id: `sistema_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.sistemaEquipo,
          subSistemas: []
        };
        subArea.sistemas.push(sistema);
        console.log(`  ✅ Sistema creado: "${ubicacion.sistemaEquipo}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Sistema ya existe: "${ubicacion.sistemaEquipo}"`);
      }
      
      // Nivel 5: Sub-Sistema (OPCIONAL)
      if (!ubicacion.subSistema) {
        console.log('  ℹ️ Sin sub-sistema, deteniendo en nivel 4');
        return;
      }
      
      if (!sistema.subSistemas) sistema.subSistemas = [];
      let subSistema = sistema.subSistemas.find(ss => ss.nombre === ubicacion.subSistema);
      if (!subSistema) {
        subSistema = {
          id: `subsistema_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.subSistema,
          secciones: []
        };
        sistema.subSistemas.push(subSistema);
        console.log(`  ✅ Sub-Sistema creado: "${ubicacion.subSistema}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Sub-Sistema ya existe: "${ubicacion.subSistema}"`);
      }
      
      // Nivel 6: Sección (OPCIONAL)
      if (!ubicacion.seccion) {
        console.log('  ℹ️ Sin sección, deteniendo en nivel 5');
        return;
      }
      
      if (!subSistema.secciones) subSistema.secciones = [];
      let seccion = subSistema.secciones.find(sec => sec.nombre === ubicacion.seccion);
      if (!seccion) {
        seccion = {
          id: `seccion_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.seccion,
          subSecciones: []
        };
        subSistema.secciones.push(seccion);
        console.log(`  ✅ Sección creada: "${ubicacion.seccion}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Sección ya existe: "${ubicacion.seccion}"`);
      }
      
      // Nivel 7: Sub-Sección (OPCIONAL)
      if (!ubicacion.subSeccion) {
        console.log('  ℹ️ Sin sub-sección, deteniendo en nivel 6');
        return;
      }
      
      if (!seccion.subSecciones) seccion.subSecciones = [];
      let subSeccion = seccion.subSecciones.find(ssec => ssec.nombre === ubicacion.subSeccion);
      if (!subSeccion) {
        subSeccion = {
          id: `subseccion_${Date.now()}_${Math.random()}`,
          nombre: ubicacion.subSeccion
        };
        seccion.subSecciones.push(subSeccion);
        console.log(`  ✅ Sub-Sección creada: "${ubicacion.subSeccion}"`);
        cambiosRealizados = true;
      } else {
        console.log(`  ℹ️ Sub-Sección ya existe: "${ubicacion.subSeccion}"`);
      }
    });
    
    if (cambiosRealizados) {
      this.saveJerarquiaAnidada();
      console.log('💾 Jerarquía sincronizada y guardada');
      
      // Actualizar UI si está en la tab de configuración
      if (this.currentTab === 'configuracion') {
        this.renderJerarquiaTree();
        console.log('🔄 Árbol de jerarquía actualizado en UI');
      }
    } else {
      console.log('ℹ️ No se realizaron cambios - todos los nodos ya existían');
    }
  }

  /**
   * Obtiene el estado guardado de un nodo del árbol
   * Por defecto retorna 'closed' (colapsado)
   */
  getTreeNodeState(childrenId) {
    return localStorage.getItem('tree-' + childrenId) || 'closed';
  }
  
  async agregarNodoJerarquia(tipo, ...indices) {
    const labels = {
      area: 'Nueva Área (N2)',
      subArea: 'Nueva Sub-Área (N3)',
      sistema: 'Nuevo Sistema (N4)',
      subSistema: 'Nuevo Sub-Sistema (N5)',
      seccion: 'Nueva Sección (N6)',
      subSeccion: 'Nueva Sub-Sección (N7)'
    };
    
    const label = labels[tipo] || 'Nuevo Elemento';
    const nombre = await this.showInputModal(`Ingrese el nombre para: ${label}`, '');
    
    if (!nombre || nombre.trim() === '') {
      this.showToast('⚠️ Operación cancelada', 'warning');
      return;
    }
    
    const nuevoNodo = {
      id: `${tipo}_${Date.now()}`,
      nombre: nombre.trim()
    };
    
    // Agregar arrays hijos según el tipo
    if (tipo === 'area') nuevoNodo.subAreas = [];
    if (tipo === 'subArea') nuevoNodo.sistemas = [];
    if (tipo === 'sistema') nuevoNodo.subSistemas = [];
    if (tipo === 'subSistema') nuevoNodo.secciones = [];
    if (tipo === 'seccion') nuevoNodo.subSecciones = [];
    
    // Insertar en la ubicación correcta
    try {
      if (tipo === 'area') {
        this.jerarquiaAnidada.areas.push(nuevoNodo);
      } else if (tipo === 'subArea') {
        const [aIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas.push(nuevoNodo);
      } else if (tipo === 'sistema') {
        const [aIdx, saIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas.push(nuevoNodo);
      } else if (tipo === 'subSistema') {
        const [aIdx, saIdx, sIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas.push(nuevoNodo);
      } else if (tipo === 'seccion') {
        const [aIdx, saIdx, sIdx, ssIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones.push(nuevoNodo);
      } else if (tipo === 'subSeccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx].subSecciones.push(nuevoNodo);
      }
      
      this.saveJerarquiaAnidada();
      this.renderJerarquiaTree();
      this.showToast(`✅ ${label} agregado: ${nombre}`, 'success');
    } catch (error) {
      console.error('Error agregando nodo:', error);
      this.showToast('❌ Error al agregar elemento', 'error');
    }
  }
  
  async editarNodoJerarquia(tipo, ...indices) {
    try {
      let nodo;
      let label = 'Elemento';
      
      if (tipo === 'empresa') {
        nodo = this.jerarquiaAnidada.empresa;
        label = 'Empresa (N1)';
      } else if (tipo === 'area') {
        const [aIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx];
        label = 'Área (N2)';
      } else if (tipo === 'subArea') {
        const [aIdx, saIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx];
        label = 'Sub-Área (N3)';
      } else if (tipo === 'sistema') {
        const [aIdx, saIdx, sIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx];
        label = 'Sistema (N4)';
      } else if (tipo === 'subSistema') {
        const [aIdx, saIdx, sIdx, ssIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx];
        label = 'Sub-Sistema (N5)';
      } else if (tipo === 'seccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx];
        label = 'Sección (N6)';
      } else if (tipo === 'subSeccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx, subSecIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx].subSecciones[subSecIdx];
        label = 'Sub-Sección (N7)';
      }
      
      if (!nodo) {
        this.showToast('❌ Elemento no encontrado', 'error');
        return;
      }
      
      const nuevoNombre = await this.showInputModal(`Editar nombre de ${label}:`, nodo.nombre);
      
      if (nuevoNombre === null) {
        this.showToast('⚠️ Operación cancelada', 'warning');
        return;
      }
      
      if (nuevoNombre.trim() === '') {
        this.showToast('⚠️ El nombre no puede estar vacío', 'warning');
        return;
      }
      
      nodo.nombre = nuevoNombre.trim();
      this.saveJerarquiaAnidada();
      this.renderJerarquiaTree();
      this.showToast(`✅ ${label} actualizado`, 'success');
      
    } catch (error) {
      console.error('Error editando nodo:', error);
      this.showToast('❌ Error al editar elemento', 'error');
    }
  }
  
  async eliminarNodoJerarquia(tipo, ...indices) {
    try {
      let nodo, label, tieneHijos = false;
      
      if (tipo === 'empresa') {
        this.showToast('⚠️ No se puede eliminar la empresa raíz', 'warning');
        return;
      } else if (tipo === 'area') {
        const [aIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx];
        label = 'Área';
        tieneHijos = nodo.subAreas && nodo.subAreas.length > 0;
      } else if (tipo === 'subArea') {
        const [aIdx, saIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx];
        label = 'Sub-Área';
        tieneHijos = nodo.sistemas && nodo.sistemas.length > 0;
      } else if (tipo === 'sistema') {
        const [aIdx, saIdx, sIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx];
        label = 'Sistema';
        tieneHijos = nodo.subSistemas && nodo.subSistemas.length > 0;
      } else if (tipo === 'subSistema') {
        const [aIdx, saIdx, sIdx, ssIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx];
        label = 'Sub-Sistema';
        tieneHijos = nodo.secciones && nodo.secciones.length > 0;
      } else if (tipo === 'seccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx];
        label = 'Sección';
        tieneHijos = nodo.subSecciones && nodo.subSecciones.length > 0;
      } else if (tipo === 'subSeccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx, subSecIdx] = indices;
        nodo = this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx].subSecciones[subSecIdx];
        label = 'Sub-Sección';
        tieneHijos = false;
      }
      
      if (!nodo) {
        this.showToast('❌ Elemento no encontrado', 'error');
        return;
      }
      
      if (tieneHijos) {
        this.showToast(`⚠️ No se puede eliminar "${nodo.nombre}" porque tiene elementos hijos. Elimina primero los hijos.`, 'warning');
        return;
      }
      
      const confirmar = await this.showConfirmModal(`¿Está seguro de eliminar "${nodo.nombre}"?\n\nEsta acción no se puede deshacer.`);
      
      if (!confirmar) {
        this.showToast('⚠️ Operación cancelada', 'warning');
        return;
      }
      
      // Eliminar el nodo
      if (tipo === 'area') {
        const [aIdx] = indices;
        this.jerarquiaAnidada.areas.splice(aIdx, 1);
      } else if (tipo === 'subArea') {
        const [aIdx, saIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas.splice(saIdx, 1);
      } else if (tipo === 'sistema') {
        const [aIdx, saIdx, sIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas.splice(sIdx, 1);
      } else if (tipo === 'subSistema') {
        const [aIdx, saIdx, sIdx, ssIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas.splice(ssIdx, 1);
      } else if (tipo === 'seccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones.splice(secIdx, 1);
      } else if (tipo === 'subSeccion') {
        const [aIdx, saIdx, sIdx, ssIdx, secIdx, subSecIdx] = indices;
        this.jerarquiaAnidada.areas[aIdx].subAreas[saIdx].sistemas[sIdx].subSistemas[ssIdx].secciones[secIdx].subSecciones.splice(subSecIdx, 1);
      }
      
      this.saveJerarquiaAnidada();
      this.renderJerarquiaTree();
      this.showToast(`✅ ${label} eliminado: ${nodo.nombre}`, 'success');
      
    } catch (error) {
      console.error('Error eliminando nodo:', error);
      this.showToast('❌ Error al eliminar elemento', 'error');
    }
  }
  
  guardarCambiosJerarquia() {
    this.saveJerarquiaAnidada();
    this.showToast('✅ Jerarquía guardada correctamente', 'success');
    document.getElementById('btnGuardarJerarquia').style.display = 'none';
  }
  
  marcarCambiosPendientesJerarquia() {
    const btn = document.getElementById('btnGuardarJerarquia');
    if (btn) btn.style.display = 'block';
  }

  // 🗺️ NUEVO: Agregar nueva categoría de área
  agregarNuevaCategoria() {
    const modal = document.getElementById('modal');
    const modalContent = document.querySelector('.modal-content');
    
    if (!modal || !modalContent) {
      console.error('Modal no encontrado');
      return;
    }

    modalContent.innerHTML = `
      <span class="close" onclick="app.cerrarModalCategoria()">&times;</span>
      <h2 style="color: var(--primary); margin-bottom: 20px; font-size: 1.5rem;">➕ Nueva Categoría de Área</h2>
      <form id="formNuevaCategoria" style="display: flex; flex-direction: column; gap: 16px;">
        
        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            ID de la Categoría *
          </label>
          <input type="text" id="categoriaId" required 
                 placeholder="ej: plataforma, tanque, bomba"
                 style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.95rem;">
          <small style="color: var(--text-muted); font-size: 0.75rem; display: block; margin-top: 4px;">
            Solo minúsculas, sin espacios ni caracteres especiales
          </small>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 12px;">
          <div>
            <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
              Icono * (Emoji)
            </label>
            <input type="text" id="categoriaIcon" required maxlength="2"
                   placeholder="🏭"
                   style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 1.5rem; text-align: center;">
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
              Nombre *
            </label>
            <input type="text" id="categoriaName" required 
                   placeholder="ej: Plataforma"
                   style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.95rem;">
          </div>
        </div>

        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            Color *
          </label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="categoriaColor" required value="#3b82f6"
                   style="width: 60px; height: 40px; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer; background: none;">
            <input type="text" id="categoriaColorHex" value="#3b82f6" pattern="^#[0-9A-Fa-f]{6}$"
                   placeholder="#3b82f6"
                   style="flex: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 0.95rem;">
          </div>
        </div>

        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            Descripción *
          </label>
          <textarea id="categoriaDescription" required rows="2"
                    placeholder="Descripción breve de esta categoría"
                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.9rem; resize: vertical; font-family: inherit;"></textarea>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 10px;">
          <button type="submit" 
                  style="flex: 1; background: var(--success); color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
            ✅ Crear Categoría
          </button>
          <button type="button" onclick="app.cerrarModalCategoria()" 
                  style="flex: 1; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
            ❌ Cancelar
          </button>
        </div>
      </form>
    `;

    modal.style.display = 'block';

    // Sincronizar color picker con input hex
    setTimeout(() => {
      const colorInput = document.getElementById('categoriaColor');
      const hexInput = document.getElementById('categoriaColorHex');
      
      if (colorInput && hexInput) {
        colorInput.addEventListener('input', () => {
          hexInput.value = colorInput.value;
        });
        
        hexInput.addEventListener('input', () => {
          if (/^#[0-9A-Fa-f]{6}$/.test(hexInput.value)) {
            colorInput.value = hexInput.value;
          }
        });
      }

      // Manejar envío del formulario
      const form = document.getElementById('formNuevaCategoria');
      if (form) {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          this.guardarNuevaCategoria();
        });
      }
    }, 100);
  }

  // 🗺️ NUEVO: Guardar nueva categoría
  guardarNuevaCategoria() {
    const id = document.getElementById('categoriaId').value.trim().toLowerCase();
    const icon = document.getElementById('categoriaIcon').value.trim();
    const name = document.getElementById('categoriaName').value.trim();
    const color = document.getElementById('categoriaColor').value;
    const description = document.getElementById('categoriaDescription').value.trim();

    // Validar ID
    if (!/^[a-z0-9_]+$/.test(id)) {
      this.showToast('❌ El ID solo puede contener letras minúsculas, números y guiones bajos', 'error');
      return;
    }

    // Verificar si ya existe
    if (mapController.categories[id]) {
      this.showToast('❌ Ya existe una categoría con este ID', 'error');
      return;
    }

    // Agregar nueva categoría
    mapController.categories[id] = {
      icon: icon,
      name: name,
      color: color,
      description: description
    };

    // Guardar en localStorage
    localStorage.setItem('mapCategories', JSON.stringify(mapController.categories));

    this.showToast(`✅ Categoría "${name}" creada exitosamente`, 'success');
    this.renderCategoriasAreasConfig();
    mapController.renderAreasList(); // Actualizar lista de áreas
    this.cerrarModalCategoria();
  }

  // 🗺️ NUEVO: Cerrar modal de categorías
  cerrarModalCategoria() {
    const modal = document.getElementById('modal');
    if (modal) {
      modal.style.display = 'none';
      const modalContent = document.querySelector('.modal-content');
      if (modalContent) {
        modalContent.innerHTML = '';
      }
    }
  }

  // 🗺️ NUEVO: Editar categoría existente
  editarCategoria(categoryId) {
    const category = mapController.categories[categoryId];
    if (!category) return;

    const modal = document.getElementById('modal');
    const modalContent = document.querySelector('.modal-content');
    
    if (!modal || !modalContent) {
      console.error('Modal no encontrado');
      return;
    }

    modalContent.innerHTML = `
      <span class="close" onclick="app.cerrarModalCategoria()">&times;</span>
      <h2 style="color: var(--primary); margin-bottom: 20px; font-size: 1.5rem;">✏️ Editar Categoría: ${category.name}</h2>
      <form id="formEditarCategoria" style="display: flex; flex-direction: column; gap: 16px;">
        
        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            ID de la Categoría
          </label>
          <input type="text" value="${categoryId}" disabled
                 style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-tertiary); color: var(--text-muted); font-size: 0.95rem; cursor: not-allowed;">
          <small style="color: var(--text-muted); font-size: 0.75rem; display: block; margin-top: 4px;">
            El ID no se puede modificar
          </small>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 12px;">
          <div>
            <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
              Icono * (Emoji)
            </label>
            <input type="text" id="editCategoriaIcon" required maxlength="2" value="${category.icon}"
                   style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 1.5rem; text-align: center;">
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
              Nombre *
            </label>
            <input type="text" id="editCategoriaName" required value="${category.name}"
                   style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.95rem;">
          </div>
        </div>

        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            Color *
          </label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="editCategoriaColor" required value="${category.color}"
                   style="width: 60px; height: 40px; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer; background: none;">
            <input type="text" id="editCategoriaColorHex" value="${category.color}" pattern="^#[0-9A-Fa-f]{6}$"
                   style="flex: 1; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-family: monospace; font-size: 0.95rem;">
          </div>
        </div>

        <div>
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary); font-weight: 600; font-size: 0.85rem;">
            Descripción *
          </label>
          <textarea id="editCategoriaDescription" required rows="2"
                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); font-size: 0.9rem; resize: vertical; font-family: inherit;">${category.description}</textarea>
        </div>

        <div style="display: flex; gap: 10px; margin-top: 10px;">
          <button type="submit" 
                  style="flex: 1; background: var(--info); color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
            💾 Guardar Cambios
          </button>
          <button type="button" onclick="app.cerrarModalCategoria()" 
                  style="flex: 1; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 1rem;">
            ❌ Cancelar
          </button>
        </div>
      </form>
    `;

    modal.style.display = 'block';

    // Sincronizar color picker con input hex
    setTimeout(() => {
      const colorInput = document.getElementById('editCategoriaColor');
      const hexInput = document.getElementById('editCategoriaColorHex');
      
      if (colorInput && hexInput) {
        colorInput.addEventListener('input', () => {
          hexInput.value = colorInput.value;
        });
        
        hexInput.addEventListener('input', () => {
          if (/^#[0-9A-Fa-f]{6}$/.test(hexInput.value)) {
            colorInput.value = hexInput.value;
          }
        });
      }

      // Manejar envío del formulario
      const form = document.getElementById('formEditarCategoria');
      if (form) {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          app.actualizarCategoria('${categoryId}');
        });
      }
    }, 100);
  }

  // 🗺️ NUEVO: Actualizar categoría
  actualizarCategoria(categoryId) {
    const icon = document.getElementById('editCategoriaIcon').value.trim();
    const name = document.getElementById('editCategoriaName').value.trim();
    const color = document.getElementById('editCategoriaColor').value;
    const description = document.getElementById('editCategoriaDescription').value.trim();

    // Actualizar categoría
    mapController.categories[categoryId] = {
      icon: icon,
      name: name,
      color: color,
      description: description
    };

    // Guardar en localStorage
    localStorage.setItem('mapCategories', JSON.stringify(mapController.categories));

    // Actualizar todas las áreas que usan esta categoría (para reflejar cambios de color)
    mapController.state.areas.forEach(area => {
      if (area.category === categoryId) {
        area.color = color;
      }
    });
    mapController.saveAreas();
    mapController.draw();

    this.showToast(`✅ Categoría "${name}" actualizada exitosamente`, 'success');
    this.renderCategoriasAreasConfig();
    mapController.renderAreasList();
    this.cerrarModalCategoria();
  }

  // 🗺️ NUEVO: Eliminar categoría
  eliminarCategoria(categoryId) {
    const category = mapController.categories[categoryId];
    if (!category) return;

    // Contar áreas que usan esta categoría
    const areasUsandoCategoria = mapController.state.areas.filter(a => a.category === categoryId).length;

    let mensaje = `¿Eliminar la categoría "${category.name}"?`;
    if (areasUsandoCategoria > 0) {
      mensaje += `\n\n⚠️ ADVERTENCIA: ${areasUsandoCategoria} área(s) del mapa usan esta categoría.\nSe restablecerán a la categoría por defecto "Área".`;
    }

    if (!confirm(mensaje)) return;

    // Restablecer categoría en áreas afectadas
    if (areasUsandoCategoria > 0) {
      mapController.state.areas.forEach(area => {
        if (area.category === categoryId) {
          area.category = 'area';
          area.color = mapController.categories.area.color;
        }
      });
      mapController.saveAreas();
      mapController.draw();
      mapController.renderAreasList();
    }

    // Eliminar categoría
    delete mapController.categories[categoryId];
    localStorage.setItem('mapCategories', JSON.stringify(mapController.categories));

    this.showToast(`✅ Categoría "${category.name}" eliminada`, 'success');
    this.renderCategoriasAreasConfig();
  }

  setupAutocomplete() {
    ['codProv', 'tipo', 'area', 'equipo'].forEach(field => {
      const input = document.getElementById(field);
      const list = document.getElementById(`autocomplete-${field}`);
      
      if (!input || !list) return;

      input.addEventListener('input', () => {
        const value = input.value.trim();
        if (!value) {
          list.classList.remove('active');
          return;
        }

        const suggestions = this.autocompleteData[field].filter(item =>
          item.toLowerCase().includes(value.toLowerCase())
        );

        if (suggestions.length === 0) {
          list.classList.remove('active');
          return;
        }

        list.innerHTML = suggestions.map(item => `
          <div class="autocomplete-item" onclick="app.selectAutocomplete('${field}', '${item.replace(/'/g, "\\'")}')">
            ${item}
          </div>
        `).join('');
        list.classList.add('active');
      });

      input.addEventListener('blur', () => {
        setTimeout(() => list.classList.remove('active'), 200);
      });
    });
  }

  selectAutocomplete(field, value) {
    document.getElementById(field).value = value;
    document.getElementById(`autocomplete-${field}`).classList.remove('active');
  }

  async openLightbox(id) {
    console.log('🖼️ openLightbox llamado con ID:', id);
    
    const repuesto = this.repuestos.find(r => r.id === id);
    console.log('📦 Repuesto encontrado:', repuesto ? repuesto.nombre : 'NO ENCONTRADO');
    
    if (!repuesto) {
      console.error('❌ No se encontró el repuesto con ID:', id);
      return;
    }
    
    if (!repuesto.multimedia || repuesto.multimedia.length === 0) {
      console.warn('⚠️ El repuesto no tiene multimedia');
      return;
    }
    
    this.lightboxMedias = repuesto.multimedia.filter(m => m.type === 'image' || m.type === 'video');
    console.log('🖼️ Medios encontrados:', this.lightboxMedias.length);
    
    if (this.lightboxMedias.length === 0) {
      console.warn('⚠️ No hay imágenes o videos para mostrar');
      return;
    }
    
    this.lightboxIndex = 0;
    
    // Mostrar lightbox primero
    const lightbox = document.getElementById('lightbox');
    console.log('🎬 Activando lightbox...');
    lightbox.classList.add('active');
    
    // Luego cargar la imagen
    console.log('⏳ Cargando imagen...');
    await this.showLightbox();
    console.log('✅ Lightbox mostrado');
  }

  async showLightbox() {
    const media = this.lightboxMedias[this.lightboxIndex];
    const content = document.getElementById('lightboxContent');
    
    // Mostrar loading mientras se carga
    content.innerHTML = '<div style="color: white; text-align: center; padding: 40px;">Cargando...</div>';
    
    if (media.type === 'video') {
      content.innerHTML = `<video src="${media.url}" controls autoplay style="max-width: 100%; max-height: 90vh;"></video>`;
    } else {
      // Si es FileSystem, la URL ya es un Blob URL generado por getFirstImage
      // Solo necesitamos usarla directamente
      let imageUrl = media.url;
      
      // Si la imagen está en FileSystem pero no tiene Blob URL, cargarla
      if (media.isFileSystem && fsManager.isFileSystemMode && !imageUrl.startsWith('blob:')) {
        try {
          console.log('⏳ Cargando imagen desde FileSystem:', media.url);
          // Cargar el archivo desde la carpeta
          const filename = media.url.replace('./imagenes/', '');
          const fileHandle = await fsManager.imagesFolder.getFileHandle(filename);
          const file = await fileHandle.getFile();
          imageUrl = URL.createObjectURL(file);
          console.log('✅ Blob URL creado:', imageUrl);
        } catch (error) {
          console.error('❌ Error cargando imagen para lightbox:', error);
          content.innerHTML = '<div style="color: white; text-align: center; padding: 40px;">Error al cargar la imagen</div>';
          return;
        }
      }
      
      content.innerHTML = `<img id="lightboxImage" src="${imageUrl}" style="max-width: 100%; max-height: 90vh; transition: transform 0.2s ease; cursor: grab;" alt="Imagen ampliada">`;
      
      // 🔍 AGREGAR ZOOM CON SCROLL
      setTimeout(() => {
        const img = document.getElementById('lightboxImage');
        if (img) {
          let scale = 1;
          let isDragging = false;
          let startX = 0, startY = 0;
          let translateX = 0, translateY = 0;
          
          // Zoom con scroll
          content.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            scale = Math.max(1, Math.min(5, scale + delta));
            
            if (scale === 1) {
              translateX = 0;
              translateY = 0;
              img.style.cursor = 'grab';
            } else {
              img.style.cursor = scale > 1 ? 'grab' : 'default';
            }
            
            img.style.transform = `translate(${translateX / scale}px, ${translateY / scale}px) scale(${scale})`;
          }, { passive: false });
          
          // Arrastre
          img.addEventListener('mousedown', (e) => {
            if (scale > 1) {
              e.preventDefault();
              isDragging = true;
              startX = e.clientX - translateX;
              startY = e.clientY - translateY;
              img.style.cursor = 'grabbing';
            }
          });
          
          document.addEventListener('mousemove', (e) => {
            if (isDragging) {
              translateX = e.clientX - startX;
              translateY = e.clientY - startY;
              img.style.transform = `translate(${translateX / scale}px, ${translateY / scale}px) scale(${scale})`;
            }
          });
          
          document.addEventListener('mouseup', () => {
            if (isDragging) {
              isDragging = false;
              img.style.cursor = scale > 1 ? 'grab' : 'default';
            }
          });
          
          // Resetear con doble click
          img.addEventListener('dblclick', (e) => {
            e.preventDefault();
            scale = 1;
            translateX = 0;
            translateY = 0;
            img.style.cursor = 'grab';
            img.style.transform = 'translate(0px, 0px) scale(1)';
          });
        }
      }, 100);
    }
    
    document.getElementById('lightboxCounter').textContent = `${this.lightboxIndex + 1} / ${this.lightboxMedias.length}`;
  }

  closeLightbox() {
    document.getElementById('lightbox').classList.remove('active');
  }

  async lightboxPrev() {
    this.lightboxIndex = (this.lightboxIndex - 1 + this.lightboxMedias.length) % this.lightboxMedias.length;
    await this.showLightbox();
  }

  async lightboxNext() {
    this.lightboxIndex = (this.lightboxIndex + 1) % this.lightboxMedias.length;
    await this.showLightbox();
  }

  // RENDERIZAR PESTAÑA DE VALORES
  renderValores() {
    const resumen = document.getElementById('valoresResumen');
    const content = document.getElementById('valoresTabContent');
    
    // Calcular estadísticas generales
    const valorTotal = this.repuestos.reduce((sum, r) => sum + ((r.precio || 0) * (r.cantidad || 0)), 0);
    const valorPromedio = this.repuestos.length > 0 ? valorTotal / this.repuestos.length : 0;
    
    // Calcular valores por área
    const areaStats = {};
    this.repuestos.forEach(r => {
      const area = r.area || 'Sin Área';
      if (!areaStats[area]) {
        areaStats[area] = { cantidad: 0, valor: 0, repuestos: [] };
      }
      const valorItem = (r.precio || 0) * (r.cantidad || 0);
      areaStats[area].cantidad++;
      areaStats[area].valor += valorItem;
      areaStats[area].repuestos.push({
        nombre: r.nombre,
        codSAP: r.codSAP,
        cantidad: r.cantidad,
        precio: r.precio || 0,
        valor: valorItem
      });
    });
    
    // Calcular valores por equipo
    const equipoStats = {};
    this.repuestos.forEach(r => {
      const equipo = r.equipo || 'Sin Equipo';
      if (!equipoStats[equipo]) {
        equipoStats[equipo] = { cantidad: 0, valor: 0 };
      }
      equipoStats[equipo].cantidad++;
      equipoStats[equipo].valor += (r.precio || 0) * (r.cantidad || 0);
    });
    
    // Calcular valores por tipo
    const tipoStats = {};
    this.repuestos.forEach(r => {
      const tipo = r.tipo || 'Sin Tipo';
      if (!tipoStats[tipo]) {
        tipoStats[tipo] = { cantidad: 0, valor: 0 };
      }
      tipoStats[tipo].cantidad++;
      tipoStats[tipo].valor += (r.precio || 0) * (r.cantidad || 0);
    });
    
    // Top 10 repuestos más valiosos
    const topValiosos = this.repuestos
      .map(r => ({
        nombre: r.nombre,
        codSAP: r.codSAP || '',
        area: r.area,
        cantidad: r.cantidad,
        precio: r.precio || 0,
        valor: (r.precio || 0) * (r.cantidad || 0)
      }))
      .filter(r => r.valor > 0)
      .sort((a, b) => b.valor - a.valor)
      .slice(0, 10);
    
    // Construir HTML del resumen
    resumen.innerHTML = `
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px;">
        <div>
          <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 4px; color: #94a3b8;">$${valorTotal.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
          <div style="opacity: 0.85; font-size: 1.1rem; color: var(--text-secondary);">Valor Total del Inventario</div>
        </div>
        <div>
          <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 4px; color: #94a3b8;">$${valorPromedio.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
          <div style="opacity: 0.85; font-size: 1.1rem; color: var(--text-secondary);">Valor Promedio por Repuesto</div>
        </div>
        <div>
          <div style="font-size: 2.5rem; font-weight: bold; margin-bottom: 4px; color: #94a3b8;">${this.repuestos.length}</div>
          <div style="opacity: 0.85; font-size: 1.1rem; color: var(--text-secondary);">Total de Repuestos</div>
        </div>
      </div>
    `;
    
    // Guardar datos para tabs
    this.valoresData = { areaStats, equipoStats, tipoStats, topValiosos, valorTotal };
    
    // Mostrar tab inicial
    this.switchValoresTab('area');
  }
  
  switchValoresTab(tab) {
    // Actualizar botones
    document.querySelectorAll('.tab-valores').forEach(btn => {
      btn.style.background = 'var(--bg-primary)';
      btn.style.color = 'var(--text-secondary)';
      btn.style.border = '1px solid var(--border-color)';
      btn.style.boxShadow = 'none';
    });
    const activeBtn = document.getElementById(`tab${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
    activeBtn.style.background = 'var(--primary)';
    activeBtn.style.color = 'white';
    activeBtn.style.border = 'none';
    activeBtn.style.boxShadow = '0 0 15px rgba(59, 130, 246, 0.5)';
    
    const content = document.getElementById('valoresTabContent');
    const data = this.valoresData;
    let html = '';
    
    if (tab === 'area') {
      // Desglose por Área
      const sortedAreas = Object.entries(data.areaStats).sort((a, b) => b[1].valor - a[1].valor);
      sortedAreas.forEach(([area, stats]) => {
        const porcentaje = ((stats.valor / data.valorTotal) * 100).toFixed(1);
        const top5 = stats.repuestos.sort((a, b) => b.valor - a.valor).slice(0, 5);
        
        html += `
          <div style="background: var(--bg-secondary); padding: 20px; border-radius: 12px; margin-bottom: 16px; border-left: 4px solid var(--primary); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <h3 style="margin: 0; color: var(--primary); font-size: 1.2rem;">${area}</h3>
              <div style="text-align: right;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #7A9AB8;">$${stats.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
                <div style="font-size: 0.85rem; color: var(--gray-500);">${porcentaje}% del total</div>
              </div>
            </div>
            <div style="display: flex; gap: 20px; margin-bottom: 12px; padding: 12px; background: var(--bg-primary); border-radius: 8px;">
              <div><strong>${stats.cantidad}</strong> repuestos</div>
              <div><strong>$${(stats.valor / stats.cantidad).toLocaleString('es-ES', {minimumFractionDigits: 2})}</strong> promedio</div>
            </div>
            <div style="font-weight: 600; margin-bottom: 8px; color: var(--text-primary);">Top 5 más valiosos:</div>
            <div style="display: grid; gap: 6px;">
              ${top5.map((r, i) => `
                <div style="display: flex; justify-content: space-between; padding: 8px 12px; background: var(--bg-primary); border-radius: 6px; font-size: 0.9rem;">
                  <span><strong>${i + 1}.</strong> ${r.nombre} ${r.codSAP ? `(${r.codSAP})` : ''}</span>
                  <span style="font-weight: 600; color: #7A9AB8;">$${r.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      });
    } else if (tab === 'equipo') {
      // Desglose por Equipo
      const sortedEquipos = Object.entries(data.equipoStats).sort((a, b) => b[1].valor - a[1].valor);
      html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">';
      sortedEquipos.forEach(([equipo, stats]) => {
        const porcentaje = ((stats.valor / data.valorTotal) * 100).toFixed(1);
        html += `
          <div style="background: var(--bg-secondary); padding: 16px; border-radius: 12px; border-left: 4px solid var(--info); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h4 style="margin: 0 0 12px 0; color: var(--info);">${equipo}</h4>
            <div style="font-size: 1.3rem; font-weight: bold; color: #7A9AB8; margin-bottom: 4px;">$${stats.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
            <div style="font-size: 0.85rem; color: var(--gray-500); margin-bottom: 8px;">${porcentaje}% del total</div>
            <div style="display: flex; justify-content: space-between; padding-top: 8px; border-top: 1px solid var(--gray-200); font-size: 0.9rem;">
              <span>${stats.cantidad} repuestos</span>
              <span>$${(stats.valor / stats.cantidad).toFixed(2)} prom.</span>
            </div>
          </div>
        `;
      });
      html += '</div>';
    } else if (tab === 'tipo') {
      // Desglose por Tipo
      const sortedTipos = Object.entries(data.tipoStats).sort((a, b) => b[1].valor - a[1].valor);
      html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">';
      sortedTipos.forEach(([tipo, stats]) => {
        const porcentaje = ((stats.valor / data.valorTotal) * 100).toFixed(1);
        html += `
          <div style="background: var(--bg-secondary); padding: 16px; border-radius: 12px; border-left: 4px solid var(--secondary); box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h4 style="margin: 0 0 12px 0; color: var(--secondary);">${tipo}</h4>
            <div style="font-size: 1.3rem; font-weight: bold; color: #7A9AB8; margin-bottom: 4px;">$${stats.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
            <div style="font-size: 0.85rem; color: var(--gray-500); margin-bottom: 8px;">${porcentaje}% del total</div>
            <div style="display: flex; justify-content: space-between; padding-top: 8px; border-top: 1px solid var(--gray-200); font-size: 0.9rem;">
              <span>${stats.cantidad} repuestos</span>
              <span>$${(stats.valor / stats.cantidad).toFixed(2)} prom.</span>
            </div>
          </div>
        `;
      });
      html += '</div>';
    } else if (tab === 'top') {
      // Top 10 Más Valiosos
      html += `
        <div style="background: var(--bg-secondary); padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
          <h3 style="margin: 0 0 16px 0; color: var(--primary);">Top 10 Repuestos Más Valiosos</h3>
          <div style="display: grid; gap: 12px;">
            ${data.topValiosos.map((r, i) => {
              const posicion = i + 1;
              const bgPodium = i < 3 ? 'linear-gradient(135deg, rgba(91, 124, 153, 0.15) 0%, rgba(122, 154, 184, 0.15) 100%)' : 'var(--bg-primary)';
              const borderPodium = i < 3 ? 'var(--primary)' : 'var(--border-color)';
              return `
                <div style="display: grid; grid-template-columns: 40px 1fr auto; gap: 12px; align-items: center; padding: 12px; background: ${bgPodium}; border-radius: 8px; border-left: 4px solid ${borderPodium}; border: 1px solid var(--border-color);">
                  <div style="font-size: 1.5rem; text-align: center; font-weight: 700; color: var(--primary);">${posicion}</div>
                  <div>
                    <div style="font-weight: 600; color: var(--text-primary);">${r.nombre}</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">
                      ${r.codSAP} • ${r.area} • ${r.cantidad} unidades
                    </div>
                  </div>
                  <div style="text-align: right;">
                    <div style="font-size: 1.3rem; font-weight: bold; color: #7A9AB8;">$${r.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
                    <div style="font-size: 0.8rem; color: var(--text-muted);">$${r.precio.toFixed(2)} c/u</div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }
    
    content.innerHTML = html;
  }

  iniciarConteo() {
    this.conteoActivo = true;
    this.conteoData = {};
    this.conteoFiltros = { search: '', estado: 'todos', area: 'todas', orden: 'codigo' };
    this.conteoAgrupadoPorArea = false;
    
    this.repuestos.forEach(r => {
      this.conteoData[r.id] = { original: r.cantidad, nuevo: r.cantidad, contado: false };
    });
    
    // Llenar select de áreas
    const areas = [...new Set(this.repuestos.map(r => r.area || 'Sin área'))].sort();
    const areaSelect = document.getElementById('conteoFilterArea');
    areaSelect.innerHTML = '<option value="todas">Todas las áreas</option>' + 
      areas.map(a => `<option value="${a}">${a}</option>`).join('');
    
    // Eventos de filtros
    document.getElementById('conteoSearch').addEventListener('input', (e) => {
      this.conteoFiltros.search = e.target.value.toLowerCase();
      this.renderConteo();
    });
    document.getElementById('conteoFilterEstado').addEventListener('change', (e) => {
      this.conteoFiltros.estado = e.target.value;
      this.renderConteo();
    });
    document.getElementById('conteoFilterArea').addEventListener('change', (e) => {
      this.conteoFiltros.area = e.target.value;
      this.renderConteo();
    });
    document.getElementById('conteoOrden').addEventListener('change', (e) => {
      this.conteoFiltros.orden = e.target.value;
      this.renderConteo();
    });
    
    document.getElementById('btnIniciarConteo').style.display = 'none';
    document.getElementById('btnFinalizarConteo').style.display = 'block';
    document.getElementById('conteoFilters').style.display = 'block';
    document.getElementById('conteoProgress').style.display = 'block';
    
    this.renderConteo();
  }

  finalizarConteo() {
    // Calcular resumen de cambios
    const cambios = [];
    const grandesDiferencias = [];
    let totalContados = 0;
    let sinContar = 0;
    
    Object.keys(this.conteoData).forEach(id => {
      const conteo = this.conteoData[id];
      if (conteo.contado) {
        totalContados++;
        const diferencia = conteo.nuevo - conteo.original;
        if (diferencia !== 0) {
          const repuesto = this.repuestos.find(r => r.id === id);
          cambios.push({ repuesto, diferencia });
          
          // Diferencias mayores al 20%
          if (Math.abs(diferencia / (conteo.original || 1)) > 0.2) {
            grandesDiferencias.push({ repuesto, diferencia, porcentaje: (diferencia / (conteo.original || 1) * 100).toFixed(1) });
          }
        }
      } else {
        sinContar++;
      }
    });
    
    // Modal de confirmación
    let mensaje = `<div style="text-align: left; max-height: 400px; overflow-y: auto;">
      <h3 style="color: var(--primary); margin-bottom: 16px;">Resumen del Conteo</h3>
      <div style="display: grid; gap: 12px; margin-bottom: 20px;">
        <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
          <strong>Total contados:</strong> ${totalContados} de ${this.repuestos.length}
        </div>
        <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
          <strong>Sin contar:</strong> ${sinContar} productos (mantendrán cantidad actual)
        </div>
        <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
          <strong>Con diferencias:</strong> ${cambios.length} productos
        </div>
      </div>`;
    
    if (grandesDiferencias.length > 0) {
      mensaje += `<div style="padding: 12px; background: rgba(239, 68, 68, 0.1); border: 2px solid #ef4444; border-radius: 8px; margin-bottom: 16px;">
        <strong style="color: #ef4444;">⚠️ Diferencias Grandes (>20%):</strong>
        <ul style="margin-top: 8px;">
          ${grandesDiferencias.slice(0, 5).map(gd => 
            `<li>${gd.repuesto.codSAP}: ${gd.diferencia > 0 ? '+' : ''}${gd.diferencia} (${gd.porcentaje}%)</li>`
          ).join('')}
          ${grandesDiferencias.length > 5 ? `<li>...y ${grandesDiferencias.length - 5} más</li>` : ''}
        </ul>
      </div>`;
    }
    
    mensaje += `<p style="margin-top: 16px;"><strong>¿Deseas aplicar estos cambios?</strong></p></div>`;
    
    if (!confirm(mensaje)) return;
    
    // Aplicar cambios solo a productos contados
    Object.keys(this.conteoData).forEach(id => {
      const conteo = this.conteoData[id];
      if (conteo.contado) {
        const repuesto = this.repuestos.find(r => r.id === id);
        if (repuesto) {
          repuesto.cantidad = conteo.nuevo;
        }
      }
    });
    
    // Guardar en historial
    this.guardarHistorialConteo({
      fecha: new Date().toISOString(),
      totalContados,
      sinContar,
      cambios: cambios.length,
      grandesDiferencias: grandesDiferencias.length
    });
    
    this.conteoActivo = false;
    this.saveData();
    this.render();
    
    document.getElementById('btnIniciarConteo').style.display = 'block';
    document.getElementById('btnFinalizarConteo').style.display = 'none';
    document.getElementById('conteoFilters').style.display = 'none';
    document.getElementById('conteoProgress').style.display = 'none';
    
    this.showToast(`✅ Conteo aplicado: ${cambios.length} cambios, ${sinContar} sin modificar`, 'success');
  }

  renderConteo() {
    const grid = document.getElementById('conteoGrid');
    
    if (!this.conteoActivo) {
      const totalRepuestos = this.repuestos.length;
      const sinStock = this.repuestos.filter(r => r.cantidad === 0).length;
      const bajoStock = this.repuestos.filter(r => r.cantidad > 0 && r.cantidad <= (r.minimo || 5)).length;
      
      const bgCard = '#0f172a';
      const textPrimary = '#f8fafc';
      const textSecondary = '#cbd5e1';
      const borderColor = '#334155';
      
      grid.innerHTML = `
        <div style="max-width: 600px; margin: 0 auto; padding: 40px 20px; text-align: center;">
          <div style="font-size: 4rem; margin-bottom: 20px;">📋</div>
          <h2 style="color: #60a5fa; margin-bottom: 16px;">Conteo de Inventario</h2>
          <p style="color: ${textSecondary}; margin-bottom: 32px; line-height: 1.8;">
            Inicia un conteo físico para actualizar las cantidades reales de los repuestos
          </p>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 32px;">
            <div style="background: ${bgCard}; padding: 20px; border-radius: 12px; border: 1px solid ${borderColor};">
              <div style="font-size: 2rem; font-weight: 700; color: #60a5fa;">${totalRepuestos}</div>
              <div style="font-size: 0.9rem; color: ${textSecondary}; margin-top: 4px;">Total Repuestos</div>
            </div>
            <div style="background: ${bgCard}; padding: 20px; border-radius: 12px; border: 1px solid ${borderColor};">
              <div style="font-size: 2rem; font-weight: 700; color: #fbbf24;">${bajoStock}</div>
              <div style="font-size: 0.9rem; color: ${textSecondary}; margin-top: 4px;">Stock Bajo</div>
            </div>
            <div style="background: ${bgCard}; padding: 20px; border-radius: 12px; border: 1px solid ${borderColor};">
              <div style="font-size: 2rem; font-weight: 700; color: #f87171;">${sinStock}</div>
              <div style="font-size: 0.9rem; color: ${textSecondary}; margin-top: 4px;">Sin Stock</div>
            </div>
          </div>
          
          <div style="background: #0f172a; color: #22d3ee; padding: 16px; border-radius: 12px; margin-bottom: 24px; border: 1px solid #334155;">
            <strong>💡 Consejo:</strong> Usa la cámara de tu móvil para escanear códigos mientras cuentas
          </div>
          
          <button class="btn btn-success" style="font-size: 1.1rem; padding: 16px 32px;" onclick="app.iniciarConteo()">
            Iniciar Conteo
          </button>
        </div>
      `;
      return;
    }

    // Filtrar repuestos
    let repuestosFiltrados = this.repuestos.filter(r => {
      const conteo = this.conteoData[r.id];
      const search = this.conteoFiltros.search;
      const estado = this.conteoFiltros.estado;
      const area = this.conteoFiltros.area;
      
      // Filtro de búsqueda
      if (search) {
        const matchSearch = r.codSAP.toLowerCase().includes(search) || 
                           r.nombre.toLowerCase().includes(search) ||
                           (r.area || '').toLowerCase().includes(search);
        if (!matchSearch) return false;
      }
      
      // Filtro de estado
      if (estado === 'contados' && !conteo.contado) return false;
      if (estado === 'no-contados' && conteo.contado) return false;
      if (estado === 'diferencias' && conteo.nuevo === conteo.original) return false;
      
      // Filtro de área
      if (area !== 'todas' && (r.area || 'Sin área') !== area) return false;
      
      return true;
    });

    // Ordenar
    const orden = this.conteoFiltros.orden;
    repuestosFiltrados.sort((a, b) => {
      if (orden === 'codigo') return a.codSAP.localeCompare(b.codSAP);
      if (orden === 'nombre') return a.nombre.localeCompare(b.nombre);
      if (orden === 'area') return (a.area || '').localeCompare(b.area || '');
      if (orden === 'diferencia') {
        const difA = Math.abs(this.conteoData[a.id].nuevo - this.conteoData[a.id].original);
        const difB = Math.abs(this.conteoData[b.id].nuevo - this.conteoData[b.id].original);
        return difB - difA;
      }
      if (orden === 'no-contados') {
        const aContado = this.conteoData[a.id].contado ? 1 : 0;
        const bContado = this.conteoData[b.id].contado ? 1 : 0;
        return aContado - bContado;
      }
      return 0;
    });

    // Actualizar progreso
    const totalContados = Object.values(this.conteoData).filter(c => c.contado).length;
    const total = this.repuestos.length;
    const progress = (totalContados / total * 100).toFixed(0);
    
    document.getElementById('conteoProgressBar').style.width = `${progress}%`;
    document.getElementById('conteoProgressText').textContent = `${totalContados} de ${total} repuestos contados (${progress}%) • Mostrando ${repuestosFiltrados.length}`;

    // Renderizar
    if (this.conteoAgrupadoPorArea) {
      grid.innerHTML = this.renderConteoAgrupado(repuestosFiltrados);
    } else {
      grid.innerHTML = repuestosFiltrados.map(r => {
        const conteo = this.conteoData[r.id];
        const diferencia = conteo.nuevo - conteo.original;
        const multimedia = r.multimedia || [];
        const primeraImagen = multimedia.find(m => m.type === 'image');
        const porcentajeDif = conteo.original > 0 ? ((diferencia / conteo.original) * 100).toFixed(1) : 0;
        const granDiferencia = Math.abs(porcentajeDif) > 20;
        
        return `
        <div class="conteo-card-responsive ${granDiferencia ? 'conteo-alerta' : ''}">
          ${primeraImagen ? `
            <div class="conteo-img-wrapper">
              <img src="${primeraImagen.url}" class="conteo-img" alt="${r.nombre}">
            </div>
          ` : ''}
          
          <div class="conteo-info">
            <div class="conteo-header">
              <div>
                <strong class="conteo-codigo">${r.codSAP}</strong>
                <span class="conteo-nombre">${r.nombre}</span>
                ${r.area ? `<span class="conteo-area">${r.area}</span>` : ''}
              </div>
            </div>
            
            <div class="conteo-stats">
              <div class="conteo-stat-item">
                <span class="conteo-stat-label">En Sistema:</span>
                <span class="conteo-stat-value">${conteo.original}</span>
              </div>
              ${diferencia !== 0 ? `
                <div class="conteo-stat-item">
                  <span class="conteo-stat-label">Diferencia:</span>
                  <span class="conteo-diferencia ${diferencia > 0 ? 'positiva' : 'negativa'}">
                    ${diferencia > 0 ? '+' : ''}${diferencia} (${porcentajeDif}%)
                  </span>
                </div>
              ` : '<div class="conteo-stat-item"><span class="conteo-igual">✓ Igual</span></div>'}
              ${granDiferencia ? '<div class="conteo-revisar">⚠️ REVISAR</div>' : ''}
            </div>
          </div>
          
          <div class="conteo-control">
            <label class="conteo-label">Cantidad Física:</label>
            <div class="conteo-input-group">
              <button class="conteo-btn-minus" onclick="app.ajustarConteo('${r.id}', -1)" type="button">
                <span class="btn-symbol">−</span>
              </button>
              <input 
                type="number" 
                class="conteo-input-number" 
                value="${conteo.nuevo}" 
                min="0"
                id="conteo-${r.id}"
                data-action="update-conteo" 
                data-id="${r.id}"
                placeholder="0"
              >
              <button class="conteo-btn-plus" onclick="app.ajustarConteo('${r.id}', 1)" type="button">
                <span class="btn-symbol">+</span>
              </button>
            </div>
          </div>
        </div>
        `;
      }).join('');
    }
  }

  renderConteoAgrupado(repuestos) {
    const porArea = {};
    repuestos.forEach(r => {
      const area = r.area || 'Sin área';
      if (!porArea[area]) porArea[area] = [];
      porArea[area].push(r);
    });

    return Object.keys(porArea).sort().map(area => {
      const items = porArea[area];
      const contados = items.filter(r => this.conteoData[r.id].contado).length;
      const areaId = 'conteo-area-' + area.replace(/\s/g, '-');
      
      return `
        <div style="margin-bottom: 24px; border: 2px solid var(--border-color); border-radius: 12px; overflow: hidden;">
          <div onclick="app.toggleConteoArea('${areaId}')" 
            style="background: var(--bg-secondary); padding: 16px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; user-select: none;">
            <div>
              <h3 style="margin: 0; color: var(--primary); font-size: 1.1rem;">
                <span id="${areaId}-icon" style="display: inline-block; transition: transform 0.3s;">▼</span>
                ${area}
              </h3>
            </div>
            <div style="text-align: right; font-size: 0.9rem; color: var(--text-secondary);">
              <strong style="color: var(--success);">${contados}/${items.length}</strong> contados
            </div>
          </div>
          <div id="${areaId}" style="padding: 12px;">
            ${items.map(r => {
              const conteo = this.conteoData[r.id];
              const diferencia = conteo.nuevo - conteo.original;
              const multimedia = r.multimedia || [];
              const primeraImagen = multimedia.find(m => m.type === 'image');
              
              return `
                <div class="conteo-item" style="display: grid; grid-template-columns: ${primeraImagen ? 'auto 1fr' : '1fr'}; gap: 12px; margin-bottom: 12px;">
                  ${primeraImagen ? `<img src="${primeraImagen.url}" style="width: 70px; height: 70px; object-fit: cover; border-radius: 8px;">` : ''}
                  <div style="flex: 1;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                      <div>
                        <strong style="color: var(--primary);">${r.codSAP}</strong><br>
                        <span style="font-size: 0.9rem; color: var(--text-secondary);">${r.nombre}</span>
                      </div>
                      <div style="text-align: right; font-size: 0.85rem;">
                        <div>Sistema: ${conteo.original}</div>
                        ${diferencia !== 0 ? `<div style="font-weight: 700; color: ${diferencia > 0 ? 'var(--success)' : 'var(--danger)'};">${diferencia > 0 ? '+' : ''}${diferencia}</div>` : ''}
                      </div>
                    </div>
                    <input type="number" class="conteo-input" value="${conteo.nuevo}" min="0" 
                      data-action="update-conteo" data-id="${r.id}" placeholder="Cantidad física"
                      style="width: 100%; padding: 10px; font-size: 1.1rem; text-align: center; font-weight: 700;">
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }).join('');
  }

  toggleConteoArea(areaId) {
    const content = document.getElementById(areaId);
    const icon = document.getElementById(areaId + '-icon');
    if (content.style.display === 'none') {
      content.style.display = 'block';
      icon.style.transform = 'rotate(0deg)';
      icon.textContent = '▼';
    } else {
      content.style.display = 'none';
      icon.style.transform = 'rotate(-90deg)';
      icon.textContent = '▶';
    }
  }

  updateConteo(id, valor) {
    if (this.conteoData[id]) {
      const nuevoValor = parseInt(valor) || 0;
      this.conteoData[id].nuevo = nuevoValor;
      this.conteoData[id].contado = true; // Marcar como contado cuando se edita
      this.renderConteo();
    }
  }

  // Ajustar conteo con botones +/-
  ajustarConteo(id, delta) {
    const input = document.getElementById(`conteo-${id}`);
    if (!input) return;
    
    const valorActual = parseInt(input.value) || 0;
    const nuevoValor = Math.max(0, valorActual + delta);
    
    input.value = nuevoValor;
    this.updateConteo(id, nuevoValor);
  }

  // Modal de conteo individual desde las tarjetas
  abrirModalConteoIndividual(id) {
    const repuesto = this.repuestos.find(r => r.id === id);
    if (!repuesto) {
      this.showToast('⚠️ Repuesto no encontrado', 'error');
      return;
    }

    // 🎨 PALETA NIEBLA Y BOSQUE (Nueva paleta minimalista)
    const NIEBLA_CARBON = '#4A5568';              // Gris oscuro carbón
    const NIEBLA_MEDIO = '#5A6778';               // Gris medio
    const NIEBLA_AZUL = '#5B7C99';                // Azul-gris brumoso
    const BOSQUE_VERDE = '#6B8E7F';               // Verde bosque suave
    const TIERRA_NARANJA = '#D4976C';             // Naranja tierra cálido
    const ROJO_SUAVE = '#C76B6B';                 // Rojo suave
    
    // Calcular estadísticas y estado del stock
    const minimo = repuesto.minimo || repuesto.stockMinimo || 5;
    const cantidadActual = repuesto.cantidad || 0;
    const estadoStock = cantidadActual === 0 ? 'AGOTADO' : cantidadActual <= minimo ? 'BAJO' : 'OK';
    const colorEstado = cantidadActual === 0 ? ROJO_SUAVE : cantidadActual <= minimo ? TIERRA_NARANJA : BOSQUE_VERDE;
    const iconoEstado = cantidadActual === 0 ? '❌' : cantidadActual <= minimo ? '⚠️' : '✅';
    
    // Crear el contenido del modal con diseño minimalista y corporativo
    const modalHTML = `
      <div class="modal-backdrop-custom" id="modalConteoIndividual">
        <div class="modal-dialog-custom" style="max-width: 540px; animation: slideUp 0.3s ease-out;">
          <div class="modal-content-custom" style="border-radius: 12px; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.2); border: 1px solid ${NIEBLA_CARBON};">
            
            <!-- HEADER MINIMALISTA CON NUEVA PALETA -->
            <div class="modal-header-custom" style="background: ${NIEBLA_CARBON}; color: #F7FAFC; padding: 20px 24px; border-bottom: 3px solid ${NIEBLA_AZUL};">
              <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                <span style="font-size: 1.8rem; opacity: 0.9;">📊</span>
                <div>
                  <h3 style="margin: 0; font-size: 1.2rem; font-weight: 600; color: white;">Conteo Individual</h3>
                  <p style="margin: 4px 0 0 0; opacity: 0.7; font-size: 0.8rem;">Actualiza la cantidad física en inventario</p>
                </div>
              </div>
              <button class="close-btn" onclick="app.cerrarModalConteoIndividual()" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; width: 32px; height: 32px; border-radius: 6px; font-size: 1.3rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">×</button>
            </div>
            
            <div class="modal-body-custom" style="padding: 24px;">
              
              <!-- CARD DE INFORMACIÓN DEL PRODUCTO - MINIMALISTA -->
              <div style="background: #1e293b; border: 1px solid #334155; padding: 16px; border-radius: 8px; margin-bottom: 18px;">
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                  <h4 style="margin: 0; font-size: 1rem; color: #e2e8f0; font-weight: 600; max-width: 70%;">${repuesto.nombre}</h4>
                  <span style="background: ${colorEstado}; color: white; padding: 4px 10px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; white-space: nowrap; opacity: 0.95;">${iconoEstado} ${estadoStock}</span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 0.8rem; color: #A0AEC0;">
                  <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="color: ${NIEBLA_AZUL}; opacity: 0.8;">📍</span>
                    <span><strong style="color: #F7FAFC;">Área:</strong> ${repuesto.area || 'N/A'}</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="color: ${NIEBLA_AZUL}; opacity: 0.8;">⚙️</span>
                    <span><strong style="color: #F7FAFC;">Equipo:</strong> ${repuesto.equipo || 'N/A'}</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="color: ${NIEBLA_AZUL}; opacity: 0.8;">🔢</span>
                    <span><strong style="color: #F7FAFC;">SAP:</strong> ${repuesto.codSAP || 'N/A'}</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="color: ${NIEBLA_AZUL}; opacity: 0.8;">🏷️</span>
                    <span><strong style="color: #F7FAFC;">Tipo:</strong> ${repuesto.tipo || 'N/A'}</span>
                  </div>
                </div>
              </div>

              <!-- CANTIDAD ACTUAL EN SISTEMA - PALETA NIEBLA -->
              <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 14px; margin-bottom: 20px; align-items: center;">
                <div style="background: ${NIEBLA_CARBON}; padding: 14px; border-radius: 8px; text-align: center; border-left: 3px solid ${NIEBLA_AZUL};">
                  <div style="font-size: 0.75rem; color: #A0AEC0; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">📦 En Sistema</div>
                  <div style="font-size: 2.2rem; color: ${NIEBLA_AZUL}; font-weight: 700; line-height: 1;">${cantidadActual}</div>
                  <div style="font-size: 0.7rem; color: #718096; margin-top: 4px;">unidades</div>
                </div>
                
                <div style="font-size: 1.5rem; color: ${NIEBLA_MEDIO}; opacity: 0.6;">→</div>
                
                <div style="background: ${NIEBLA_CARBON}; padding: 14px; border-radius: 8px; text-align: center; border-left: 3px solid ${TIERRA_NARANJA};">
                  <div style="font-size: 0.75rem; color: #A0AEC0; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">📋 Mínimo</div>
                  <div style="font-size: 2.2rem; color: ${TIERRA_NARANJA}; font-weight: 700; line-height: 1;">${minimo}</div>
                  <div style="font-size: 0.7rem; color: #718096; margin-top: 4px;">requerido</div>
                </div>
              </div>

              <!-- INFORMACIÓN DE ÚLTIMO CONTEO - MINIMALISTA -->
              ${repuesto.ultimoConteo ? `
                <div style="background: #1e293b; padding: 10px 14px; border-radius: 6px; margin-bottom: 18px; border-left: 3px solid #527853; display: flex; align-items: center; gap: 10px;">
                  <span style="font-size: 1.2rem; opacity: 0.8;">✅</span>
                  <div>
                    <div style="font-size: 0.75rem; color: #94a3b8; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Último conteo</div>
                    <div style="font-size: 0.85rem; color: #cbd5e1; font-weight: 600; margin-top: 3px;">
                      ${new Date(repuesto.ultimoConteo).toLocaleDateString('es-ES', {
                        day: '2-digit',
                        month: 'short',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </div>
                  </div>
                </div>
              ` : `
                <div style="background: #1e293b; padding: 10px 14px; border-radius: 6px; margin-bottom: 18px; border-left: 3px solid #8B5A5A; display: flex; align-items: center; gap: 10px;">
                  <span style="font-size: 1.2rem; opacity: 0.8;">⚠️</span>
                  <div>
                    <div style="font-size: 0.75rem; color: #94a3b8; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Sin conteo previo</div>
                    <div style="font-size: 0.8rem; color: #cbd5e1; margin-top: 3px;">Este es el primer conteo que se registrará</div>
                  </div>
                </div>
              `}

              <!-- SECCIÓN DE CONTEO - MINIMALISTA -->
              <div style="margin-bottom: 18px;">
                <label style="display: flex; align-items: center; gap: 8px; font-weight: 600; margin-bottom: 12px; color: #cbd5e1; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.5px;">
                  <span style="font-size: 1.1rem; opacity: 0.8;">🔢</span>
                  Nueva Cantidad Física:
                </label>
                
                <!-- CONTADOR MINIMALISTA CON BOTONES +/- -->
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 14px;">
                  <button 
                    class="btn" 
                    onclick="const input = document.getElementById('inputConteoIndividual'); input.value = Math.max(0, parseInt(input.value || 0) - 1); input.focus();" 
                    style="background: ${ROJO_SUAVE}; color: #F7FAFC; font-size: 2rem; font-weight: 700; padding: 0; min-width: 65px; height: 65px; border-radius: 8px; border: 1px solid #A85555; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;"
                    onmouseover="this.style.background='#A85555'"
                    onmouseout="this.style.background='${ROJO_SUAVE}'"
                    title="Disminuir cantidad">
                    −
                  </button>
                  
                  <input 
                    type="number" 
                    id="inputConteoIndividual" 
                    class="form-control" 
                    value="${cantidadActual}" 
                    min="0" 
                    style="font-size: 2.2rem; text-align: center; font-weight: 700; flex: 1; height: 65px; border: 2px solid ${NIEBLA_AZUL}; border-radius: 8px; background: #3A4556; color: #F7FAFC; transition: all 0.2s;"
                    onfocus="this.style.borderColor='${NIEBLA_AZUL}'; this.style.background='${NIEBLA_CARBON}'"
                    onblur="this.style.borderColor='${NIEBLA_MEDIO}'; this.style.background='#3A4556'"
                    autofocus
                  />
                  
                  <button 
                    class="btn" 
                    onclick="const input = document.getElementById('inputConteoIndividual'); input.value = parseInt(input.value || 0) + 1; input.focus();" 
                    style="background: ${BOSQUE_VERDE}; color: #F7FAFC; font-size: 2rem; font-weight: 700; padding: 0; min-width: 65px; height: 65px; border-radius: 8px; border: 1px solid #557566; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center;"
                    onmouseover="this.style.background='#557566'"
                    onmouseout="this.style.background='${BOSQUE_VERDE}'"
                    title="Aumentar cantidad">
                    +
                  </button>
                </div>
                
                <!-- BOTONES RÁPIDOS MINIMALISTAS -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                  <button class="btn btn-sm" onclick="document.getElementById('inputConteoIndividual').value = 0; document.getElementById('inputConteoIndividual').focus();" 
                    style="background: ${NIEBLA_CARBON}; color: #F7FAFC; padding: 10px 8px; border-radius: 6px; border: 1px solid #5A6778; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;"
                    onmouseover="this.style.background='${ROJO_SUAVE}'; this.style.borderColor='#A85555'"
                    onmouseout="this.style.background='${NIEBLA_CARBON}'; this.style.borderColor='#5A6778'">
                    🚫 Vacío (0)
                  </button>
                  <button class="btn btn-sm" onclick="document.getElementById('inputConteoIndividual').value = ${cantidadActual}; document.getElementById('inputConteoIndividual').focus();" 
                    style="background: ${NIEBLA_CARBON}; color: #F7FAFC; padding: 10px 8px; border-radius: 6px; border: 1px solid #5A6778; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;"
                    onmouseover="this.style.background='${NIEBLA_AZUL}'; this.style.borderColor='#4A6278'"
                    onmouseout="this.style.background='${NIEBLA_CARBON}'; this.style.borderColor='#5A6778'">
                    📦 = Sistema
                  </button>
                  <button class="btn btn-sm" onclick="document.getElementById('inputConteoIndividual').value = ${minimo}; document.getElementById('inputConteoIndividual').focus();" 
                    style="background: ${NIEBLA_CARBON}; color: #F7FAFC; padding: 10px 8px; border-radius: 6px; border: 1px solid #5A6778; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.2s;"
                    onmouseover="this.style.background='${TIERRA_NARANJA}'; this.style.borderColor='#B8825A'"
                    onmouseout="this.style.background='${NIEBLA_CARBON}'; this.style.borderColor='#5A6778'">
                    ⚠️ = Mínimo
                  </button>
                </div>
              </div>

              <!-- NOTA INFORMATIVA CON NUEVA PALETA -->
              <div style="background: #3A4556; padding: 12px 14px; border-radius: 6px; border-left: 3px solid ${NIEBLA_MEDIO}; font-size: 0.8rem; color: #A0AEC0; display: flex; gap: 10px; align-items: start;">
                <span style="font-size: 1.1rem; line-height: 1; opacity: 0.7;">💡</span>
                <div>
                  <strong style="display: block; margin-bottom: 3px; color: #cbd5e1; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Nota:</strong>
                  Se actualizará la cantidad y se registrará la fecha/hora del conteo automáticamente.
                </div>
              </div>
            </div>

            <!-- FOOTER CON NUEVA PALETA -->
            <div class="modal-footer-custom" style="display: flex; gap: 10px; justify-content: flex-end; padding: 16px 24px; background: #2D3748; border-top: 1px solid ${NIEBLA_CARBON};">
              <button class="btn" onclick="app.cerrarModalConteoIndividual()" 
                style="background: ${NIEBLA_CARBON}; color: #F7FAFC; padding: 10px 24px; font-weight: 600; border-radius: 6px; border: 1px solid #5A6778; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;"
                onmouseover="this.style.background='#5A6778'"
                onmouseout="this.style.background='${NIEBLA_CARBON}'">
                ✕ Cancelar
              </button>
              <button class="btn" onclick="app.guardarConteoIndividual('${id}')" 
                style="background: ${BOSQUE_VERDE}; color: #F7FAFC; padding: 10px 28px; font-weight: 600; border-radius: 6px; border: 1px solid #557566; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;"
                onmouseover="this.style.background='#557566'"
                onmouseout="this.style.background='${BOSQUE_VERDE}'">
                ✓ Guardar Conteo
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <style>
        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(30px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      </style>
    `;

    // Inyectar el modal en el body
    const modalContainer = document.createElement('div');
    modalContainer.innerHTML = modalHTML;
    document.body.appendChild(modalContainer);

    // Focus en el input después de un pequeño delay
    setTimeout(() => {
      const input = document.getElementById('inputConteoIndividual');
      if (input) {
        input.focus();
        input.select();
      }
    }, 100);

    // Cerrar con ESC
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        this.cerrarModalConteoIndividual();
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);

    // Guardar con Enter
    const handleEnter = (e) => {
      if (e.key === 'Enter' && e.target.id === 'inputConteoIndividual') {
        this.guardarConteoIndividual(id);
        document.removeEventListener('keydown', handleEnter);
      }
    };
    document.addEventListener('keydown', handleEnter);
  }

  cerrarModalConteoIndividual() {
    const modal = document.getElementById('modalConteoIndividual');
    if (modal) {
      modal.parentElement.remove();
    }
  }

  async guardarConteoIndividual(id) {
    const input = document.getElementById('inputConteoIndividual');
    if (!input) return;

    const nuevaCantidad = parseInt(input.value) || 0;
    const repuesto = this.repuestos.find(r => r.id === id);
    
    if (!repuesto) {
      this.showToast('⚠️ Error: Repuesto no encontrado', 'error');
      return;
    }

    const cantidadAnterior = repuesto.cantidad;

    // ⚡ CERRAR MODAL INMEDIATAMENTE (antes de guardar)
    this.cerrarModalConteoIndividual();

    // Actualizar cantidad y fecha de conteo
    repuesto.cantidad = nuevaCantidad;
    repuesto.ultimoConteo = new Date().toISOString();
    repuesto.ultimaModificacion = new Date().toISOString();

    console.log('💾 Guardando conteo individual:', {
      id: repuesto.id,
      nombre: repuesto.nombre,
      cantidadAnterior,
      nuevaCantidad,
      ultimoConteo: repuesto.ultimoConteo
    });

    // 🔥 GUARDAR USANDO saveData() para actualizar EMBEDDED_DATA automáticamente
    const guardadoExitoso = await this.saveData();
    
    if (!guardadoExitoso) {
      this.showToast('⚠️ Error al guardar el conteo', 'error');
      // Revertir cambios si falló
      repuesto.cantidad = cantidadAnterior;
      return;
    }

    console.log('✅ Conteo guardado exitosamente (EMBEDDED_DATA actualizado)');

    // Mostrar notificación con diferencia y fecha/hora
    const diferencia = nuevaCantidad - cantidadAnterior;
    const textoDiferencia = diferencia !== 0 ? ` (${diferencia > 0 ? '+' : ''}${diferencia})` : '';
    const fechaHora = new Date().toLocaleString('es-ES', { 
      day: '2-digit', 
      month: '2-digit', 
      year: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    this.showToast(
      `Conteo guardado: <strong>${repuesto.nombre}</strong><br>${cantidadAnterior} → ${nuevaCantidad}${textoDiferencia}<br>${fechaHora}`,
      'success',
      4000
    );

    // Re-renderizar la vista completa para actualizar (móvil o PC)
    await this.renderInventario();
  }

  accionMasivaConteo(accion) {
    if (accion === 'copiar-sistema') {
      if (!confirm('¿Copiar las cantidades del sistema a todos los productos físicos?')) return;
      Object.keys(this.conteoData).forEach(id => {
        this.conteoData[id].nuevo = this.conteoData[id].original;
        this.conteoData[id].contado = true;
      });
      this.showToast('✅ Cantidades del sistema copiadas', 'success');
    } else if (accion === 'resetear') {
      if (!confirm('¿Resetear todo el conteo? Se perderán los cambios.')) return;
      Object.keys(this.conteoData).forEach(id => {
        this.conteoData[id].nuevo = this.conteoData[id].original;
        this.conteoData[id].contado = false;
      });
      this.showToast('🔄 Conteo reseteado', 'info');
    } else if (accion === 'aplicar-no-contados') {
      let noContados = 0;
      Object.keys(this.conteoData).forEach(id => {
        if (!this.conteoData[id].contado) {
          this.conteoData[id].nuevo = this.conteoData[id].original;
          noContados++;
        }
      });
      this.showToast(`✅ Cantidad del sistema aplicada a ${noContados} productos no contados`, 'success');
    }
    this.renderConteo();
  }

  toggleAgruparPorArea() {
    this.conteoAgrupadoPorArea = !this.conteoAgrupadoPorArea;
    document.getElementById('btnAgruparTexto').textContent = this.conteoAgrupadoPorArea ? 'Vista Normal' : 'Agrupar por Área';
    this.renderConteo();
  }

  guardarHistorialConteo(datos) {
    const historial = JSON.parse(localStorage.getItem('historialConteos') || '[]');
    historial.unshift(datos);
    if (historial.length > 20) historial.pop(); // Mantener solo 20
    localStorage.setItem('historialConteos', JSON.stringify(historial));
  }

  async exportarJSON() {
    if (!this.fsManager.directoryHandle) {
      this.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }

    try {
      // Preparar datos solo SIN multimedia (las imágenes quedan en FileSystem)
      const exportData = {
        version: '2.4',
        exportDate: new Date().toISOString(),
        repuestos: this.repuestos.map(r => ({
          id: r.id,
          codSAP: r.codSAP,
          codProv: r.codProv,
          tipo: r.tipo,
          nombre: r.nombre,
          area: r.area,
          equipo: r.equipo,
          cantidad: r.cantidad,
          minimo: r.minimo,
          precio: r.precio,
          // multimedia queda vacío - las imágenes están en FileSystem
          multimedia: []
        })),
        mapa: this.mapObjects || []
      };

      const jsonString = JSON.stringify(exportData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });

      // Guardar en INVENTARIO_STORAGE/repuestos.json
      const fileName = 'repuestos.json';
      const fileHandle = await this.fsManager.directoryHandle.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();

      // Registrar en historial
      this.registrarSincronizacion({
        tipo: 'exportacion',
        fecha: new Date().toISOString(),
        productos: this.repuestos.length,
        archivo: fileName,
        tamaño: (blob.size / 1024).toFixed(2) + ' KB'
      });

      this.showToast(`✅ JSON exportado: ${fileName} (${(blob.size / 1024).toFixed(2)} KB)`, 'success');
    } catch (error) {
      console.error('Error exportando JSON:', error);
      this.showToast('❌ Error al exportar: ' + error.message, 'error');
    }
  }

  async importarJSON() {
    if (!this.fsManager.directoryHandle) {
      this.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }

    try {
      // Leer repuestos.json de la carpeta
      const fileHandle = await this.fsManager.directoryHandle.getFileHandle('repuestos.json');
      const file = await fileHandle.getFile();
      const content = await file.text();
      const data = JSON.parse(content);

      const cantidadImportada = data.repuestos?.length || 0;
      
      const accion = confirm(
        `📥 Archivo encontrado: repuestos.json\n\n` +
        `Productos en archivo: ${cantidadImportada}\n` +
        `Productos actuales: ${this.repuestos.length}\n\n` +
        `¿Cómo deseas importar?\n\n` +
        `✅ ACEPTAR = FUSIONAR (actualizar datos, mantener imágenes locales)\n` +
        `❌ CANCELAR = Cancelar operación`
      );

      if (!accion) {
        this.showToast('Importación cancelada', 'info');
        return;
      }

      // FUSIÓN INTELIGENTE
      const nuevosRepuestos = data.repuestos.map(importado => {
        // Buscar si ya existe por ID o código SAP
        const existente = this.repuestos.find(r => 
          r.id === importado.id || r.codSAP === importado.codSAP
        );

        if (existente) {
          // ACTUALIZAR: Mantener multimedia local, actualizar resto de datos
          return {
            ...importado,
            multimedia: existente.multimedia || [] // Preservar imágenes locales
          };
        } else {
          // NUEVO: Agregar sin multimedia
          return {
            ...importado,
            multimedia: []
          };
        }
      });

      const productosNuevos = nuevosRepuestos.length - this.repuestos.length;
      const productosActualizados = Math.min(nuevosRepuestos.length, this.repuestos.length);

      this.repuestos = nuevosRepuestos;

      // Importar mapa si existe
      if (data.mapa) {
        this.mapObjects = data.mapa;
        localStorage.setItem('mapData', JSON.stringify(this.mapObjects));
      }

      this.saveData();
      this.updateAutocompleteData();
      this.render();
      this.renderFilters();

      // Registrar en historial
      this.registrarSincronizacion({
        tipo: 'importacion',
        fecha: new Date().toISOString(),
        productos: nuevosRepuestos.length,
        nuevos: productosNuevos > 0 ? productosNuevos : 0,
        actualizados: productosActualizados,
        archivo: 'repuestos.json',
        tamaño: (file.size / 1024).toFixed(2) + ' KB'
      });

      this.showToast(
        `✅ Importación completa: ${productosActualizados} actualizados, ${productosNuevos > 0 ? productosNuevos : 0} nuevos`,
        'success'
      );
    } catch (error) {
      if (error.name === 'NotFoundError') {
        this.showToast('⚠️ No se encontró repuestos.json en la carpeta', 'warning');
      } else {
        console.error('Error importando JSON:', error);
        this.showToast('❌ Error al importar: ' + error.message, 'error');
      }
    }
  }

  registrarSincronizacion(datos) {
    const historial = JSON.parse(localStorage.getItem('historialSincronizaciones') || '[]');
    historial.unshift(datos);
    if (historial.length > 50) historial.pop(); // Mantener 50 registros
    localStorage.setItem('historialSincronizaciones', JSON.stringify(historial));
  }

  verHistorialSincronizaciones() {
    const historial = JSON.parse(localStorage.getItem('historialSincronizaciones') || '[]');
    
    if (historial.length === 0) {
      this.showToast('📋 No hay sincronizaciones registradas', 'info');
      return;
    }

    const html = `
      <div style="max-height: 500px; overflow-y: auto;">
        <h3 style="color: var(--primary); margin-bottom: 16px;">📊 Historial de Sincronizaciones</h3>
        <div style="display: grid; gap: 12px;">
          ${historial.slice(0, 20).map((sync, i) => {
            const fecha = new Date(sync.fecha);
            const icono = sync.tipo === 'exportacion' ? '📤' : '📥';
            const color = sync.tipo === 'exportacion' ? 'var(--success)' : 'var(--info)';
            
            return `
              <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${color};">
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                  <strong style="color: ${color};">${icono} ${sync.tipo.toUpperCase()}</strong>
                  <span style="font-size: 0.85rem; color: var(--text-secondary);">
                    ${fecha.toLocaleDateString()} ${fecha.toLocaleTimeString()}
                  </span>
                </div>
                <div style="font-size: 0.9rem; color: var(--text-secondary);">
                  📦 Productos: ${sync.productos} | 📄 ${sync.archivo} (${sync.tamaño})
                  ${sync.nuevos ? `<br>🆕 Nuevos: ${sync.nuevos} | 🔄 Actualizados: ${sync.actualizados}` : ''}
                </div>
              </div>
            `;
          }).join('')}
        </div>
        ${historial.length > 20 ? `<div style="text-align: center; padding: 12px; color: var(--text-secondary);">... y ${historial.length - 20} más</div>` : ''}
      </div>
    `;

    // Mostrar en modal (reutilizar el modal existente)
    const modal = document.getElementById('modal');
    const modalContent = modal.querySelector('.modal-content');
    const oldContent = modalContent.innerHTML;
    modalContent.innerHTML = html + `<div style="text-align: center; margin-top: 20px;"><button class="btn btn-secondary" onclick="document.getElementById('modal').style.display='none'">Cerrar</button></div>`;
    modal.style.display = 'flex';
  }

  renderJerarquia() {
    const tree = {};
    
    // Construir árbol jerárquico - SOLO con niveles que tienen datos
    this.repuestos.forEach(r => {
      // Nivel 1: Planta (obligatorio)
      const planta = r.planta || 'Sin Clasificar';
      if (!tree[planta]) tree[planta] = {};
      
      // Nivel 2: Área General
      const areaGeneral = r.areaGeneral || '🔧 Inventario General';
      if (!tree[planta][areaGeneral]) tree[planta][areaGeneral] = {};
      
      // Nivel 3: Sub-Área
      const subArea = r.subArea || 'Sin Sub-Área';
      if (!tree[planta][areaGeneral][subArea]) tree[planta][areaGeneral][subArea] = {};
      
      // Determinar en qué nivel va el repuesto basándose en los datos que tiene
      let currentLevel = tree[planta][areaGeneral][subArea];
      
      // Si tiene Sistema/Equipo, agregar nivel 4
      if (r.sistemaEquipo) {
        if (!currentLevel[r.sistemaEquipo]) currentLevel[r.sistemaEquipo] = {};
        currentLevel = currentLevel[r.sistemaEquipo];
        
        // Si tiene Sub-Sistema, agregar nivel 5
        if (r.subSistema) {
          if (!currentLevel[r.subSistema]) currentLevel[r.subSistema] = {};
          currentLevel = currentLevel[r.subSistema];
          
          // Si tiene Sección, agregar nivel 6
          if (r.seccion) {
            if (!currentLevel[r.seccion]) currentLevel[r.seccion] = {};
            currentLevel = currentLevel[r.seccion];
            
            // Si tiene Detalle, agregar nivel 7
            if (r.detalle) {
              if (!currentLevel[r.detalle]) currentLevel[r.detalle] = [];
              currentLevel[r.detalle].push(r);
            } else {
              // No tiene detalle, poner repuesto en nivel 6
              if (!Array.isArray(currentLevel)) {
                // Convertir a array si aún no lo es
                const keys = Object.keys(currentLevel);
                if (keys.length === 0) {
                  tree[planta][areaGeneral][subArea][r.sistemaEquipo][r.subSistema][r.seccion] = [r];
                  return;
                }
              }
              if (!currentLevel._repuestos) currentLevel._repuestos = [];
              currentLevel._repuestos.push(r);
            }
          } else {
            // No tiene sección, poner repuesto en nivel 5 (Sub-Sistema)
            if (!currentLevel._repuestos) currentLevel._repuestos = [];
            currentLevel._repuestos.push(r);
          }
        } else {
          // No tiene sub-sistema, poner repuesto en nivel 4 (Sistema)
          if (!currentLevel._repuestos) currentLevel._repuestos = [];
          currentLevel._repuestos.push(r);
        }
      } else {
        // No tiene sistema, poner repuesto en nivel 3 (Sub-Área)
        if (!currentLevel._repuestos) currentLevel._repuestos = [];
        currentLevel._repuestos.push(r);
      }
    });

    const container = document.getElementById('treeContainer');
    
    if (Object.keys(tree).length === 0) {
      container.innerHTML = '<div class="text-center" style="padding: 60px; color: var(--gray-500);">No hay repuestos para mostrar</div>';
      return;
    }

    let html = '';
    let nodeCounter = 0;
    
    // Función helper para generar IDs únicos
    const getNodeId = () => `node-${nodeCounter++}`;
    
    // Nivel 1: Planta
    Object.keys(tree).sort().forEach(planta => {
      const plantaId = getNodeId();
      html += `
        <div class="tree-node tree-area">
          <div class="tree-item" onclick="app.toggleTree('${plantaId}')" style="display: flex; align-items: center; gap: 8px;">
            <span class="tree-toggle" id="${plantaId}-toggle">▶</span>
            <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N1]</span> 🏭 ${planta}</span>
            <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}'})" 
                    class="btn btn-sm" 
                    style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                    onmouseover="this.style.opacity='1'"
                    onmouseout="this.style.opacity='0.7'"
                    title="Ver repuestos de esta planta en Inventario">
              📋 Ver
            </button>
          </div>
          <div class="tree-children" id="${plantaId}">
      `;
      
      // Nivel 2: Área General
      Object.keys(tree[planta]).sort().forEach(areaGeneral => {
        const areaId = getNodeId();
        
        // Si es "Sin Área Definida", mostrar repuestos directamente
        if (areaGeneral === 'Sin Área Definida') {
          const sinAreaData = tree[planta][areaGeneral];
          const repuestosSinArea = [];
          
          // Recolectar todos los repuestos que solo tienen planta
          const collectRepuestos = (obj) => {
            if (Array.isArray(obj)) {
              repuestosSinArea.push(...obj);
            } else {
              Object.values(obj).forEach(val => collectRepuestos(val));
            }
          };
          collectRepuestos(sinAreaData);
          
          if (repuestosSinArea.length > 0) {
            html += `
              <div class="tree-node tree-equipo">
                <div class="tree-item" onclick="app.toggleTree('${areaId}')">
                  <span class="tree-toggle" id="${areaId}-toggle">▶</span>
                  <span>📦 ${areaGeneral} (${repuestosSinArea.length})</span>
                </div>
                <div class="tree-children" id="${areaId}">
            `;
            
            repuestosSinArea.forEach(r => {
              html += `
                <div class="tree-node tree-repuesto">
                  <div class="tree-item" style="display: flex; align-items: center; gap: 8px;">
                    <span style="flex: 1;">🔍 ${r.codSAP || 'N/A'} - ${r.nombre}</span>
                    <span style="font-size: 0.85rem; color: var(--gray-500);">Stock: ${r.cantidad}</span>
                    <button onclick="app.irAInventarioConRepuesto('${r.id}')" style="
                      padding: 4px 12px;
                      font-size: 0.8rem;
                      background: var(--primary-color);
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                    " title="Ver en inventario">📋 Ver</button>
                  </div>
                </div>
              `;
            });
            
            html += '</div></div>';
          }
          return;
        }
        
        html += `
          <div class="tree-node tree-equipo">
            <div class="tree-item" onclick="app.toggleTree('${areaId}')" style="display: flex; align-items: center; gap: 8px;">
              <span class="tree-toggle" id="${areaId}-toggle">▶</span>
              <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N2]</span> 📁 ${areaGeneral}</span>
              <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}'})" 
                      class="btn btn-sm" 
                      style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                      onmouseover="this.style.opacity='1'"
                      onmouseout="this.style.opacity='0.7'"
                      title="Ver repuestos de esta área en Inventario">
                📋 Ver
              </button>
            </div>
            <div class="tree-children" id="${areaId}">
        `;
        
        // Nivel 3: Sub-Área
        Object.keys(tree[planta][areaGeneral]).sort().forEach(subArea => {
          const subAreaId = getNodeId();
          
          if (subArea === 'Sin Sub-Área') {
            // Mostrar solo si hay repuestos directos
            const subAreaData = tree[planta][areaGeneral][subArea];
            const repuestosSinSubArea = [];
            
            const collectRepuestos = (obj) => {
              if (Array.isArray(obj)) {
                repuestosSinSubArea.push(...obj);
              } else {
                Object.values(obj).forEach(val => collectRepuestos(val));
              }
            };
            collectRepuestos(subAreaData);
            
            if (repuestosSinSubArea.length > 0 && Object.keys(tree[planta][areaGeneral]).length === 1) {
              // Solo mostrar repuestos si no hay otras sub-áreas
              repuestosSinSubArea.forEach(r => {
                html += `
                  <div class="tree-node tree-repuesto">
                    <div class="tree-item" style="display: flex; align-items: center; gap: 8px;">
                      <span style="flex: 1;">🔍 ${r.codSAP || 'N/A'} - ${r.nombre}</span>
                      <span style="font-size: 0.85rem; color: var(--gray-500);">Stock: ${r.cantidad}</span>
                      <button onclick="app.irAInventarioConRepuesto('${r.id}')" style="
                        padding: 4px 12px;
                        font-size: 0.8rem;
                        background: var(--primary-color);
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                      " title="Ver en inventario">📋 Ver</button>
                    </div>
                  </div>
                `;
              });
            }
            return;
          }
          
          html += `
            <div class="tree-node tree-equipo">
              <div class="tree-item" onclick="app.toggleTree('${subAreaId}')" style="display: flex; align-items: center; gap: 8px;">
                <span class="tree-toggle" id="${subAreaId}-toggle">▶</span>
                <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N3]</span> 📁 ${subArea}</span>
                <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}', subArea: '${subArea.replace(/'/g, "\\'")}'})" 
                        class="btn btn-sm" 
                        style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                        onmouseover="this.style.opacity='1'"
                        onmouseout="this.style.opacity='0.7'"
                        title="Ver repuestos de esta sub-área en Inventario">
                  📋 Ver
                </button>
              </div>
              <div class="tree-children" id="${subAreaId}">
          `;
          
          // Función auxiliar para renderizar repuestos en cualquier nivel
          const renderRepuestos = (repuestosArray) => {
            repuestosArray.forEach(r => {
              html += `
                <div class="tree-node tree-repuesto">
                  <div class="tree-item" style="display: flex; align-items: center; gap: 8px;">
                    <span style="flex: 1;">🔩 ${r.codSAP || 'N/A'} - ${r.nombre}</span>
                    <span style="font-size: 0.85rem; color: var(--gray-500);">Stock: ${r.cantidad}</span>
                    <button onclick="app.irAInventarioConRepuesto('${r.id}')" style="
                      padding: 4px 12px;
                      font-size: 0.8rem;
                      background: var(--primary-color);
                      color: white;
                      border: none;
                      border-radius: 4px;
                      cursor: pointer;
                    " title="Ver en inventario">📋 Ver</button>
                  </div>
                </div>
              `;
            });
          };
          
          // Primero, mostrar repuestos directos de este nivel (Sub-Área)
          const subAreaData = tree[planta][areaGeneral][subArea];
          if (subAreaData._repuestos) {
            renderRepuestos(subAreaData._repuestos);
          }
          
          // Nivel 4: Sistema/Equipo
          Object.keys(tree[planta][areaGeneral][subArea])
            .filter(key => key !== '_repuestos')
            .sort()
            .forEach(sistemaEquipo => {
              const sistemaId = getNodeId();
              const nivel4Data = tree[planta][areaGeneral][subArea][sistemaEquipo];
            
              html += `
                <div class="tree-node tree-sistema">
                  <div class="tree-item" onclick="app.toggleTree('${sistemaId}')" style="display: flex; align-items: center; gap: 8px;">
                    <span class="tree-toggle" id="${sistemaId}-toggle">▶</span>
                    <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N4]</span> ⚙️ ${sistemaEquipo}</span>
                    <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}', subArea: '${subArea.replace(/'/g, "\\'")}', sistemaEquipo: '${sistemaEquipo.replace(/'/g, "\\'")}'})" 
                            class="btn btn-sm" 
                            style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                            onmouseover="this.style.opacity='1'"
                            onmouseout="this.style.opacity='0.7'"
                            title="Ver repuestos de este sistema en Inventario">
                      📋 Ver
                    </button>
                  </div>
                  <div class="tree-children" id="${sistemaId}">
              `;
              
              // Repuestos directos de nivel 4
              if (nivel4Data._repuestos) {
                renderRepuestos(nivel4Data._repuestos);
              }
            
              // Nivel 5: Sub-Sistema
              Object.keys(nivel4Data)
                .filter(key => key !== '_repuestos')
                .sort()
                .forEach(subSistema => {
                  const subSistemaId = getNodeId();
                  const nivel5Data = nivel4Data[subSistema];
                
                  html += `
                    <div class="tree-node tree-subsistema">
                      <div class="tree-item" onclick="app.toggleTree('${subSistemaId}')" style="display: flex; align-items: center; gap: 8px;">
                        <span class="tree-toggle" id="${subSistemaId}-toggle">▶</span>
                        <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N5]</span> 🔧 ${subSistema}</span>
                        <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}', subArea: '${subArea.replace(/'/g, "\\'")}', sistemaEquipo: '${sistemaEquipo.replace(/'/g, "\\'")}', subSistema: '${subSistema.replace(/'/g, "\\'")}'})" 
                                class="btn btn-sm" 
                                style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                                onmouseover="this.style.opacity='1'"
                                onmouseout="this.style.opacity='0.7'"
                                title="Ver repuestos de este sub-sistema en Inventario">
                          📋 Ver
                        </button>
                      </div>
                      <div class="tree-children" id="${subSistemaId}">
                  `;
                  
                  // Repuestos directos de nivel 5
                  if (nivel5Data._repuestos) {
                    renderRepuestos(nivel5Data._repuestos);
                  }
                  
                  // Nivel 6: Sección
                  Object.keys(nivel5Data)
                    .filter(key => key !== '_repuestos')
                    .sort()
                    .forEach(seccion => {
                      const seccionId = getNodeId();
                      const nivel6Data = nivel5Data[seccion];
                    
                      html += `
                        <div class="tree-node tree-seccion">
                          <div class="tree-item" onclick="app.toggleTree('${seccionId}')" style="display: flex; align-items: center; gap: 8px;">
                            <span class="tree-toggle" id="${seccionId}-toggle">▶</span>
                            <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N6]</span> 📋 ${seccion}</span>
                            <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}', subArea: '${subArea.replace(/'/g, "\\'")}', sistemaEquipo: '${sistemaEquipo.replace(/'/g, "\\'")}', subSistema: '${subSistema.replace(/'/g, "\\'")}', seccion: '${seccion.replace(/'/g, "\\'")}'})" 
                                    class="btn btn-sm" 
                                    style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                                    onmouseover="this.style.opacity='1'"
                                    onmouseout="this.style.opacity='0.7'"
                                    title="Ver repuestos de esta sección en Inventario">
                              📋 Ver
                            </button>
                          </div>
                          <div class="tree-children" id="${seccionId}">
                      `;
                      
                      // Repuestos directos de nivel 6
                      if (nivel6Data._repuestos) {
                        renderRepuestos(nivel6Data._repuestos);
                      }
                      
                      // Nivel 7: Detalle
                      Object.keys(nivel6Data)
                        .filter(key => key !== '_repuestos')
                        .sort()
                        .forEach(detalle => {
                          const detalleId = getNodeId();
                          const nivel7Data = nivel6Data[detalle];
                          
                          // Solo mostrar si es un array (repuestos en nivel 7)
                          if (Array.isArray(nivel7Data)) {
                            html += `
                              <div class="tree-node tree-detalle">
                                <div class="tree-item" onclick="app.toggleTree('${detalleId}')" style="display: flex; align-items: center; gap: 8px;">
                                  <span class="tree-toggle" id="${detalleId}-toggle">▶</span>
                                  <span style="flex: 1;"><span style="opacity: 0.6; font-size: 0.85em;">[N7]</span> 🔍 ${detalle}</span>
                                  <button onclick="event.stopPropagation(); app.irAInventarioConFiltro({planta: '${planta.replace(/'/g, "\\'")}', areaGeneral: '${areaGeneral.replace(/'/g, "\\'")}', subArea: '${subArea.replace(/'/g, "\\'")}', sistemaEquipo: '${sistemaEquipo.replace(/'/g, "\\'")}', subSistema: '${subSistema.replace(/'/g, "\\'")}', seccion: '${seccion.replace(/'/g, "\\'")}', detalle: '${detalle.replace(/'/g, "\\'")}'})" 
                                          class="btn btn-sm" 
                                          style="padding: 4px 8px; font-size: 0.75rem; opacity: 0.7; transition: opacity 0.2s;"
                                          onmouseover="this.style.opacity='1'"
                                          onmouseout="this.style.opacity='0.7'"
                                          title="Ver repuestos de este detalle en Inventario">
                                    📋 Ver
                                  </button>
                                </div>
                                <div class="tree-children" id="${detalleId}">
                            `;
                            
                            renderRepuestos(nivel7Data);
                            
                            html += '</div></div>'; // Cierra detalle
                          }
                        });
                      
                      html += '</div></div>'; // Cierra sección
                    });
                  
                  html += '</div></div>'; // Cierra sub-sistema
                });
              
              html += '</div></div>'; // Cierra sistema
            });          html += '</div></div>'; // Cierra sub-área
        });
        
        html += '</div></div>';
      });
      
      html += '</div></div>';
    });
    
    container.innerHTML = html;
    
    // Actualizar contador
    this.actualizarContadorJerarquia();
  }

  toggleTree(id) {
    const element = document.getElementById(id);
    const toggle = document.getElementById(id + '-toggle');
    
    if (element.classList.contains('expanded')) {
      element.classList.remove('expanded');
      toggle.classList.remove('expanded');
    } else {
      element.classList.add('expanded');
      toggle.classList.add('expanded');
    }
  }

  // Expandir/Contraer todo el árbol
  toggleAllTree() {
    const allChildren = document.querySelectorAll('.tree-children');
    const allToggles = document.querySelectorAll('.tree-toggle');
    const icon = document.getElementById('toggleAllIcon');
    const text = document.getElementById('toggleAllText');
    
    // Verificar si hay alguno expandido
    const anyExpanded = Array.from(allChildren).some(child => child.classList.contains('expanded'));
    
    if (anyExpanded) {
      // Contraer todo
      allChildren.forEach(child => child.classList.remove('expanded'));
      allToggles.forEach(toggle => toggle.classList.remove('expanded'));
      icon.textContent = '📂';
      text.textContent = 'Expandir Todo';
    } else {
      // Expandir todo
      allChildren.forEach(child => child.classList.add('expanded'));
      allToggles.forEach(toggle => toggle.classList.add('expanded'));
      icon.textContent = '📁';
      text.textContent = 'Contraer Todo';
    }
  }

  // Inicializar opciones de filtros escalonados
  inicializarFiltrosJerarquia() {
    // Cargar opciones de plantas
    const plantas = [...new Set(this.repuestos.map(r => r.planta).filter(Boolean))].sort();
    const selectPlanta = document.getElementById('filtro_planta');
    selectPlanta.innerHTML = '<option value="">🏭 Todas las plantas</option>';
    plantas.forEach(p => {
      selectPlanta.innerHTML += `<option value="${p}">${p}</option>`;
    });
  }

  // Filtrado escalonado por jerarquía
  filtrarEscalonado(nivel, valor) {
    const filtroPlanta = document.getElementById('filtro_planta');
    const filtroArea = document.getElementById('filtro_area');
    const filtroSubArea = document.getElementById('filtro_subarea');
    const filtroSistema = document.getElementById('filtro_sistema');
    const filtroSubSistema = document.getElementById('filtro_subsistema');
    const filtroSeccion = document.getElementById('filtro_seccion');
    const filtroDetalle = document.getElementById('filtro_detalle');
    const btnLimpiar = document.getElementById('btnLimpiarFiltros');
    
    // Construir filtros actuales
    const filtros = {
      planta: filtroPlanta.value,
      area: filtroArea.value,
      subarea: filtroSubArea.value,
      sistema: filtroSistema.value,
      subsistema: filtroSubSistema.value,
      seccion: filtroSeccion.value,
      detalle: filtroDetalle.value
    };
    
    // Si se selecciona un nivel, actualizar los siguientes
    if (nivel === 1 && valor) {
      // Planta seleccionada → mostrar áreas
      filtroArea.style.display = 'block';
      btnLimpiar.style.display = 'block';
      
      // Cargar opciones de áreas para esta planta
      const areas = [...new Set(
        this.repuestos
          .filter(r => r.planta === valor && r.areaGeneral)
          .map(r => r.areaGeneral)
      )].sort();
      
      filtroArea.innerHTML = '<option value="">📁 Todas las áreas</option>';
      areas.forEach(a => {
        filtroArea.innerHTML += `<option value="${a}">${a}</option>`;
      });
      
      // Ocultar niveles siguientes
      filtroSubArea.style.display = 'none';
      filtroSubArea.value = '';
      filtroSistema.style.display = 'none';
      filtroSistema.value = '';
      filtroSubSistema.style.display = 'none';
      filtroSubSistema.value = '';
      filtroSeccion.style.display = 'none';
      filtroSeccion.value = '';
      filtroDetalle.style.display = 'none';
      filtroDetalle.value = '';
      
    } else if (nivel === 2 && valor) {
      // Área seleccionada → mostrar sub-áreas
      filtroSubArea.style.display = 'block';
      
      const subareas = [...new Set(
        this.repuestos
          .filter(r => r.planta === filtros.planta && r.areaGeneral === valor && r.subArea)
          .map(r => r.subArea)
      )].sort();
      
      filtroSubArea.innerHTML = '<option value="">📁 Todas las sub-áreas</option>';
      subareas.forEach(s => {
        filtroSubArea.innerHTML += `<option value="${s}">${s}</option>`;
      });
      
      // Ocultar niveles siguientes
      filtroSistema.style.display = 'none';
      filtroSistema.value = '';
      filtroSubSistema.style.display = 'none';
      filtroSubSistema.value = '';
      filtroSeccion.style.display = 'none';
      filtroSeccion.value = '';
      filtroDetalle.style.display = 'none';
      filtroDetalle.value = '';
      
    } else if (nivel === 3 && valor) {
      // Sub-área seleccionada → mostrar sistemas
      filtroSistema.style.display = 'block';
      
      const sistemas = [...new Set(
        this.repuestos
          .filter(r => 
            r.planta === filtros.planta && 
            r.areaGeneral === filtros.area && 
            r.subArea === valor && 
            r.sistemaEquipo
          )
          .map(r => r.sistemaEquipo)
      )].sort();
      
      filtroSistema.innerHTML = '<option value="">📁 Todos los sistemas</option>';
      sistemas.forEach(s => {
        filtroSistema.innerHTML += `<option value="${s}">${s}</option>`;
      });
      
      // Ocultar niveles siguientes
      filtroSubSistema.style.display = 'none';
      filtroSubSistema.value = '';
      filtroSeccion.style.display = 'none';
      filtroSeccion.value = '';
      filtroDetalle.style.display = 'none';
      filtroDetalle.value = '';
      
    } else if (nivel === 4 && valor) {
      // Sistema seleccionado → mostrar sub-sistemas
      filtroSubSistema.style.display = 'block';
      
      const subsistemas = [...new Set(
        this.repuestos
          .filter(r => 
            r.planta === filtroPlanta.value && 
            r.areaGeneral === filtroArea.value && 
            r.subArea === filtroSubArea.value && 
            r.sistemaEquipo === valor && 
            r.subSistema
          )
          .map(r => r.subSistema)
      )].sort();
      
      filtroSubSistema.innerHTML = '<option value="">📁 Todos los sub-sistemas</option>';
      subsistemas.forEach(s => {
        filtroSubSistema.innerHTML += `<option value="${s}">${s}</option>`;
      });
      
      // Ocultar niveles siguientes
      filtroSeccion.style.display = 'none';
      filtroSeccion.value = '';
      filtroDetalle.style.display = 'none';
      filtroDetalle.value = '';
      
    } else if (nivel === 5 && valor) {
      // Sub-sistema seleccionado → mostrar secciones
      filtroSeccion.style.display = 'block';
      
      const secciones = [...new Set(
        this.repuestos
          .filter(r => 
            r.planta === filtroPlanta.value && 
            r.areaGeneral === filtroArea.value && 
            r.subArea === filtroSubArea.value && 
            r.sistemaEquipo === filtroSistema.value && 
            r.subSistema === valor && 
            r.seccion
          )
          .map(r => r.seccion)
      )].sort();
      
      filtroSeccion.innerHTML = '<option value="">📁 Todas las secciones</option>';
      secciones.forEach(s => {
        filtroSeccion.innerHTML += `<option value="${s}">${s}</option>`;
      });
      
      // Ocultar nivel siguiente
      filtroDetalle.style.display = 'none';
      filtroDetalle.value = '';
      
    } else if (nivel === 6 && valor) {
      // Sección seleccionada → mostrar detalles
      filtroDetalle.style.display = 'block';
      
      const detalles = [...new Set(
        this.repuestos
          .filter(r => 
            r.planta === filtroPlanta.value && 
            r.areaGeneral === filtroArea.value && 
            r.subArea === filtroSubArea.value && 
            r.sistemaEquipo === filtroSistema.value && 
            r.subSistema === filtroSubSistema.value && 
            r.seccion === valor && 
            r.detalle
          )
          .map(r => r.detalle)
      )].sort();
      
      filtroDetalle.innerHTML = '<option value="">📁 Todos los detalles</option>';
      detalles.forEach(d => {
        filtroDetalle.innerHTML += `<option value="${d}">${d}</option>`;
      });
    }
    
    // Actualizar breadcrumb visual
    this.actualizarBreadcrumbFiltros();
    
    // Aplicar filtros y renderizar
    this.aplicarFiltrosJerarquia();
  }

  // Actualizar breadcrumb visual de filtros activos
  actualizarBreadcrumbFiltros() {
    const breadcrumb = document.getElementById('filtrosBreadcrumb');
    const breadcrumbPath = document.getElementById('breadcrumbPath');
    
    const filtroPlanta = document.getElementById('filtro_planta').value;
    const filtroArea = document.getElementById('filtro_area').value;
    const filtroSubArea = document.getElementById('filtro_subarea').value;
    const filtroSistema = document.getElementById('filtro_sistema').value;
    const filtroSubSistema = document.getElementById('filtro_subsistema').value;
    const filtroSeccion = document.getElementById('filtro_seccion').value;
    const filtroDetalle = document.getElementById('filtro_detalle').value;
    
    // Si no hay filtros activos, ocultar breadcrumb
    if (!filtroPlanta && !filtroArea && !filtroSubArea && !filtroSistema && !filtroSubSistema && !filtroSeccion && !filtroDetalle) {
      breadcrumb.style.display = 'none';
      return;
    }
    
    // Construir ruta visual
    let ruta = [];
    
    if (filtroPlanta) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>🏭</strong> ${filtroPlanta}</span>`);
    }
    
    if (filtroArea) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>📁</strong> ${filtroArea}</span>`);
    }
    
    if (filtroSubArea) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>📁</strong> ${filtroSubArea}</span>`);
    }
    
    if (filtroSistema) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>⚙️</strong> ${filtroSistema}</span>`);
    }
    
    if (filtroSubSistema) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>🔧</strong> ${filtroSubSistema}</span>`);
    }
    
    if (filtroSeccion) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>📋</strong> ${filtroSeccion}</span>`);
    }
    
    if (filtroDetalle) {
      ruta.push(`<span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px;"><strong>🔍</strong> ${filtroDetalle}</span>`);
    }
    
    // Unir con flechas
    breadcrumbPath.innerHTML = ruta.join(' <span style="opacity: 0.6;">→</span> ');
    
    // Mostrar breadcrumb
    breadcrumb.style.display = 'flex';
  }

  // Aplicar filtros actuales y renderizar
  aplicarFiltrosJerarquia() {
    const filtroPlanta = document.getElementById('filtro_planta').value;
    const filtroArea = document.getElementById('filtro_area').value;
    const filtroSubArea = document.getElementById('filtro_subarea').value;
    const filtroSistema = document.getElementById('filtro_sistema').value;
    const filtroSubSistema = document.getElementById('filtro_subsistema').value;
    const filtroSeccion = document.getElementById('filtro_seccion').value;
    const filtroDetalle = document.getElementById('filtro_detalle').value;
    
    // Si no hay filtros, mostrar todo
    if (!filtroPlanta && !filtroArea && !filtroSubArea && !filtroSistema && !filtroSubSistema && !filtroSeccion && !filtroDetalle) {
      this.renderJerarquia();
      return;
    }
    
    // Filtrar repuestos según criterios
    const repuestosFiltrados = this.repuestos.filter(r => {
      if (filtroPlanta && r.planta !== filtroPlanta) return false;
      if (filtroArea && r.areaGeneral !== filtroArea) return false;
      if (filtroSubArea && r.subArea !== filtroSubArea) return false;
      if (filtroSistema && r.sistemaEquipo !== filtroSistema) return false;
      if (filtroSubSistema && r.subSistema !== filtroSubSistema) return false;
      if (filtroSeccion && r.seccion !== filtroSeccion) return false;
      if (filtroDetalle && r.detalle !== filtroDetalle) return false;
      return true;
    });
    
    // Actualizar contador
    document.getElementById('repuestosVisibles').textContent = repuestosFiltrados.length;
    
    // Renderizar árbol filtrado
    this.renderJerarquiaFiltrada(repuestosFiltrados);
  }

  // Limpiar todos los filtros
  limpiarFiltrosJerarquia() {
    document.getElementById('filtro_planta').value = '';
    document.getElementById('filtro_area').value = '';
    document.getElementById('filtro_area').style.display = 'none';
    document.getElementById('filtro_subarea').value = '';
    document.getElementById('filtro_subarea').style.display = 'none';
    document.getElementById('filtro_sistema').value = '';
    document.getElementById('filtro_sistema').style.display = 'none';
    document.getElementById('filtro_subsistema').value = '';
    document.getElementById('filtro_subsistema').style.display = 'none';
    document.getElementById('filtro_seccion').value = '';
    document.getElementById('filtro_seccion').style.display = 'none';
    document.getElementById('filtro_detalle').value = '';
    document.getElementById('filtro_detalle').style.display = 'none';
    document.getElementById('btnLimpiarFiltros').style.display = 'none';
    
    // Ocultar breadcrumb
    document.getElementById('filtrosBreadcrumb').style.display = 'none';
    
    // Renderizar todo
    this.renderJerarquia();
  }

  // Ir a inventario con filtros desde un nodo jerárquico
  irAInventarioConFiltro(filtros) {
    console.log('🔍 irAInventarioConFiltro llamado con:', filtros);
    
    // Aplicar filtros jerárquicos PRIMERO
    this.filtrosJerarquicosActivos = filtros;
    
    console.log('✅ Filtros guardados en this.filtrosJerarquicosActivos:', this.filtrosJerarquicosActivos);
    
    // Mostrar botón para quitar filtros
    const btnQuitar = document.getElementById('quitarFiltrosJerarquicosBtn');
    if (btnQuitar) {
      btnQuitar.style.display = 'inline-block';
      console.log('✅ Botón "Quitar Filtros" mostrado');
    }
    
    // Cambiar a pestaña inventario (esto llamará a renderInventario)
    this.switchTab('inventario');
    
    // FORZAR re-renderizado después de cambiar de pestaña para asegurar que los filtros se apliquen
    setTimeout(() => {
      console.log('🔄 Re-renderizando inventario con filtros...');
      this.renderInventario();
    }, 50);
    
    // Mostrar toast informativo con el nivel MÁS ESPECÍFICO
    const nivelNombres = {
      planta: '🏭 Planta',
      areaGeneral: '📁 Área',
      subArea: '📁 Sub-Área',
      sistemaEquipo: '⚙️ Sistema',
      subSistema: '🔧 Sub-Sistema',
      seccion: '📋 Sección',
      detalle: '🔍 Detalle'
    };
    
    // Buscar el nivel más profundo (el último con valor)
    const ordenNiveles = ['detalle', 'seccion', 'subSistema', 'sistemaEquipo', 'subArea', 'areaGeneral', 'planta'];
    const filtroActivo = ordenNiveles.find(k => filtros[k]);
    
    if (filtroActivo) {
      this.showToast(`🔍 Filtrando por ${nivelNombres[filtroActivo]}: ${filtros[filtroActivo]}`, 'info');
    }
  }

  // Ir a inventario mostrando solo un repuesto específico
  irAInventarioConRepuesto(repuestoId) {
    console.log('🔍 irAInventarioConRepuesto llamado con ID:', repuestoId);
    
    // Buscar el repuesto para obtener su nombre
    const repuesto = this.repuestos.find(r => r.id === repuestoId);
    if (!repuesto) {
      console.error('❌ Repuesto no encontrado:', repuestoId);
      return;
    }
    
    // Aplicar filtro por ID de repuesto
    this.filtrosJerarquicosActivos = { repuestoId: repuestoId };
    
    console.log('✅ Filtro de repuesto guardado:', this.filtrosJerarquicosActivos);
    
    // Mostrar botón para quitar filtros
    const btnQuitar = document.getElementById('quitarFiltrosJerarquicosBtn');
    if (btnQuitar) {
      btnQuitar.style.display = 'inline-block';
      console.log('✅ Botón "Quitar Filtros" mostrado');
    }
    
    // Cambiar a pestaña inventario
    this.switchTab('inventario');
    
    // FORZAR re-renderizado
    setTimeout(() => {
      console.log('🔄 Re-renderizando inventario con filtro de repuesto...');
      this.renderInventario();
    }, 50);
    
    // Mostrar toast informativo con el nombre del repuesto
    const nombreRepuesto = repuesto.nombre || repuesto.codSAP || 'Repuesto';
    this.showToast(`🔍 Mostrando repuesto: ${nombreRepuesto}`, 'info');
  }

  // Buscar en jerarquía (niveles y repuestos)
  buscarEnJerarquia(query) {
    const resultsContainer = document.getElementById('searchResultsJerarquia');
    
    if (!query || query.trim().length < 2) {
      resultsContainer.style.display = 'none';
      return;
    }
    
    const searchTerm = query.toLowerCase().trim();
    const results = [];
    
    // Buscar SOLO en repuestos por código o nombre
    this.repuestos.forEach(r => {
      const matches = 
        (r.codSAP && r.codSAP.toLowerCase().includes(searchTerm)) ||
        (r.nombre && r.nombre.toLowerCase().includes(searchTerm));
      
      if (matches) {
        results.push({
          tipo: 'repuesto',
          id: r.id,
          nombre: r.nombre,
          codSAP: r.codSAP,
          stock: r.cantidad,
          ubicacion: [r.planta, r.areaGeneral, r.sistemaEquipo].filter(x => x).join(' > ')
        });
      }
    });
    
    // Buscar en niveles jerárquicos Y contar repuestos de cada nivel
    const nivelesMap = new Map();
    
    this.repuestos.forEach(r => {
      // Nivel 1: Planta
      if (r.planta && r.planta.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ tipo: 'planta', valor: r.planta, nivel: 'Planta' });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 2: Área General
      if (r.areaGeneral && r.areaGeneral.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'areaGeneral', 
          valor: r.areaGeneral, 
          nivel: 'Área',
          planta: r.planta 
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 3: Sub-Área
      if (r.subArea && r.subArea.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'subArea', 
          valor: r.subArea, 
          nivel: 'Sub-Área',
          planta: r.planta,
          areaGeneral: r.areaGeneral
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 4: Sistema/Equipo
      if (r.sistemaEquipo && r.sistemaEquipo.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'sistemaEquipo', 
          valor: r.sistemaEquipo, 
          nivel: 'Sistema',
          planta: r.planta,
          areaGeneral: r.areaGeneral,
          subArea: r.subArea
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 5: Sub-Sistema
      if (r.subSistema && r.subSistema.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'subSistema', 
          valor: r.subSistema, 
          nivel: 'Sub-Sistema',
          planta: r.planta,
          areaGeneral: r.areaGeneral,
          subArea: r.subArea,
          sistemaEquipo: r.sistemaEquipo
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 6: Sección
      if (r.seccion && r.seccion.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'seccion', 
          valor: r.seccion, 
          nivel: 'Sección',
          planta: r.planta,
          areaGeneral: r.areaGeneral,
          subArea: r.subArea,
          sistemaEquipo: r.sistemaEquipo,
          subSistema: r.subSistema
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
      
      // Nivel 7: Detalle
      if (r.detalle && r.detalle.toLowerCase().includes(searchTerm)) {
        const key = JSON.stringify({ 
          tipo: 'detalle', 
          valor: r.detalle, 
          nivel: 'Detalle',
          planta: r.planta,
          areaGeneral: r.areaGeneral,
          subArea: r.subArea,
          sistemaEquipo: r.sistemaEquipo,
          subSistema: r.subSistema,
          seccion: r.seccion
        });
        if (!nivelesMap.has(key)) {
          nivelesMap.set(key, { data: JSON.parse(key), count: 0 });
        }
        nivelesMap.get(key).count++;
      }
    });
    
    // Convertir niveles a array de objetos
    const nivelesArray = Array.from(nivelesMap.values());
    
    // Renderizar resultados
    let html = '';
    
    if (nivelesArray.length === 0 && results.length === 0) {
      html = '<div style="padding: 16px; text-align: center; color: var(--gray-500);">No se encontraron resultados</div>';
    } else {
      // Mostrar niveles jerárquicos primero
      if (nivelesArray.length > 0) {
        html += '<div style="padding: 8px; background: var(--bg-light); border-bottom: 1px solid var(--border-color); font-weight: bold; color: var(--primary-color);">📁 Niveles Jerárquicos</div>';
        nivelesArray.slice(0, 10).forEach(nivelObj => {
          const nivel = nivelObj.data;
          const count = nivelObj.count;
          
          const filtros = {};
          if (nivel.planta) filtros.planta = nivel.planta;
          if (nivel.areaGeneral) filtros.areaGeneral = nivel.areaGeneral;
          if (nivel.subArea) filtros.subArea = nivel.subArea;
          if (nivel.sistemaEquipo) filtros.sistemaEquipo = nivel.sistemaEquipo;
          if (nivel.subSistema) filtros.subSistema = nivel.subSistema;
          if (nivel.seccion) filtros.seccion = nivel.seccion;
          if (nivel.detalle) filtros.detalle = nivel.detalle;
          
          const filtrosStr = JSON.stringify(filtros).replace(/"/g, '&quot;');
          
          html += `
            <div 
              onclick="app.irAInventarioConFiltro(${filtrosStr}); document.getElementById('searchJerarquia').value = ''; app.buscarEnJerarquia('');" 
              style="
                padding: 12px;
                border-bottom: 1px solid var(--border-color);
                cursor: pointer;
                transition: background 0.2s;
                background: var(--bg-primary);
              "
              onmouseover="this.style.background='var(--bg-secondary)'"
              onmouseout="this.style.background='var(--bg-primary)'"
            >
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="font-weight: 600; color: var(--text-primary);">
                  ${nivel.nivel}: ${nivel.valor}
                </div>
                <div style="background: var(--primary-color); color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem; font-weight: bold;">
                  ${count} repuesto${count !== 1 ? 's' : ''}
                </div>
              </div>
              <div style="font-size: 0.85rem; color: var(--gray-500); margin-top: 4px;">
                ${[nivel.planta, nivel.areaGeneral, nivel.subArea].filter(x => x).join(' > ')}
              </div>
            </div>
          `;
        });
      }
      
      // Mostrar repuestos
      if (results.length > 0) {
        html += '<div style="padding: 8px; background: var(--bg-light); border-bottom: 1px solid var(--border-color); font-weight: bold; color: var(--primary-color);">🔍 Repuestos</div>';
        results.slice(0, 15).forEach(r => {
          html += `
            <div 
              onclick="app.irAInventarioConRepuesto('${r.id}'); document.getElementById('searchJerarquia').value = ''; app.buscarEnJerarquia('');" 
              style="
                padding: 12px;
                border-bottom: 1px solid var(--border-color);
                cursor: pointer;
                transition: background 0.2s;
                background: var(--bg-primary);
              "
              onmouseover="this.style.background='var(--bg-secondary)'"
              onmouseout="this.style.background='var(--bg-primary)'"
            >
              <div style="font-weight: 600; color: var(--text-primary);">
                ${r.codSAP || 'N/A'} - ${r.nombre}
              </div>
              <div style="font-size: 0.85rem; color: var(--gray-500); margin-top: 4px; display: flex; justify-content: space-between;">
                <span>${r.ubicacion || 'Sin ubicación'}</span>
                <span style="color: var(--primary-color);">Stock: ${r.stock}</span>
              </div>
            </div>
          `;
        });
      }
      
      if (nivelesArray.length + results.length > 25) {
        html += '<div style="padding: 8px; text-align: center; color: var(--gray-500); font-size: 0.85rem;">Mostrando primeros 25 resultados...</div>';
      }
    }
    
    resultsContainer.innerHTML = html;
    resultsContainer.style.display = 'block';
  }

  // Renderizar jerarquía con repuestos filtrados
  renderJerarquiaFiltrada(repuestosFiltrados) {
    const tree = {};
    
    // Construir árbol con repuestos filtrados
    repuestosFiltrados.forEach(r => {
      const planta = r.planta || 'Sin Clasificar';
      if (!tree[planta]) tree[planta] = {};
      
      const areaGeneral = r.areaGeneral || '🔧 Inventario General';
      if (!tree[planta][areaGeneral]) tree[planta][areaGeneral] = {};
      
      const subArea = r.subArea || 'Sin Sub-Área';
      if (!tree[planta][areaGeneral][subArea]) tree[planta][areaGeneral][subArea] = {};
      
      const sistemaEquipo = r.sistemaEquipo || 'Sin Sistema';
      if (!tree[planta][areaGeneral][subArea][sistemaEquipo]) tree[planta][areaGeneral][subArea][sistemaEquipo] = {};
      
      const subSistema = r.subSistema || 'Sin Sub-Sistema';
      if (!tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema]) tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema] = {};
      
      const seccion = r.seccion || 'Sin Sección';
      if (!tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema][seccion]) tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema][seccion] = {};
      
      const detalle = r.detalle || 'Repuestos';
      if (!tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema][seccion][detalle]) {
        tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema][seccion][detalle] = [];
      }
      
      tree[planta][areaGeneral][subArea][sistemaEquipo][subSistema][seccion][detalle].push(r);
    });

    const container = document.getElementById('treeContainer');
    
    if (repuestosFiltrados.length === 0) {
      container.innerHTML = '<div class="text-center" style="padding: 60px; color: var(--gray-500);">No hay repuestos en este nivel</div>';
      return;
    }

    let html = '';
    let nodeCounter = 0;
    const getNodeId = () => `node-${nodeCounter++}`;
    
    // Renderizar árbol simplificado (igual que renderJerarquia pero con datos filtrados)
    Object.keys(tree).sort().forEach(planta => {
      const plantaId = getNodeId();
      html += `
        <div class="tree-node tree-area">
          <div class="tree-item" onclick="app.toggleTree('${plantaId}')">
            <span class="tree-toggle expanded" id="${plantaId}-toggle">▼</span>
            <span>🏭 ${planta}</span>
          </div>
          <div class="tree-children expanded" id="${plantaId}">
      `;
      
      // Recolectar y mostrar todos los repuestos bajo esta planta
      const collectAllRepuestos = (obj, repuestos = []) => {
        if (Array.isArray(obj)) {
          repuestos.push(...obj);
        } else {
          Object.values(obj).forEach(val => collectAllRepuestos(val, repuestos));
        }
        return repuestos;
      };
      
      const repuestos = collectAllRepuestos(tree[planta]);
      repuestos.forEach(r => {
        html += `
          <div class="tree-node tree-repuesto">
            <div class="tree-item" style="display: flex; align-items: center; gap: 8px; padding-left: 40px;">
              <span style="flex: 1;">🔍 ${r.codSAP || 'N/A'} - ${r.nombre}</span>
              <span style="font-size: 0.85rem; color: var(--gray-500);">Stock: ${r.cantidad}</span>
              <button onclick="app.irAInventarioConRepuesto('${r.id}')" style="
                padding: 4px 12px;
                font-size: 0.8rem;
                background: var(--primary-color);
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
              " title="Ver en inventario">📋 Ver</button>
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
    });
    
    container.innerHTML = html;
  }

  // Actualizar contador de repuestos visibles
  actualizarContadorJerarquia() {
    const counter = document.getElementById('repuestosVisibles');
    if (counter) {
      counter.textContent = this.repuestos.length;
    }
  }

  // Ir a tarjeta desde jerarquía (con opción de filtros)
  irATarjeta(id, aplicarFiltrosJerarquicos = false) {
    // Si se solicita aplicar filtros jerárquicos, obtenerlos del repuesto
    if (aplicarFiltrosJerarquicos) {
      const repuesto = this.repuestos.find(r => r.id === id);
      if (repuesto) {
        this.aplicarFiltrosDesdeJerarquia(repuesto);
      }
    }
    
    // Cambiar al tab de inventario
    this.switchTab('inventario');
    
    // Esperar a que se renderice el tab
    setTimeout(() => {
      // Buscar la tarjeta del producto
      const card = document.querySelector(`[data-id="${id}"]`)?.closest('.repuesto-card');
      
      if (card) {
        // Hacer scroll suave a la tarjeta
        card.scrollIntoView({ 
          behavior: 'smooth', 
          block: 'center' 
        });
        
        // Destacar la tarjeta temporalmente
        card.style.transition = 'all 0.3s ease';
        card.style.transform = 'scale(1.05)';
        card.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.6)';
        card.style.borderColor = '#3b82f6';
        
        setTimeout(() => {
          card.style.transform = '';
          card.style.boxShadow = '';
          card.style.borderColor = '';
        }, 2000);
        
        this.showToast('📍 Producto localizado', 'success');
      } else {
        this.showToast('⚠️ Producto no encontrado en vista actual', 'warning');
      }
    }, 300);
  }

  // Aplicar filtros de jerarquía en inventario
  aplicarFiltrosDesdeJerarquia(repuesto) {
    // Guardar los filtros jerárquicos activos
    this.filtrosJerarquicosActivos = {
      planta: repuesto.planta,
      areaGeneral: repuesto.areaGeneral,
      subArea: repuesto.subArea,
      sistemaEquipo: repuesto.sistemaEquipo,
      subSistema: repuesto.subSistema,
      seccion: repuesto.seccion
    };
    
    // Mostrar botón para quitar filtros
    const btnQuitar = document.getElementById('quitarFiltrosJerarquicosBtn');
    if (btnQuitar) {
      btnQuitar.style.display = 'inline-block';
    }
    
    // Re-renderizar inventario con filtros aplicados
    this.renderInventario();
  }

  // Quitar filtros jerárquicos aplicados desde jerarquía
  quitarFiltrosJerarquicos() {
    this.filtrosJerarquicosActivos = null;
    
    // Ocultar botón
    const btnQuitar = document.getElementById('quitarFiltrosJerarquicosBtn');
    if (btnQuitar) {
      btnQuitar.style.display = 'none';
    }
    
    // Re-renderizar inventario sin filtros jerárquicos
    this.renderInventario();
    this.showToast('✓ Filtros jerárquicos eliminados', 'success');
  }

  // 🗺️ ETAPA 5: Ver repuesto en mapa
  // 🆕 NUEVA FUNCIÓN: Agregar ubicación en mapa (siempre abre modal para nueva ubicación)
  async agregarUbicacionMapa(id) {
    console.log('📍 Agregar nueva ubicación en mapa:', id);
    
    // 🔌 Verificar conexión y conectar si es necesario
    if (!fsManager.isConnected) {
      this.showToast('⚠️ Conectando al sistema de archivos...', 'info');
      const connected = await app.connectWorkspace(false, true);
      
      if (!connected) {
        this.showToast('❌ No se pudo conectar al sistema de archivos', 'error');
        this.switchTab('configuracion');
        return;
      }
    }
    
    if (!mapStorage.initialized) {
      this.showToast('❌ Error: Sistema de mapas no inicializado', 'error');
      return;
    }
    
    const repuesto = this.repuestos.find(r => String(r.id) === String(id));
    
    if (!repuesto) {
      this.showToast('❌ Repuesto no encontrado', 'error');
      return;
    }
    
    // Siempre abrir modal para agregar nueva ubicación
    this.abrirModalAsignarAreaMapa(id, repuesto);
  }

  async verRepuestoEnMapa(id) {
    console.log('🗺️ Ver repuesto en mapa:', id);
    
    // 🔌 Verificar conexión y conectar si es necesario (USANDO MÉTODO CENTRALIZADO)
    if (!fsManager.isConnected) {
      this.showToast('⚠️ Conectando al sistema de archivos...', 'info');
      const connected = await app.connectWorkspace(false, true); // Pedir al usuario seleccionar carpeta
      
      if (!connected) {
        this.showToast('❌ No se pudo conectar al sistema de archivos', 'error');
        this.switchTab('configuracion');
        return;
      }
    }
    
    // mapStorage ya debería estar inicializado por connectWorkspace
    if (!mapStorage.initialized) {
      this.showToast('❌ Error: Sistema de mapas no inicializado', 'error');
      return;
    }
    
    // Buscar el repuesto
    const repuesto = this.repuestos.find(r => String(r.id) === String(id));
    
    if (!repuesto) {
      this.showToast('❌ Repuesto no encontrado', 'error');
      return;
    }
    
    // Obtener todas las ubicaciones
    let ubicaciones = [];
    
    if (repuesto.ubicaciones && Array.isArray(repuesto.ubicaciones) && repuesto.ubicaciones.length > 0) {
      ubicaciones = repuesto.ubicaciones.filter(ub => ub.mapId && ub.areaId);
      
      // 🔧 LIMPIEZA: Si hay formato nuevo, eliminar propiedades antiguas para evitar duplicados
      if (repuesto.mapId || repuesto.markerX || repuesto.markerY) {
        console.log(`🧹 Limpiando formato antiguo de "${repuesto.nombre}" (ya tiene ubicaciones[])`);
        delete repuesto.mapId;
        delete repuesto.areaId;
        delete repuesto.markerX;
        delete repuesto.markerY;
        delete repuesto.ubicacionDescripcion;
        // Guardar cambio para persistir la limpieza
        this.saveData().catch(err => console.error('Error guardando limpieza:', err));
      }
    } else if (repuesto.mapId && repuesto.areaId) {
      // Formato antiguo - convertir a array
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    console.log('📍 Ubicaciones encontradas:', ubicaciones.length);
    
    // 🆕 Si NO tiene ubicaciones, informar al usuario
    if (ubicaciones.length === 0) {
      this.showToast('📍 Este repuesto no tiene ubicaciones. Usa "📍 Añadir Ubicación" para agregarlo al mapa.', 'info', 4000);
      return;
    }
    
    // 🆕 SIEMPRE mostrar modal, incluso con 1 ubicación (para consistencia y opciones)
    this.mostrarModalSeleccionUbicacion(repuesto, ubicaciones);
  }

  // 🆕 NUEVA FUNCIÓN: Modal para seleccionar entre múltiples ubicaciones
  mostrarModalSeleccionUbicacion(repuesto, ubicaciones) {
    console.log('🗺️ Mostrar modal de selección de ubicación');
    console.log(`   Repuesto: ${repuesto.nombre}`);
    console.log(`   Ubicaciones recibidas: ${ubicaciones.length}`);
    
    // 🔧 FIX BUG 1: Eliminar TODOS los modales existentes antes de crear uno nuevo
    const modalesExistentes = document.querySelectorAll('#modalSeleccionUbicacion');
    if (modalesExistentes.length > 0) {
      console.log(`   🧹 Limpiando ${modalesExistentes.length} modal(es) antiguo(s)...`);
      modalesExistentes.forEach(modal => modal.remove());
    }
    
    // Crear HTML de las ubicaciones con checkbox
    let ubicacionesHTML = '';
    ubicaciones.forEach((ub, index) => {
      const mapa = mapStorage.maps.find(m => m.id === ub.mapId);
      const area = mapStorage.areas.find(a => a.id === ub.areaId);
      
      const mapaNombre = mapa ? mapa.name : 'Mapa desconocido';
      const areaNombre = area ? area.name : 'Área desconocida';
      const icono = area && mapController?.categories?.[area.category]?.icon || '📍';
      const descripcion = ub.descripcion || '';
      
      ubicacionesHTML += `
        <div style="
          padding: 16px;
          background: var(--bg-secondary);
          border: 2px solid var(--border-color);
          border-radius: 12px;
          margin-bottom: 12px;
          transition: all 0.3s ease;
          box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        " 
        class="ubicacion-item" 
        data-index="${index}"
        onmouseenter="this.style.borderColor='var(--primary)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
        onmouseleave="this.style.borderColor='var(--border-color)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.05)';">
          
          <div style="display: flex; align-items: start; gap: 14px;">
            <!-- Checkbox -->
            <input type="checkbox" 
                   id="ubicacion-check-${index}" 
                   class="ubicacion-checkbox"
                   style="
                     margin-top: 6px; 
                     width: 20px; 
                     height: 20px; 
                     cursor: pointer;
                     accent-color: var(--primary);
                   "
                   onchange="app.toggleUbicacionSeleccion(${index})">
            
            <!-- Contenido principal -->
            <div style="flex: 1;">
              <!-- Encabezado con ícono y nombre -->
              <div style="
                display: flex; 
                align-items: center; 
                gap: 8px;
                font-weight: 700; 
                font-size: 1.05rem;
                margin-bottom: 8px;
                color: var(--text-primary);
              ">
                <span style="font-size: 1.4rem;">${icono}</span>
                <span>${areaNombre}</span>
              </div>
              
              <!-- Nombre del mapa -->
              <div style="
                font-size: 0.9rem; 
                color: var(--text-secondary); 
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 6px;
              ">
                <span style="opacity: 0.7;">🗺️</span>
                <span>${mapaNombre}</span>
              </div>
              
              <!-- Descripción -->
              ${descripcion ? `
                <div style="
                  font-size: 0.9rem; 
                  color: var(--text-primary);
                  background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
                  padding: 10px 14px;
                  border-radius: 8px;
                  margin: 10px 0;
                  border-left: 4px solid var(--primary);
                  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
                  line-height: 1.5;
                ">
                  <div style="font-weight: 600; font-size: 0.75rem; color: var(--primary); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">
                    💬 Descripción
                  </div>
                  ${descripcion}
                </div>
              ` : `
                <div style="
                  font-size: 0.85rem; 
                  color: var(--text-muted);
                  font-style: italic;
                  margin: 8px 0;
                  padding: 8px;
                  background: var(--bg-tertiary);
                  border-radius: 6px;
                  text-align: center;
                ">
                  Sin descripción personalizada
                </div>
              `}
              
              <!-- Coordenadas -->
              ${ub.markerX && ub.markerY ? `
                <div style="
                  font-size: 0.8rem; 
                  color: var(--text-muted); 
                  margin-top: 8px;
                  font-family: 'Courier New', monospace;
                  background: var(--bg-tertiary);
                  display: inline-block;
                  padding: 4px 10px;
                  border-radius: 4px;
                ">
                  📍 (${Math.round(ub.markerX)}, ${Math.round(ub.markerY)})
                </div>
              ` : ''}
              
              <!-- Botones de acción -->
              <div style="
                display: grid; 
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 8px; 
                margin-top: 14px;
              ">
                <button onclick="app.verUbicacionIndividual('${repuesto.id}', ${index})" style="
                  padding: 10px 14px;
                  background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
                  color: white;
                  border: none;
                  border-radius: 8px;
                  font-size: 0.85rem;
                  cursor: pointer;
                  font-weight: 600;
                  transition: all 0.2s ease;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                "
                onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                  🗺️ Ver en Mapa
                </button>
                
                <button onclick="app.editarDescripcionUbicacion('${repuesto.id}', ${index})" style="
                  padding: 10px 14px;
                  background: linear-gradient(135deg, var(--info) 0%, #117a8b 100%);
                  color: white;
                  border: none;
                  border-radius: 8px;
                  font-size: 0.85rem;
                  cursor: pointer;
                  font-weight: 600;
                  transition: all 0.2s ease;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                "
                onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                  ✏️ Editar Nota
                </button>
                
                <button onclick="app.editarUbicacionRepuesto('${repuesto.id}', ${index})" style="
                  padding: 10px 14px;
                  background: linear-gradient(135deg, var(--warning) 0%, #d39e00 100%);
                  color: white;
                  border: none;
                  border-radius: 8px;
                  font-size: 0.85rem;
                  cursor: pointer;
                  font-weight: 600;
                  transition: all 0.2s ease;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                "
                onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                  🎯 Mover Pin
                </button>
                
                <button onclick="app.eliminarUbicacionRepuesto('${repuesto.id}', ${index})" style="
                  padding: 10px 14px;
                  background: linear-gradient(135deg, var(--danger) 0%, #bd2130 100%);
                  color: white;
                  border: none;
                  border-radius: 8px;
                  font-size: 0.85rem;
                  cursor: pointer;
                  font-weight: 600;
                  transition: all 0.2s ease;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                "
                onmouseenter="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';"
                onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)';">
                  🗑️ Eliminar
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    });
    
    const modalHTML = `
      <div class="modal active" id="modalSeleccionUbicacion" style="z-index: 10000;">
        <div class="modal-content" style="max-width: 700px;">
          <button class="modal-close" onclick="document.getElementById('modalSeleccionUbicacion').remove()">×</button>
          
          <!-- Título del modal -->
          <div class="modal-title" style="
            background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
            color: white;
            padding: 20px 24px;
            margin: -20px -24px 20px;
            border-radius: 12px 12px 0 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
          ">
            <div style="font-size: 1.4rem; font-weight: 700; margin-bottom: 6px;">
              🗺️ Ubicaciones del Repuesto
            </div>
            <div style="font-size: 1.1rem; opacity: 0.95;">
              ${repuesto.nombre}
            </div>
          </div>
          
          <div style="padding: 0 24px 24px;">
            <!-- Contador de ubicaciones -->
            <div style="
              margin-bottom: 20px; 
              padding: 14px 18px;
              background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
              border-radius: 10px;
              border-left: 4px solid var(--accent);
              box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            ">
              <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.8rem;">📍</span>
                <div>
                  <div style="font-weight: 600; font-size: 1.05rem;">
                    ${ubicaciones.length} ${ubicaciones.length === 1 ? 'Ubicación' : 'Ubicaciones'} Registradas
                  </div>
                  <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 2px;">
                    Selecciona una o varias ubicaciones para visualizar
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Lista de ubicaciones -->
            <div style="max-height: 450px; overflow-y: auto; margin-bottom: 20px; padding-right: 8px;">
              ${ubicacionesHTML}
            </div>
            
            <!-- Botones principales -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
              <button onclick="app.verTodasLasUbicaciones('${repuesto.id}')" class="btn btn-primary" style="
                padding: 14px 20px;
                background: linear-gradient(135deg, var(--primary) 0%, #0056b3 100%);
                color: white;
                border: none;
                border-radius: 10px;
                font-size: 1rem;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 8px rgba(0,0,0,0.15);
              "
              onmouseenter="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';"
              onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';">
                🗺️ Ver Todas en Mapa
              </button>
              
              <button id="btnVerSeleccionadas" onclick="app.verUbicacionesSeleccionadas('${repuesto.id}')" class="btn btn-accent" style="
                padding: 14px 20px;
                background: linear-gradient(135deg, var(--accent) 0%, #218838 100%);
                color: white;
                border: none;
                border-radius: 10px;
                font-size: 1rem;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                opacity: 0.5;
              "
              disabled
              onmouseenter="if(!this.disabled) { this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)'; }"
              onmouseleave="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.15)';">
                ✓ Ver Seleccionadas (<span id="countSeleccionadas">0</span>)
              </button>
            </div>
            
            <!-- Botón cerrar -->
            <button onclick="document.getElementById('modalSeleccionUbicacion').remove()" class="btn btn-secondary" style="
              width: 100%; 
              padding: 12px;
              background: var(--bg-tertiary);
              color: var(--text-primary);
              border: 2px solid var(--border-color);
              border-radius: 8px;
              font-size: 0.95rem;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s ease;
            "
            onmouseenter="this.style.background='var(--bg-secondary)'; this.style.borderColor='var(--text-muted)';"
            onmouseleave="this.style.background='var(--bg-tertiary)'; this.style.borderColor='var(--border-color)';">
              Cerrar
            </button>
          </div>
        </div>
      </div>
    `;
    
    const modalAnterior = document.getElementById('modalSeleccionUbicacion');
    if (modalAnterior) modalAnterior.remove();
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Inicializar estado de selección
    window._ubicacionesSeleccionadas = new Set();
  }

  // 🆕 NUEVA FUNCIÓN: Toggle selección de ubicación con checkbox
  toggleUbicacionSeleccion(indice) {
    if (!window._ubicacionesSeleccionadas) {
      window._ubicacionesSeleccionadas = new Set();
    }
    
    const checkbox = document.getElementById(`ubicacion-check-${indice}`);
    
    if (checkbox.checked) {
      window._ubicacionesSeleccionadas.add(indice);
    } else {
      window._ubicacionesSeleccionadas.delete(indice);
    }
    
    // Actualizar contador y estado del botón
    const count = window._ubicacionesSeleccionadas.size;
    const countSpan = document.getElementById('countSeleccionadas');
    const btnSeleccionadas = document.getElementById('btnVerSeleccionadas');
    
    if (countSpan) countSpan.textContent = count;
    if (btnSeleccionadas) {
      btnSeleccionadas.disabled = count === 0;
      // Cambiar opacidad según estado
      btnSeleccionadas.style.opacity = count === 0 ? '0.5' : '1';
      btnSeleccionadas.style.cursor = count === 0 ? 'not-allowed' : 'pointer';
    }
  }

  // 🆕 NUEVA FUNCIÓN: Ver una ubicación individual en el mapa
  verUbicacionIndividual(repuestoId, indice) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    const ubicacion = ubicaciones[indice];
    if (!ubicacion) return;
    
    // Cerrar modal
    const modal = document.getElementById('modalSeleccionUbicacion');
    if (modal) modal.remove();
    
    // 🔧 FIX BUG 2: Llamar directamente a moverMarcador para activar el pin naranja + modal flotante
    console.log('🗺️ Ver en Mapa → Activando moverMarcador para activar modo edición');
    
    // Cambiar a tab de mapa primero
    this.switchTab('mapa');
    
    // Esperar a que el tab se active y luego llamar a moverMarcador
    setTimeout(() => {
      if (typeof mapController !== 'undefined' && mapController.moverMarcador) {
        mapController.moverMarcador(repuestoId, indice);
      } else {
        console.error('❌ mapController.moverMarcador no disponible');
        this.showToast('❌ Sistema de mapas no disponible', 'error');
      }
    }, 300);
  }

  // 🆕 NUEVA FUNCIÓN: Ver todas las ubicaciones en el mapa
  verTodasLasUbicaciones(repuestoId) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    // Cerrar modal
    const modal = document.getElementById('modalSeleccionUbicacion');
    if (modal) modal.remove();
    
    // Cambiar a tab de mapa
    this.switchTab('mapa');
    
    // Resaltar todas las ubicaciones
    this.showToast(`🗺️ Mostrando ${ubicaciones.length} ubicaciones de "${repuesto.nombre}"`, 'info');
    
    setTimeout(() => {
      if (mapController && mapController.mostrarMultiplesUbicaciones) {
        mapController.mostrarMultiplesUbicaciones(ubicaciones, repuesto);
      }
    }, 300);
  }

  // 🆕 NUEVA FUNCIÓN: Ver ubicaciones seleccionadas
  verUbicacionesSeleccionadas(repuestoId) {
    if (!window._ubicacionesSeleccionadas || window._ubicacionesSeleccionadas.size === 0) {
      this.showToast('⚠️ Selecciona al menos una ubicación', 'warning');
      return;
    }
    
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let todasUbicaciones = repuesto.ubicaciones || [];
    if (todasUbicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      todasUbicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    // Filtrar solo las seleccionadas
    const ubicacionesSeleccionadas = Array.from(window._ubicacionesSeleccionadas)
      .map(index => todasUbicaciones[index])
      .filter(ub => ub);
    
    // Cerrar modal
    const modal = document.getElementById('modalSeleccionUbicacion');
    if (modal) modal.remove();
    
    // Cambiar a tab de mapa
    this.switchTab('mapa');
    
    this.showToast(`🗺️ Mostrando ${ubicacionesSeleccionadas.length} ubicaciones seleccionadas`, 'info');
    
    setTimeout(() => {
      if (mapController && mapController.mostrarMultiplesUbicaciones) {
        mapController.mostrarMultiplesUbicaciones(ubicacionesSeleccionadas, repuesto);
      }
    }, 300);
  }

  // 🆕 NUEVA FUNCIÓN: Editar descripción de ubicación
  async editarDescripcionUbicacion(repuestoId, indice) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion || ''
      }];
      repuesto.ubicaciones = ubicaciones;
      delete repuesto.mapId;
      delete repuesto.areaId;
      delete repuesto.markerX;
      delete repuesto.markerY;
      delete repuesto.ubicacionDescripcion;
    }
    
    const ubicacion = ubicaciones[indice];
    if (!ubicacion) return;
    
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'ubicación';
    
    const descripcionActual = ubicacion.descripcion || '';
    const nuevaDescripcion = prompt(
      `Descripción para "${areaNombre}":\n\nEjemplo: "Al lado de la máquina BAADER 200, tercer estante"`,
      descripcionActual
    );
    
    if (nuevaDescripcion === null) return; // Usuario canceló
    
    // Actualizar descripción
    ubicacion.descripcion = nuevaDescripcion.trim();
    
    try {
      await this.saveData();
      this.showToast('✅ Descripción actualizada', 'success');
      
      // 🆕 Refrescar modal de ubicaciones
      this.refrescarModalUbicaciones(repuestoId);
    } catch (error) {
      console.error('Error guardando descripción:', error);
      this.showToast('❌ Error al guardar', 'error');
    }
  }
  
  // 🆕 NUEVA FUNCIÓN: Refrescar modal de ubicaciones después de cambios
  refrescarModalUbicaciones(repuestoId) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY,
        descripcion: repuesto.ubicacionDescripcion
      }];
    }
    
    // 🔧 FIX BUG 1: Eliminar TODOS los modales duplicados antes de recrear
    console.log('🔄 Refrescando modal de ubicaciones...');
    const modalesAntiguos = document.querySelectorAll('#modalSeleccionUbicacion');
    modalesAntiguos.forEach((modal, index) => {
      console.log(`  🗑️ Eliminando modal duplicado ${index + 1}/${modalesAntiguos.length}`);
      modal.remove();
    });
    
    // Si ya no hay ubicaciones, solo cerrar
    if (ubicaciones.length === 0) {
      this.showToast('ℹ️ El repuesto ya no tiene ubicaciones', 'info');
      return;
    }
    
    // Reabrir con datos actualizados (esperar para asegurar limpieza del DOM)
    setTimeout(() => {
      console.log(`  ✅ Recreando modal con ${ubicaciones.length} ubicación(es)`);
      this.mostrarModalSeleccionUbicacion(repuesto, ubicaciones);
    }, 150);
  }

  // 🆕 NUEVA FUNCIÓN: Seleccionar y mostrar una ubicación específica
  seleccionarYMostrarUbicacion(repuestoId, indice) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY
      }];
    }
    
    const ubicacion = ubicaciones[indice];
    if (!ubicacion) return;
    
    // Cerrar modal
    const modal = document.getElementById('modalSeleccionUbicacion');
    if (modal) modal.remove();
    
    // Mostrar en mapa
    this.mostrarRepuestoEnMapa(ubicacion, repuesto);
  }

  // 🆕 NUEVA FUNCIÓN: Editar ubicación de repuesto
  async editarUbicacionRepuesto(repuestoId, indice) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY
      }];
      // Convertir formato antiguo a nuevo
      repuesto.ubicaciones = ubicaciones;
      delete repuesto.mapId;
      delete repuesto.areaId;
      delete repuesto.markerX;
      delete repuesto.markerY;
    }
    
    const ubicacion = ubicaciones[indice];
    if (!ubicacion) return;
    
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'el área';
    
    // Cerrar modal de selección
    const modalSeleccion = document.getElementById('modalSeleccionUbicacion');
    if (modalSeleccion) modalSeleccion.remove();
    
    // Guardar índice para actualizar la ubicación correcta
    if (!window._editandoUbicacion) window._editandoUbicacion = {};
    window._editandoUbicacion.repuestoId = repuestoId;
    window._editandoUbicacion.indice = indice;
    window._editandoUbicacion.modoEdicion = true;
    
    // Cambiar a tab de mapa
    this.switchTab('mapa');
    this.showToast(`✏️ Editando ubicación... Cargando mapa`, 'info');
    
    // Cargar mapa y activar modo edición
    setTimeout(() => {
      if (mapController && mapController.loadMap) {
        mapController.loadMap(ubicacion.mapId);
      }
      
      setTimeout(() => {
        // Hacer zoom al área
        if (mapController && mapController.zoomToArea) {
          mapController.zoomToArea(ubicacion.areaId);
        }
        
        // Resaltar área
        setTimeout(() => {
          if (mapController && mapController.flashArea) {
            mapController.flashArea(ubicacion.areaId, 3);
          } else if (mapController && mapController.highlightArea) {
            mapController.highlightArea(ubicacion.areaId);
          }
          
          // Activar modo marcador para reubicar
          if (mapController && mapController.activarModoMarcador) {
            mapController.activarModoMarcador(repuestoId, ubicacion.mapId, ubicacion.areaId, true); // true = modo edición
          }
          
          setTimeout(() => {
            this.showToast(`✏️ Haz click en "${areaNombre}" para cambiar la posición del marcador`, 'info', 6000);
          }, 1000);
        }, 600);
      }, 500);
    }, 300);
  }

  // 🆕 NUEVA FUNCIÓN: Eliminar ubicación de repuesto
  async eliminarUbicacionRepuesto(repuestoId, indice) {
    const repuesto = this.repuestos.find(r => String(r.id) === String(repuestoId));
    if (!repuesto) return;
    
    let ubicaciones = repuesto.ubicaciones || [];
    if (ubicaciones.length === 0 && repuesto.mapId && repuesto.areaId) {
      ubicaciones = [{
        mapId: repuesto.mapId,
        areaId: repuesto.areaId,
        markerX: repuesto.markerX,
        markerY: repuesto.markerY
      }];
      repuesto.ubicaciones = ubicaciones;
      delete repuesto.mapId;
      delete repuesto.areaId;
      delete repuesto.markerX;
      delete repuesto.markerY;
    }
    
    if (indice < 0 || indice >= ubicaciones.length) return;
    
    const ubicacion = ubicaciones[indice];
    const area = mapStorage.areas.find(a => a.id === ubicacion.areaId);
    const areaNombre = area ? area.name : 'desconocida';
    
    const confirmacion = confirm(`¿Eliminar la ubicación en "${areaNombre}"?\n\nEsta acción no se puede deshacer.`);
    
    if (!confirmacion) return;
    
    // Eliminar ubicación del array
    ubicaciones.splice(indice, 1);
    
    // Si ya no quedan ubicaciones, eliminar el array
    if (ubicaciones.length === 0) {
      delete repuesto.ubicaciones;
    }
    
    // Guardar cambios
    try {
      await this.saveData();
      this.showToast(`✅ Ubicación eliminada de "${repuesto.nombre}"`, 'success');
      
      // 🆕 Refrescar modal de ubicaciones (o cerrar si ya no hay ubicaciones)
      this.refrescarModalUbicaciones(repuestoId);
      
      // Re-renderizar mapa para reflejar cambios
      if (mapController && mapController.draw) {
        mapController.draw();
      }
    } catch (error) {
      console.error('Error eliminando ubicación:', error);
      this.showToast('❌ Error al eliminar ubicación', 'error');
    }
  }

  // 🆕 NUEVA FUNCIÓN: Mostrar repuesto en mapa (cuando ya tiene ubicación)
  mostrarRepuestoEnMapa(ubicacionConMapa, repuesto) {
    // Cambiar al tab de mapa
    this.switchTab('mapa');
    
    // Esperar a que el tab de mapa se active
    setTimeout(() => {
      // Verificar si mapController está disponible
      if (typeof mapController === 'undefined' || !mapController) {
        this.showToast('❌ Sistema de mapas no disponible', 'error');
        return;
      }
      
      // Cargar el mapa correspondiente
      if (mapController.loadMap) {
        mapController.loadMap(ubicacionConMapa.mapId);
      }
      
      // Esperar a que se cargue el mapa y luego resaltar el área
      setTimeout(() => {
        // Resaltar el área
        if (mapController.highlightArea) {
          mapController.highlightArea(ubicacionConMapa.areaId);
        }
        
        // Hacer zoom al área
        if (mapController.zoomToArea) {
          mapController.zoomToArea(ubicacionConMapa.areaId);
        }
        
        // Animación de pulsación
        if (mapController.pulseArea) {
          mapController.pulseArea(ubicacionConMapa.areaId);
        }
        
        // 🆕 Si tiene marcador específico, mostrarlo
        if (ubicacionConMapa.markerX && ubicacionConMapa.markerY && mapController.showMarker) {
          mapController.showMarker(ubicacionConMapa.markerX, ubicacionConMapa.markerY, repuesto.nombre);
        }
        
        this.showToast(`🗺️ Ubicación de "${repuesto.nombre}" mostrada en el mapa`, 'success');
      }, 500);
    }, 300);
  }

  // 🆕 NUEVA FUNCIÓN: Modal para asignar área en mapa
  abrirModalAsignarAreaMapa(repuestoId, repuesto) {
    console.log('🗺️ Abrir modal de asignación de área para:', repuesto.nombre);
    
    // Verificar si hay mapas disponibles
    if (typeof mapStorage === 'undefined' || !mapStorage) {
      this.showToast('❌ Sistema de mapas no disponible', 'error');
      return;
    }
    
    const mapas = mapStorage.maps || [];
    if (!mapas || mapas.length === 0) {
      this.showToast('⚠️ No hay mapas creados. Crea un mapa primero en la pestaña "MAPA"', 'warning');
      return;
    }
    
    // Obtener todas las áreas
    const todasLasAreas = mapStorage.areas || [];
    
    if (!todasLasAreas || todasLasAreas.length === 0) {
      this.showToast('⚠️ No hay áreas creadas en los mapas. Dibuja áreas primero en la pestaña "MAPA"', 'warning');
      return;
    }
    
    // Agrupar áreas por mapa
    const areasPorMapa = {};
    todasLasAreas.forEach(area => {
      if (!areasPorMapa[area.mapId]) {
        const mapa = mapas.find(m => m.id === area.mapId);
        areasPorMapa[area.mapId] = {
          mapa: mapa,
          areas: []
        };
      }
      areasPorMapa[area.mapId].areas.push(area);
    });
    
    let opcionesHTML = '';
    Object.values(areasPorMapa).forEach(grupo => {
      opcionesHTML += `<optgroup label="🗺️ ${grupo.mapa.name}">`;
      grupo.areas.forEach(area => {
        const icono = mapController && mapController.categories && mapController.categories[area.category] 
          ? mapController.categories[area.category].icon 
          : '📍';
        opcionesHTML += `<option value="${area.mapId}|${area.id}">${icono} ${area.name}</option>`;
      });
      opcionesHTML += `</optgroup>`;
    });
    
    // Crear modal personalizado
    const modalHTML = `
      <div class="modal active" id="modalAsignarArea" style="z-index: 10000;">
        <div class="modal-content" style="max-width: 600px;">
          <button class="modal-close" onclick="document.getElementById('modalAsignarArea').remove()">×</button>
          <div class="modal-title">📍 Asignar ubicación en mapa: ${repuesto.nombre}</div>
          
          <div style="padding: 20px;">
            <p style="margin-bottom: 20px; color: var(--text-secondary); line-height: 1.6;">
              Selecciona el área donde se encuentra <strong>"${repuesto.nombre}"</strong>. 
              Luego podrás colocar un marcador en el lugar exacto dentro del área.
            </p>
            
            <div class="form-group">
              <label style="font-weight: 600; margin-bottom: 8px; display: block;">Área del mapa:</label>
              <select id="areaMapaSelect" style="
                width: 100%;
                padding: 12px;
                font-size: 1rem;
                border: 2px solid var(--border);
                border-radius: 8px;
                background: var(--surface);
                color: var(--text);
              ">
                <option value="">-- Selecciona un área --</option>
                ${opcionesHTML}
              </select>
            </div>
            
            <div style="display: flex; gap: 12px; margin-top: 24px;">
              <button onclick="document.getElementById('modalAsignarArea').remove()" class="btn btn-secondary" style="flex: 1;">
                Cancelar
              </button>
              <button onclick="app.confirmarAsignacionArea('${repuestoId}')" class="btn btn-primary" style="flex: 1;">
                Siguiente: Colocar Marcador →
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // Remover modal anterior si existe
    const modalAnterior = document.getElementById('modalAsignarArea');
    if (modalAnterior) modalAnterior.remove();
    
    // Agregar nuevo modal al body
    document.body.insertAdjacentHTML('beforeend', modalHTML);
  }

  // 🆕 NUEVA FUNCIÓN: Confirmar área y pasar a colocar marcador
  async confirmarAsignacionArea(repuestoId) {
    const select = document.getElementById('areaMapaSelect');
    const valor = select.value;
    
    if (!valor) {
      this.showToast('⚠️ Selecciona un área', 'warning');
      return;
    }
    
    const [mapId, areaId] = valor.split('|').map(v => parseInt(v));
    
    // Obtener nombre del área para el mensaje
    const area = mapStorage.areas.find(a => a.id === areaId);
    const areaName = area ? area.name : 'el área seleccionada';
    
    // Cerrar modal personalizado
    const modalAsignar = document.getElementById('modalAsignarArea');
    if (modalAsignar) modalAsignar.remove();
    
    // Cambiar al tab de mapa
    this.switchTab('mapa');
    
    // Mostrar mensaje instructivo
    this.showToast(`🎯 Cargando mapa... Haz click DENTRO de "${areaName}" para marcar la ubicación`, 'info', 6000);
    
    // Esperar y cargar el mapa
    setTimeout(() => {
      if (mapController && mapController.loadMap) {
        mapController.loadMap(mapId);
      }
      
      setTimeout(() => {
        // Hacer zoom PRIMERO (para que se vea bien el área)
        if (mapController && mapController.zoomToArea) {
          mapController.zoomToArea(areaId);
        }
        
        // Después de hacer zoom, hacer parpadear el área para que sea MUY visible
        setTimeout(() => {
          if (mapController && mapController.flashArea) {
            mapController.flashArea(areaId, 3); // Parpadear 3 veces
          } else if (mapController && mapController.highlightArea) {
            mapController.highlightArea(areaId);
          }
          
          // Activar modo de colocación de marcador
          if (mapController && mapController.activarModoMarcador) {
            mapController.activarModoMarcador(repuestoId, mapId, areaId);
          }
          
          // Mensaje final claro
          setTimeout(() => {
            this.showToast(`� Haz click DENTRO del área "${areaName}" (resaltada) para colocar el marcador`, 'info', 8000);
          }, 1500);
        }, 600);
      }, 500);
    }, 300);
  }

  selectTool(tool) {
    this.mapTool = tool;
    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
    document.querySelector(`[data-tool="${tool}"]`)?.classList.add('active');
  }

  loadMapImage(event) {
    const file = event.target.files[0];
    if (!file) {
      console.log('No se seleccionó archivo');
      return;
    }
    
    console.log('Cargando imagen de mapa:', file.name, file.size);
    this.showToast('📤 Cargando imagen...', 'info');
    
    const reader = new FileReader();
    reader.onerror = (e) => {
      console.error('Error leyendo archivo:', e);
      this.showToast('❌ Error al leer archivo', 'error');
    };
    reader.onload = (e) => {
      try {
        this.mapImage = e.target.result;
        localStorage.setItem('mapImage', this.mapImage);
        console.log('Imagen guardada, tamaño:', this.mapImage.length);
        this.renderMap();
        this.showToast('✅ Imagen de mapa cargada', 'success');
      } catch (error) {
        console.error('Error guardando imagen:', error);
        this.showToast('❌ Error al guardar imagen', 'error');
      }
    };
    reader.readAsDataURL(file);
    
    // Limpiar el input para permitir recargar la misma imagen
    event.target.value = '';
  }

  handleMapClick(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // 🎯 PRIORIDAD: Si estamos en modo marcador, colocar el marcador
    if (mapController && mapController.state && mapController.state.modoMarcador) {
      // Convertir coordenadas de pantalla a coordenadas del mapa
      const mapX = (x - mapController.state.offsetX) / mapController.state.scale;
      const mapY = (y - mapController.state.offsetY) / mapController.state.scale;
      mapController.colocarMarcador(mapX, mapY);
      return;
    }

    if (this.mapTool === 'rect') {
      const name = prompt('Nombre del área:');
      if (name) {
        this.mapObjects.push({ type: 'rect', x, y, w: 150, h: 100, name });
        this.renderMap();
        this.saveMap();
      }
    } else if (this.mapTool === 'circle') {
      const name = prompt('Nombre del área:');
      if (name) {
        this.mapObjects.push({ type: 'circle', x, y, r: 60, name });
        this.renderMap();
        this.saveMap();
      }
    } else if (this.mapTool === 'machine') {
      const name = prompt('Nombre de la máquina:');
      if (name) {
        this.mapObjects.push({ type: 'machine', x, y, name });
        this.renderMap();
        this.saveMap();
      }
    }
  }

  renderMap() {
    if (!this.ctx) {
      setTimeout(() => this.setupCanvas(), 100);
      return;
    }
    
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Fondo del canvas
    this.ctx.fillStyle = '#0f172a';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    if (this.mapImage) {
      const img = new Image();
      img.onerror = () => {
        console.error('Error al cargar imagen del mapa');
        this.showToast('❌ Error al cargar imagen', 'error');
        this.drawMapObjects();
      };
      img.onload = () => {
        try {
          // Calcular proporción para mantener aspecto
          const scale = Math.min(
            this.canvas.width / img.width,
            this.canvas.height / img.height
          );
          const x = (this.canvas.width - img.width * scale) / 2;
          const y = (this.canvas.height - img.height * scale) / 2;
          
          this.ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
          this.drawMapObjects();
        } catch (e) {
          console.error('Error dibujando imagen:', e);
          this.drawMapObjects();
        }
      };
      img.src = this.mapImage;
    } else {
      // Mostrar mensaje cuando no hay imagen
      this.ctx.fillStyle = '#94a3b8';
      this.ctx.font = '20px sans-serif';
      this.ctx.textAlign = 'center';
      this.ctx.fillText('Carga una imagen de fondo', this.canvas.width / 2, this.canvas.height / 2);
      this.drawMapObjects();
    }
  }

  drawMapObjects() {
    this.mapObjects.forEach(obj => {
      this.ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
      this.ctx.strokeStyle = '#6366f1';
      this.ctx.lineWidth = 3;

      if (obj.type === 'rect') {
        this.ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        this.ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
      } else if (obj.type === 'circle') {
        this.ctx.beginPath();
        this.ctx.arc(obj.x, obj.y, obj.r, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.stroke();
      } else if (obj.type === 'machine') {
        this.ctx.fillStyle = '#ef4444';
        this.ctx.fillRect(obj.x - 15, obj.y - 15, 30, 30);
      }

      this.ctx.fillStyle = '#1f2937';
      this.ctx.font = 'bold 14px sans-serif';
      this.ctx.fillText(obj.name, obj.x + 5, obj.y - 10);
    });
  }

  saveMap() {
    localStorage.setItem('mapData', JSON.stringify(this.mapObjects));
    this.showToast('Mapa guardado', 'success');
  }

  renderStats() {
    const total = this.repuestos.length;
    const sinStock = this.repuestos.filter(r => r.cantidad === 0).length;
    const bajoStock = this.repuestos.filter(r => r.cantidad > 0 && r.cantidad <= (r.minimo || r.stockMinimo || 5)).length;
    const stockOk = total - sinStock - bajoStock;
    const valorTotal = this.repuestos.reduce((sum, r) => sum + (r.precio * r.cantidad), 0);
    const valorPromedio = total > 0 ? valorTotal / total : 0;
    const conMultimedia = this.repuestos.filter(r => r.multimedia && r.multimedia.length > 0).length;
    const areas = new Set(this.repuestos.map(r => r.area)).size;
    const equipos = new Set(this.repuestos.map(r => r.equipo)).size;
    const tipos = new Set(this.repuestos.map(r => r.tipo).filter(t => t)).size;
    
    // Métricas de salud
    const saludStock = total > 0 ? ((stockOk / total) * 100).toFixed(1) : 0;
    const cobertura = conMultimedia > 0 ? ((conMultimedia / total) * 100).toFixed(1) : 0;
    const criticidad = sinStock + bajoStock;
    const nivelAlerta = criticidad > total * 0.3 ? 'ALTO' : criticidad > total * 0.15 ? 'MEDIO' : 'BAJO';
    const colorAlerta = criticidad > total * 0.3 ? 'var(--danger)' : criticidad > total * 0.15 ? 'var(--warning)' : 'var(--success)';

    document.getElementById('statsGrid').innerHTML = `
      <div class="stats-card" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; border: none;">
        <div class="stat-value">${total}</div>
        <div class="stat-label" style="color: rgba(255,255,255,0.9);">Total Repuestos</div>
      </div>
      <div class="stats-card" style="border-left-color: var(--danger);">
        <div class="stat-value" style="color: var(--danger);">${sinStock}</div>
        <div class="stat-label">Sin Stock</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">${(sinStock/total*100).toFixed(1)}% del total</div>
      </div>
      <div class="stats-card" style="border-left-color: var(--warning);">
        <div class="stat-value" style="color: var(--warning);">${bajoStock}</div>
        <div class="stat-label">Stock Bajo</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">${(bajoStock/total*100).toFixed(1)}% del total</div>
      </div>
      <div class="stats-card" style="border-left-color: var(--success);">
        <div class="stat-value" style="color: var(--success);">${stockOk}</div>
        <div class="stat-label">Stock OK</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--success);">${saludStock}% saludable</div>
      </div>
      <div class="stats-card" style="border-left-color: ${colorAlerta};">
        <div class="stat-value" style="color: ${colorAlerta};">${nivelAlerta}</div>
        <div class="stat-label">Nivel de Alerta</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">${criticidad} críticos</div>
      </div>
      <div class="stats-card" style="border-left-color: var(--success);">
        <div class="stat-value" style="color: var(--success);">$${valorTotal.toLocaleString('es-ES', {minimumFractionDigits: 2})}</div>
        <div class="stat-label">Valor Inventario</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">
           Ver pestaña "Valores" para desglose
        </div>
      </div>
      <div class="stats-card" style="border-left-color: var(--info);">
        <div class="stat-value" style="color: var(--info);">${cobertura}%</div>
        <div class="stat-label">Cobertura Multimedia</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">${conMultimedia} de ${total}</div>
      </div>
      <div class="stats-card">
        <div class="stat-value">${areas + equipos + tipos}</div>
        <div class="stat-label">Clasificaciones</div>
        <div style="margin-top: 8px; font-size: 0.8rem; color: var(--gray-500);">${areas} áreas, ${equipos} equipos, ${tipos} tipos</div>
      </div>
    `;

    // Detalle por áreas con gráfico de barras
    const areaStats = {};
    this.repuestos.forEach(r => {
      if (!areaStats[r.area]) areaStats[r.area] = { total: 0, valor: 0, sinStock: 0, bajoStock: 0, ok: 0 };
      areaStats[r.area].total++;
      areaStats[r.area].valor += r.precio * r.cantidad;
      const minimo = r.minimo || r.stockMinimo || 5;
      if (r.cantidad === 0) areaStats[r.area].sinStock++;
      else if (r.cantidad <= minimo) areaStats[r.area].bajoStock++;
      else areaStats[r.area].ok++;
    });

    const bgCard = '#1e293b';
    const borderCard = '#334155';
    const bgSection = '#0f172a';
    const textPrimary = '#60a5fa';
    const textSecondary = '#cbd5e1';
    const borderAccent = '#3b82f6';
    
    let detailsHtml = `<div style="background: ${bgCard}; border: 1px solid ${borderCard}; padding: 24px; border-radius: 12px; box-shadow: var(--card-shadow); margin-top: 20px;">`;
    detailsHtml += `<h3 style="margin-bottom: 20px; color: ${textPrimary}; display: flex; align-items: center; gap: 10px;"><span style="font-size: 1.5rem;">📊</span> Dashboard por Área</h3>`;
    detailsHtml += '<div style="display: grid; gap: 16px;">';

    Object.keys(areaStats).sort().forEach(area => {
      const stats = areaStats[area];
      const porcOk = (stats.ok / stats.total * 100).toFixed(0);
      const porcBajo = (stats.bajoStock / stats.total * 100).toFixed(0);
      const porcCero = (stats.sinStock / stats.total * 100).toFixed(0);
      
      detailsHtml += `
        <div style="padding: 20px; background: ${bgSection}; border-radius: 12px; border-left: 4px solid ${borderAccent}; border: 1px solid ${borderCard};">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div>
              <strong style="color: ${textPrimary}; font-size: 1.1rem;">${area}</strong>
              <div style="font-size: 0.85rem; color: ${textSecondary}; margin-top: 4px;">
                ${stats.total} repuestos | Valor: $${stats.valor.toLocaleString('es-ES', {minimumFractionDigits: 2})}
              </div>
            </div>
            <div style="text-align: right;">
              <div style="font-weight: 700; font-size: 1.2rem; color: ${textPrimary};">${porcOk}%</div>
              <div style="font-size: 0.75rem; color: ${textSecondary};">saludable</div>
            </div>
          </div>
          
          <div style="display: flex; gap: 2px; height: 12px; border-radius: 6px; overflow: hidden; margin-bottom: 8px;">
            <div style="flex: ${stats.ok}; background: var(--success);" title="Stock OK: ${stats.ok}"></div>
            <div style="flex: ${stats.bajoStock}; background: var(--warning);" title="Stock Bajo: ${stats.bajoStock}"></div>
            <div style="flex: ${stats.sinStock}; background: var(--danger);" title="Sin Stock: ${stats.sinStock}"></div>
          </div>
          
          <div style="display: flex; gap: 16px; font-size: 0.85rem;">
            <span style="color: var(--success);">${stats.ok} OK</span>
            <span style="color: var(--warning);">${stats.bajoStock} Bajo</span>
            <span style="color: var(--danger);">${stats.sinStock} Sin stock</span>
          </div>
        </div>
      `;
    });

    detailsHtml += '</div></div>';
    document.getElementById('statsDetails').innerHTML = detailsHtml;
  }

  exportJSON() {
    if (this.repuestos.length === 0) {
      this.showToast('⚠️ No hay datos para exportar', 'warning');
      return;
    }

    try {
      const data = {
        repuestos: this.repuestos,
        mapa: this.mapObjects,
        fecha: new Date().toISOString(),
        version: '2.0'
      };

      console.log('Exportando JSON con', this.repuestos.length, 'repuestos');
      
      const jsonString = JSON.stringify(data, null, 2);
      const sizeInMB = (jsonString.length / (1024 * 1024)).toFixed(2);
      
      console.log('Tamaño del archivo:', sizeInMB, 'MB');
      
      // Mostrar información sobre el tamaño
      if (parseFloat(sizeInMB) > 10) {
        this.showToast(`Exportando archivo grande (${sizeInMB}MB)...`, 'info');
      }
      
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inventario_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      setTimeout(() => URL.revokeObjectURL(url), 100);

      this.showToast(`JSON exportado (${sizeInMB}MB)`, 'success');
      console.log('Exportación completada:', sizeInMB, 'MB');
    } catch (error) {
      console.error('Error exportando JSON:', error);
      this.showToast('❌ Error al exportar: ' + error.message, 'error');
    }
  }

  exportJSONSinImagenes() {
    if (this.repuestos.length === 0) {
      this.showToast('⚠️ No hay datos para exportar', 'warning');
      return;
    }

    try {
      // Crear copia de repuestos SIN multimedia
      const repuestosSinImagenes = this.repuestos.map(r => ({
        id: r.id,
        codSAP: r.codSAP,
        codProv: r.codProv,
        tipo: r.tipo,
        nombre: r.nombre,
        area: r.area,
        equipo: r.equipo,
        cantidad: r.cantidad,
        minimo: r.minimo,
        precio: r.precio,
        multimedia: [] // Vacío - sin imágenes
      }));

      const data = {
        repuestos: repuestosSinImagenes,
        mapa: this.mapObjects,
        fecha: new Date().toISOString(),
        version: '2.0',
        nota: '⚠️ EXPORTACIÓN SIN IMÁGENES - Datos reducidos para navegador'
      };

      const jsonString = JSON.stringify(data, null, 2);
      const sizeInMB = (jsonString.length / (1024 * 1024)).toFixed(2);
      
      console.log('Exportando SIN imágenes:', sizeInMB, 'MB');
      
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inventario_SIN_IMAGENES_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      setTimeout(() => URL.revokeObjectURL(url), 100);

      this.showToast(`✅ JSON sin imágenes exportado (${sizeInMB}MB) - ${this.repuestos.length} repuestos`, 'success', 6000);
      console.log('✅ Exportación SIN imágenes completada:', sizeInMB, 'MB');
    } catch (error) {
      console.error('Error exportando JSON sin imágenes:', error);
      this.showToast('❌ Error al exportar: ' + error.message, 'error');
    }
  }

  importJSON(event) {
    const file = event.target.files[0];
    if (!file) {
      console.log('No se seleccionó archivo para importar');
      return;
    }

    console.log('Importando archivo:', file.name, file.size);
    
    const fileSizeInMB = (file.size / (1024 * 1024)).toFixed(2);
    
    // Advertencia informativa pero no bloqueante
    if (fileSizeInMB > 50) {
      if (!confirm(`Archivo muy grande (${fileSizeInMB}MB).\n\n⚠️ Esto podría tardar varios segundos.\n\n✅ El sistema soporta archivos grandes.\n\n¿Continuar con la importación?`)) {
        event.target.value = '';
        return;
      }
    } else if (fileSizeInMB > 10) {
      this.showToast(`Importando ${fileSizeInMB}MB - Puede tardar unos segundos...`, 'info');
    }

    this.showToast('📥 Importando datos...', 'info');
    
    const reader = new FileReader();
    reader.onerror = (e) => {
      console.error('Error leyendo archivo:', e);
      this.showToast('❌ Error al leer archivo', 'error');
      event.target.value = '';
    };
    reader.onload = (e) => {
      try {
        console.log('Parseando JSON...');
        const data = JSON.parse(e.target.result);
        
        let repuestosList = [];
        if (data.repuestos && Array.isArray(data.repuestos)) {
          repuestosList = data.repuestos;
          console.log('Formato: objeto con propiedad repuestos');
        } else if (Array.isArray(data)) {
          repuestosList = data;
          console.log('Formato: array directo');
        } else {
          console.error('Formato no reconocido:', typeof data);
          this.showToast('⚠️ Formato inválido', 'warning');
          event.target.value = '';
          return;
        }

        console.log('Repuestos encontrados:', repuestosList.length);

        if (!confirm(`¿Importar ${repuestosList.length} repuestos? Esto reemplazará los datos actuales.`)) {
          event.target.value = '';
          return;
        }

        this.repuestos = repuestosList.map((item, index) => {
          const repuesto = {
            id: item.id || `imported-${Date.now()}-${index}`,
            codSAP: item.codSAP || '',
            codProv: item.codProv || '',
            tipo: item.tipo || '',
            nombre: item.nombre || item.tipo || '',
            area: item.area || 'General',
            equipo: item.equipo || 'Sin equipo',
            cantidad: parseInt(item.cantidad) || 0,
            minimo: parseInt(item.minimo || item.stockMinimo) || 5,
            precio: parseFloat(item.precio) || 0,
            multimedia: item.multimedia || []
          };
          
          console.log(`✅ Item ${index + 1}: ${repuesto.nombre} (ID: ${repuesto.id}, Multimedia: ${repuesto.multimedia.length})`);
          return repuesto;
        });

        if (data.mapa && Array.isArray(data.mapa)) {
          this.mapObjects = data.mapa;
          localStorage.setItem('mapData', JSON.stringify(this.mapObjects));
          console.log('Objetos de mapa importados:', this.mapObjects.length);
        }

        console.log('Guardando datos...');
        this.saveData();
        this.updateAutocompleteData();
        this.render();
        this.renderFilters();
        
        console.log('Importación completada exitosamente');
        this.showToast(`✅ ${this.repuestos.length} repuestos importados`, 'success');
      } catch (error) {
        console.error('Error durante importación:', error);
        this.showToast('❌ Error al importar: ' + error.message, 'error');
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  }

  exportExcel() {
    if (this.repuestos.length === 0) {
      this.showToast('⚠️ No hay datos para exportar', 'warning');
      return;
    }

    try {
      console.log('Exportando Excel profesional con', this.repuestos.length, 'repuestos');
      
      // HOJA 1: INVENTARIO COMPLETO
      const inventarioData = this.repuestos.map(r => ({
        'Código SAP': r.codSAP || '',
        '🏷️ Código Proveedor': r.codProv || '',
        'Tipo': r.tipo || '',
        'Nombre': r.nombre || '',
        'Área': r.area || '',
        'Equipo': r.equipo || '',
        'Cantidad': r.cantidad || 0,
        '⚠️ Stock Mínimo': r.minimo || 5,
        'Precio Unitario': r.precio || 0,
        '💵 Valor Total': (r.precio || 0) * (r.cantidad || 0),
        '🚨 Estado': r.cantidad === 0 ? 'SIN STOCK' : 
                     r.cantidad <= (r.minimo || 5) ? 'STOCK BAJO' : 'OK',
        '🖼️ Multimedia': (r.multimedia || []).length,
        'Documentos': (r.multimedia || []).filter(m => m.type === 'document').length
      }));

      // HOJA 2: RESUMEN Y ESTADÍSTICAS
      const sinStock = this.repuestos.filter(r => r.cantidad === 0).length;
      const stockBajo = this.repuestos.filter(r => r.cantidad > 0 && r.cantidad <= (r.minimo || 5)).length;
      const stockOk = this.repuestos.length - sinStock - stockBajo;
      const valorTotal = this.repuestos.reduce((sum, r) => sum + ((r.precio || 0) * (r.cantidad || 0)), 0);
      
      const resumenData = [
        { 'Indicador': 'Total Repuestos', 'Valor': this.repuestos.length },
        { 'Indicador': '✅ Stock OK', 'Valor': stockOk },
        { 'Indicador': '⚠️ Stock Bajo', 'Valor': stockBajo },
        { 'Indicador': '🚨 Sin Stock', 'Valor': sinStock },
        { 'Indicador': '', 'Valor': '' },
        { 'Indicador': 'Valor Total Inventario', 'Valor': `$${valorTotal.toFixed(2)}` },
        { 'Indicador': 'Valor Promedio por Repuesto', 'Valor': `$${(valorTotal / this.repuestos.length).toFixed(2)}` },
        { 'Indicador': '', 'Valor': '' },
        { 'Indicador': '📅 Fecha de Exportación', 'Valor': new Date().toLocaleDateString('es-ES', { 
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', 
          hour: '2-digit', minute: '2-digit' 
        }) }
      ];

      // 🏢 HOJA 3: REPUESTOS POR ÁREA
      const areaStats = {};
      this.repuestos.forEach(r => {
        if (!areaStats[r.area]) {
          areaStats[r.area] = { cantidad: 0, valor: 0, sinStock: 0 };
        }
        areaStats[r.area].cantidad++;
        areaStats[r.area].valor += (r.precio || 0) * (r.cantidad || 0);
        if (r.cantidad === 0) areaStats[r.area].sinStock++;
      });
      
      const areaData = Object.entries(areaStats).map(([area, stats]) => ({
        'Área': area,
        'Total Repuestos': stats.cantidad,
        '🚨 Sin Stock': stats.sinStock,
        'Valor Total': `$${stats.valor.toFixed(2)}`
      }));

      // HOJA 4: REPUESTOS POR EQUIPO
      const equipoStats = {};
      this.repuestos.forEach(r => {
        if (!equipoStats[r.equipo]) {
          equipoStats[r.equipo] = { cantidad: 0, valor: 0, stockBajo: 0 };
        }
        equipoStats[r.equipo].cantidad++;
        equipoStats[r.equipo].valor += (r.precio || 0) * (r.cantidad || 0);
        if (r.cantidad <= (r.minimo || 5)) equipoStats[r.equipo].stockBajo++;
      });
      
      const equipoData = Object.entries(equipoStats).map(([equipo, stats]) => ({
        'Equipo': equipo,
        'Total Repuestos': stats.cantidad,
        '⚠️ Stock Bajo/Sin Stock': stats.stockBajo,
        'Valor Total': `$${stats.valor.toFixed(2)}`
      }));

      // 🚨 HOJA 5: ALERTAS (Sin Stock y Stock Bajo)
      const alertasData = this.repuestos
        .filter(r => r.cantidad <= (r.minimo || 5))
        .map(r => ({
          '🚨 Prioridad': r.cantidad === 0 ? 'CRÍTICA' : 'MEDIA',
          'Código SAP': r.codSAP || '',
          'Nombre': r.nombre,
          'Stock Actual': r.cantidad,
          '⚠️ Stock Mínimo': r.minimo || 5,
          '📉 Déficit': (r.minimo || 5) - r.cantidad,
          'Área': r.area,
          'Equipo': r.equipo
        }))
        .sort((a, b) => a['Stock Actual'] - b['Stock Actual']);

      // 🔨 CREAR LIBRO DE EXCEL
      const wb = XLSX.utils.book_new();
      
      // Agregar hojas
      const ws1 = XLSX.utils.json_to_sheet(inventarioData);
      const ws2 = XLSX.utils.json_to_sheet(resumenData);
      const ws3 = XLSX.utils.json_to_sheet(areaData);
      const ws4 = XLSX.utils.json_to_sheet(equipoData);
      const ws5 = XLSX.utils.json_to_sheet(alertasData);
      
      // Configurar anchos de columnas
      ws1['!cols'] = [
        { wch: 15 }, { wch: 18 }, { wch: 15 }, { wch: 30 }, { wch: 15 },
        { wch: 20 }, { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
        { wch: 12 }, { wch: 10 }, { wch: 10 }
      ];
      ws2['!cols'] = [{ wch: 35 }, { wch: 25 }];
      ws3['!cols'] = [{ wch: 20 }, { wch: 15 }, { wch: 12 }, { wch: 15 }];
      ws4['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 20 }, { wch: 15 }];
      ws5['!cols'] = [{ wch: 12 }, { wch: 15 }, { wch: 30 }, { wch: 12 }, { wch: 12 }, { wch: 10 }, { wch: 15 }, { wch: 20 }];
      
      // 📈 HOJA 6: ESTADO DEL STOCK (Gráfico Circular)
      const grafEstadoStock = [
        { 'Categoría': 'Stock OK', 'Cantidad': stockOk, 'Porcentaje': parseFloat(((stockOk / this.repuestos.length) * 100).toFixed(1)) },
        { 'Categoría': 'Stock Bajo', 'Cantidad': stockBajo, 'Porcentaje': parseFloat(((stockBajo / this.repuestos.length) * 100).toFixed(1)) },
        { 'Categoría': 'Sin Stock', 'Cantidad': sinStock, 'Porcentaje': parseFloat(((sinStock / this.repuestos.length) * 100).toFixed(1)) }
      ];
      
      const ws6 = XLSX.utils.json_to_sheet(grafEstadoStock);
      ws6['!cols'] = [{ wch: 20 }, { wch: 12 }, { wch: 12 }];
      
      // 📈 HOJA 7: TOP ÁREAS (Gráfico de Barras)
      const topAreas = Object.entries(areaStats)
        .sort((a, b) => b[1].cantidad - a[1].cantidad)
        .slice(0, 10)
        .map(([area, stats]) => ({
          'Área': area,
          'Total Repuestos': stats.cantidad,
          'Sin Stock': stats.sinStock,
          'Valor': parseFloat(stats.valor.toFixed(2))
        }));
      
      const ws7 = XLSX.utils.json_to_sheet(topAreas);
      ws7['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 12 }, { wch: 15 }];
      
      // 📈 HOJA 8: TOP EQUIPOS (Gráfico de Barras Horizontal)
      const topEquipos = Object.entries(equipoStats)
        .sort((a, b) => b[1].valor - a[1].valor)
        .slice(0, 10)
        .map(([equipo, stats]) => ({
          'Equipo': equipo,
          'Valor Total': parseFloat(stats.valor.toFixed(2)),
          'Cantidad': stats.cantidad,
          'Alertas': stats.stockBajo
        }));
      
      const ws8 = XLSX.utils.json_to_sheet(topEquipos);
      ws8['!cols'] = [{ wch: 30 }, { wch: 15 }, { wch: 12 }, { wch: 12 }];
      
      // 📈 HOJA 9: DISTRIBUCIÓN POR TIPO (Gráfico Circular)
      const tipoStats = {};
      this.repuestos.forEach(r => {
        const tipo = r.tipo || 'Sin Tipo';
        if (!tipoStats[tipo]) {
          tipoStats[tipo] = { cantidad: 0, valor: 0 };
        }
        tipoStats[tipo].cantidad++;
        tipoStats[tipo].valor += (r.precio || 0) * (r.cantidad || 0);
      });
      
      const grafTipos = Object.entries(tipoStats)
        .sort((a, b) => b[1].cantidad - a[1].cantidad)
        .map(([tipo, stats]) => ({
          'Tipo': tipo,
          'Cantidad': stats.cantidad,
          'Porcentaje': parseFloat(((stats.cantidad / this.repuestos.length) * 100).toFixed(1)),
          'Valor': parseFloat(stats.valor.toFixed(2))
        }));
      
      const ws9 = XLSX.utils.json_to_sheet(grafTipos);
      ws9['!cols'] = [{ wch: 20 }, { wch: 12 }, { wch: 12 }, { wch: 15 }];
      
      // 📈 HOJA 10: TOP REPUESTOS MÁS VALIOSOS (Gráfico de Barras)
      const topValiosos = this.repuestos
        .map(r => ({
          nombre: r.nombre,
          codSAP: r.codSAP || '',
          valor: (r.precio || 0) * (r.cantidad || 0),
          cantidad: r.cantidad,
          precio: r.precio || 0
        }))
        .filter(r => r.valor > 0) // Solo los que tienen valor
        .sort((a, b) => b.valor - a.valor)
        .slice(0, 15)
        .map(r => ({
          'Repuesto': r.nombre.substring(0, 35),
          'Código SAP': r.codSAP,
          'Valor Total': parseFloat(r.valor.toFixed(2)),
          'Cantidad': r.cantidad,
          'Precio Unit': parseFloat(r.precio.toFixed(2))
        }));
      
      const ws10 = XLSX.utils.json_to_sheet(topValiosos);
      ws10['!cols'] = [{ wch: 35 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 12 }];
      
      XLSX.utils.book_append_sheet(wb, ws1, 'Inventario');
      XLSX.utils.book_append_sheet(wb, ws2, 'Resumen');
      XLSX.utils.book_append_sheet(wb, ws3, '🏢 Por Área');
      XLSX.utils.book_append_sheet(wb, ws4, 'Por Equipo');
      XLSX.utils.book_append_sheet(wb, ws5, ' Alertas');
      XLSX.utils.book_append_sheet(wb, ws6, ' Graf-Estado Stock');
      XLSX.utils.book_append_sheet(wb, ws7, '📈 Graf-Top Áreas');
      XLSX.utils.book_append_sheet(wb, ws8, '📈 Graf-Top Equipos');
      XLSX.utils.book_append_sheet(wb, ws9, ' Graf-Por Tipo');
      XLSX.utils.book_append_sheet(wb, ws10, '📈 Graf-Top Valiosos');
      
      // Generar archivo
      const fechaHora = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const filename = `Inventario_${fechaHora}.xlsx`;
      
      XLSX.writeFile(wb, filename);
      
      this.showToast(`✅ Excel exportado con 10 hojas: ${filename}`, 'success', 4000);
      console.log('✅ Exportación Excel completada:', filename);
      console.log(`   Inventario: ${inventarioData.length} repuestos`);
      console.log(`   Resumen: KPIs generales`);
      console.log(`   🏢 Por Área: ${areaData.length} áreas`);
      console.log(`   Por Equipo: ${equipoData.length} equipos`);
      console.log(`   🚨 Alertas: ${alertasData.length} alertas`);
      console.log(`   📈 Gráficos: 5 hojas listas para visualizar`);
      
    } catch (error) {
      console.error('❌ Error exportando Excel:', error);
      this.showToast('❌ Error al exportar: ' + error.message, 'error');
    }
  }

  togglePrecio() {
    const checkbox = document.getElementById('togglePrecio');
    this.showPrecio = checkbox.checked;
    this.render();
  }

  showStorageInfo() {
    const dataString = JSON.stringify(this.repuestos);
    const sizeInMB = (dataString.length / (1024 * 1024)).toFixed(2);
    const totalImages = this.repuestos.reduce((sum, r) => sum + (r.multimedia ? r.multimedia.filter(m => m.type === 'image').length : 0), 0);
    const totalDocs = this.repuestos.reduce((sum, r) => sum + (r.multimedia ? r.multimedia.filter(m => m.type === 'document').length : 0), 0);
    
    // Detectar si está en modo FileSystem
    const isFileSystemMode = fsManager && fsManager.isFileSystemMode;
    
    const bgCard = '#1e293b';
    const textColor = '#f8fafc';
    const borderColor = '#334155';
    const bgSection = '#0f172a';
    const textSecondary = '#cbd5e1';
    
    const modal = document.createElement('div');
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
    
    modal.innerHTML = `
      <div style="background: ${bgCard}; border-radius: 16px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; padding: 32px; border: 2px solid ${borderColor};">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
          <h2 style="color: #60a5fa; margin: 0;">Información de Almacenamiento</h2>
          <button onclick="this.closest('div[style*=fixed]').remove()" style="background: #334155; border: none; font-size: 1.5rem; cursor: pointer; color: ${textColor}; width: 36px; height: 36px; border-radius: 8px; transition: all 0.2s;">✕</button>
        </div>
        
        ${isFileSystemMode ? `
        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);">
          <div style="font-size: 1.3rem; font-weight: 700; margin-bottom: 8px; display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 2rem;">∞</span> MODO CARPETA ACTIVO
          </div>
          <div style="font-size: 0.95rem; opacity: 0.95;">📁 Carpeta: ${fsManager.folderPath || 'Conectada'}</div>
          <div style="font-size: 0.9rem; opacity: 0.9; margin-top: 6px;">✅ Capacidad ilimitada | Datos en disco</div>
        </div>
        
        <div style="background: ${bgSection}; padding: 16px; border-radius: 12px; margin-bottom: 20px; border-left: 4px solid #10b981;">
          <div style="font-size: 1.2rem; font-weight: 600; color: ${textColor}; margin-bottom: 4px;">Solo Metadata en Memoria</div>
          <div style="font-size: 2rem; font-weight: 700; color: #10b981;">${sizeInMB} MB</div>
          <div style="color: ${textSecondary}; font-size: 0.85rem; margin-top: 4px;">Las imágenes NO cuentan para este tamaño</div>
        </div>
        ` : `
        <div style="background: ${bgSection}; padding: 20px; border-radius: 12px; margin-bottom: 20px; border-left: 4px solid #3b82f6;">
          <div style="font-size: 2.5rem; font-weight: 700; color: #60a5fa; margin-bottom: 8px;">${sizeInMB} MB</div>
          <div style="color: ${textColor}; font-size: 1.1rem; font-weight: 600;">Tamaño en LocalStorage</div>
          <div style="color: ${textSecondary}; font-size: 0.85rem; margin-top: 4px;">⚠️ Límite: ~10MB | Incluye imágenes en base64</div>
        </div>
        `}
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 16px; margin-bottom: 24px;">
          <div style="background: ${bgSection}; padding: 16px; border-radius: 12px; text-align: center; border: 1px solid ${borderColor};">
            <div style="font-size: 1.8rem; font-weight: 700; color: #60a5fa;">${this.repuestos.length}</div>
            <div style="color: ${textColor}; font-size: 0.9rem; margin-top: 4px;">Repuestos</div>
          </div>
          <div style="background: ${bgSection}; padding: 16px; border-radius: 12px; text-align: center; border: 1px solid ${borderColor};">
            <div style="font-size: 1.8rem; font-weight: 700; color: #22d3ee;">${totalImages}</div>
            <div style="color: ${textColor}; font-size: 0.9rem; margin-top: 4px;">Imágenes</div>
          </div>
          <div style="background: ${bgSection}; padding: 16px; border-radius: 12px; text-align: center; border: 1px solid ${borderColor};">
            <div style="font-size: 1.8rem; font-weight: 700; color: #fbbf24;">${totalDocs}</div>
            <div style="color: ${textColor}; font-size: 0.9rem; margin-top: 4px;">Documentos</div>
          </div>
        </div>
        
        ${isFileSystemMode ? `
        <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">∞ MODO CARPETA - SIN LÍMITES</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            ✅ <strong>Capacidad ilimitada:</strong> 1,000+ imágenes sin problema<br>
            📁 <strong>Almacenamiento:</strong> inventario.json + carpeta imagenes/<br>
            <strong>Portable:</strong> Copia la carpeta completa a otro PC<br>
            <strong>Imágenes:</strong> Archivos WebP en disco (no en memoria)<br>
            🔒 <strong>Sin límites:</strong> Solo depende del espacio en disco
          </div>
        </div>
        
        <div style="background: var(--info); color: white; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">¿Cómo llevar tu inventario a otro PC?</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            <strong>1.</strong> Copia la carpeta completa donde seleccionaste guardar<br>
            <strong>2.</strong> Llévala a otro PC (USB, nube, red)<br>
            <strong>3.</strong> Abre este HTML y activa "Modo Carpeta"<br>
            <strong>4.</strong> Selecciona la carpeta copiada<br>
            <strong>5.</strong> ¡Listo! Todo tu inventario estará disponible
          </div>
        </div>
        ` : `
        <div style="background: var(--info); color: white; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">INFO Límites del Sistema</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            • LocalStorage: ~5-10MB según navegador<br>
            • Archivos JSON: Sin límite (exportar/importar)<br>
            • <strong>Imágenes: Formato WebP</strong> (mejor que JPEG)<br>
            • Compresión inteligente: 800px, calidad 85%, ~100KB<br>
            • Sistema optimizado para 500+ repuestos con fotos
          </div>
        </div>
        
        <div style="background: var(--success); color: white; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">✅ Tecnología de Compresión</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            <strong>WebP:</strong> 30% más ligero que JPEG con mejor calidad<br>
            <strong>Fallback:</strong> JPEG de alta calidad si WebP no disponible<br>
            <strong>Optimización:</strong> 800px máx, calidad adaptativa 85-50%<br>
            <strong>Resultado:</strong> Imágenes nítidas de ~100KB<br>
            <strong>Reducción típica:</strong> 80-95% del tamaño original
          </div>
        </div>
        
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px; border-radius: 12px; margin-bottom: 16px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">💡 ¿Muchas imágenes? Activa MODO CARPETA</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            Click en <strong>"📁 Modo Carpeta"</strong> (esquina inferior derecha)<br>
            → Capacidad ILIMITADA | Portable | Sin límites de 10MB
          </div>
        </div>
        `}
        
        <div style="background: var(--warning); color: white; padding: 16px; border-radius: 12px; margin-bottom: 20px;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 8px;">💡 Tip Profesional</div>
          <div style="font-size: 0.95rem; line-height: 1.6;">
            <strong>Para archivos muy grandes (>50MB):</strong><br>
            • El sistema los soporta sin problemas<br>
            • La importación puede tardar 5-10 segundos<br>
            • Todo se mantiene embebido en el HTML+JSON<br>
            • Puedes tener cientos de fotos sin problema<br>
            • Solo el LocalStorage temporal tiene límite
          </div>
        </div>
        
        <div style="display: flex; gap: 12px;">
          <button onclick="app.exportJSON(); this.closest('div[style*=fixed]').remove();" style="flex: 1; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 1rem; transition: all 0.2s;" onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
            Exportar Ahora
          </button>
          <button onclick="this.closest('div[style*=fixed]').remove();" style="flex: 1; padding: 14px; background: #334155; color: ${textColor}; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 1rem; transition: all 0.2s;" onmouseover="this.style.background='#475569'" onmouseout="this.style.background='#334155'">
            Cerrar
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }

  diagnosticIDs() {
    console.log('\n========== DIAGNÓSTICO DE IDs ==========');
    console.log(`Total de repuestos: ${this.repuestos.length}\n`);
    
    const problemas = [];
    const idsMap = new Map();
    
    this.repuestos.forEach((r, index) => {
      const idInfo = {
        index: index,
        id: r.id,
        tipo: typeof r.id,
        nombre: r.nombre || 'Sin nombre',
        codSAP: r.codSAP || 'Sin código',
        multimedia: r.multimedia?.length || 0
      };
      
      console.log(`[${index}] ID: "${r.id}" (${typeof r.id})`);
      console.log(`     ${r.codSAP} - ${r.nombre}`);
      console.log(`     Multimedia: ${r.multimedia?.length || 0} items`);
      
      // Detectar problemas
      if (!r.id) {
        problemas.push(`❌ Repuesto ${index} sin ID: ${r.nombre}`);
      } else if (r.id === 'undefined' || r.id === 'null') {
        problemas.push(`⚠️ Repuesto ${index} con ID inválido: ${r.id}`);
      } else if (idsMap.has(r.id)) {
        problemas.push(`🔄 ID duplicado "${r.id}": índices ${idsMap.get(r.id)} y ${index}`);
      }
      
      idsMap.set(r.id, index);
    });
    
    console.log('\nRESUMEN:');
    console.log(`✅ IDs únicos: ${idsMap.size}`);
    console.log(`Total repuestos: ${this.repuestos.length}`);
    console.log(`⚠️ Problemas encontrados: ${problemas.length}`);
    
    if (problemas.length > 0) {
      console.log('\n🚨 PROBLEMAS DETECTADOS:');
      problemas.forEach(p => console.log(p));
      
      const fixear = confirm(`Se encontraron ${problemas.length} problema(s) con los IDs.\n\n¿Quieres regenerar todos los IDs automáticamente?\n\n(Esto solucionará los problemas pero cambiará los IDs)`);
      
      if (fixear) {
        console.log('\nRegenerando IDs...');
        this.repuestos = this.repuestos.map((r, i) => {
          const oldId = r.id;
          r.id = `repuesto-${Date.now()}-${i}`;
          console.log(`  "${oldId}" → "${r.id}"`);
          return r;
        });
        
        this.saveData();
        this.render();
        this.showToast('✅ IDs regenerados correctamente', 'success');
        console.log('✅ IDs regenerados y guardados');
      }
    } else {
      console.log('✅ No se encontraron problemas');
      this.showToast('✅ Todos los IDs están correctos', 'success');
    }
    
    console.log('========== FIN DIAGNÓSTICO ==========\n');
  }

  showExportMenu() {
    const menu = document.createElement('div');
    menu.style.cssText = 'position: fixed; top: 80px; right: 20px; background: var(--bg-secondary); border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.5), 0 0 20px rgba(59, 130, 246, 0.3); padding: 8px; z-index: 10000; min-width: 220px; border: 1px solid var(--border-color);';
    
    const btnStyle = `width: 100%; padding: 12px; background: transparent; border: none; text-align: left; cursor: pointer; border-radius: 8px; font-weight: 600; color: var(--text-primary); transition: all 0.2s;`;
    const hoverBg = 'var(--bg-tertiary)';
    
    // Mostrar opción de limpieza solo si FileSystem está activo
    const cleanBtn = fsManager.isFileSystemMode ? `
      <div style="border-top: 1px solid var(--border-color); margin: 4px 0; padding-top: 4px;">
        <button onclick="app.cleanOrphanImages(); this.parentElement.parentElement.remove();" style="${btnStyle} color: #f59e0b;" onmouseover="this.style.background='${hoverBg}'" onmouseout="this.style.background='transparent'">
          🗑️ Limpiar Imágenes Huérfanas
        </button>
      </div>
    ` : '';
    
    menu.innerHTML = `
      <button onclick="app.exportJSON(); this.parentElement.remove();" style="${btnStyle}" onmouseover="this.style.background='${hoverBg}'" onmouseout="this.style.background='transparent'">
        📥 Exportar JSON
      </button>
      <button onclick="app.exportExcel(); this.parentElement.remove();" style="${btnStyle}" onmouseover="this.style.background='${hoverBg}'" onmouseout="this.style.background='transparent'">
        📊 Exportar Excel
      </button>
      ${cleanBtn}
    `;
    
    document.body.appendChild(menu);
    
    setTimeout(() => {
      document.addEventListener('click', function closeMenu(e) {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }
      });
    }, 100);
  }

  async cleanOrphanImages() {
    if (!fsManager.isFileSystemMode) {
      this.showToast('⚠️ Función solo disponible en modo FileSystem', 'warning');
      return;
    }
    
    const confirm1 = confirm(
      '🔍 Limpieza de Imágenes Huérfanas\n\n' +
      'Esta función buscará y eliminará imágenes que estén en la carpeta\n' +
      'pero que ya no estén vinculadas a ningún producto.\n\n' +
      '⚠️ Esta acción NO se puede deshacer.\n\n' +
      '¿Deseas continuar?'
    );
    
    if (!confirm1) return;
    
    this.showToast('🔍 Analizando carpeta de imágenes...', 'info', 3000);
    
    try {
      const result = await fsManager.cleanOrphanImages(this.repuestos);
      
      if (result.orphans === 0) {
        this.showToast('✅ No se encontraron imágenes huérfanas. Carpeta limpia.', 'success', 5000);
        return;
      }
      
      const sizeMB = (result.size / 1024 / 1024).toFixed(2);
      
      const message = 
        `🗑️ Limpieza completada:\n\n` +
        `• Imágenes huérfanas: ${result.orphans}\n` +
        `• Eliminadas exitosamente: ${result.deleted}\n` +
        `• Errores: ${result.failed}\n` +
        `• Espacio liberado: ${sizeMB} MB\n\n` +
        `✅ Tu carpeta está más limpia y optimizada.`;
      
      alert(message);
      this.showToast(`✅ ${result.deleted} imágenes huérfanas eliminadas (${sizeMB} MB liberados)`, 'success', 6000);
      
    } catch (error) {
      console.error('Error en limpieza:', error);
      this.showToast('❌ Error durante la limpieza: ' + error.message, 'error');
    }
  }

  showToast(msg, type = 'info', customDuration = null) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.innerHTML = msg;
    
    // Color del borde según tipo
    const borderColor = type === 'success' ? '#10b981' : 
                        type === 'warning' ? '#f59e0b' : 
                        type === 'error' ? '#ef4444' : 
                        '#3b82f6';
    
    toast.style.borderLeftColor = borderColor;
    
    // 🔥 APILAMIENTO: Calcular posición según toasts existentes
    const existingToasts = document.querySelectorAll('.toast');
    let totalOffset = 20; // Offset inicial desde abajo
    
    existingToasts.forEach(existingToast => {
      const height = existingToast.offsetHeight || 60; // altura estimada
      totalOffset += height + 12; // 12px de separación entre toasts
    });
    
    toast.style.bottom = `${totalOffset}px`;
    
    document.body.appendChild(toast);
    
    // Duración: usar customDuration si se proporciona, sino según tipo
    const duration = customDuration || (type === 'error' ? 5000 : 3000);
    
    // Remover con animación
    setTimeout(() => {
      toast.classList.add('fade-out');
      setTimeout(() => {
        toast.remove();
        // Reajustar posiciones de toasts restantes
        this.repositionToasts();
      }, 300);
    }, duration);
  }

  repositionToasts() {
    const toasts = document.querySelectorAll('.toast');
    let offset = 20;
    
    toasts.forEach(toast => {
      toast.style.bottom = `${offset}px`;
      const height = toast.offsetHeight || 60;
      offset += height + 12;
    });
  }

  // 🆕 Modal personalizado para input (reemplazo de prompt)
  showInputModal(title, defaultValue = '') {
    return new Promise((resolve) => {
      // Helper para escapar HTML
      const escapeHtml = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };
      
      const overlay = document.createElement('div');
      overlay.className = 'custom-modal-overlay';
      
      overlay.innerHTML = `
        <div class="custom-modal">
          <div class="custom-modal-title">${escapeHtml(title)}</div>
          <input type="text" class="custom-modal-input" value="${escapeHtml(defaultValue)}" autofocus>
          <div class="custom-modal-buttons">
            <button class="custom-modal-btn custom-modal-btn-secondary" data-action="cancel">Cancelar</button>
            <button class="custom-modal-btn custom-modal-btn-primary" data-action="accept">Aceptar</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const input = overlay.querySelector('.custom-modal-input');
      const acceptBtn = overlay.querySelector('[data-action="accept"]');
      const cancelBtn = overlay.querySelector('[data-action="cancel"]');
      
      // Focus en el input y seleccionar texto
      setTimeout(() => {
        input.focus();
        input.select();
      }, 100);
      
      const close = (value) => {
        overlay.remove();
        resolve(value);
      };
      
      acceptBtn.onclick = () => close(input.value);
      cancelBtn.onclick = () => close(null);
      
      // Enter para aceptar, Escape para cancelar
      input.onkeydown = (e) => {
        if (e.key === 'Enter') close(input.value);
        if (e.key === 'Escape') close(null);
      };
      
      // Click fuera del modal para cancelar
      overlay.onclick = (e) => {
        if (e.target === overlay) close(null);
      };
    });
  }

  // 🆕 Modal personalizado para confirmación (reemplazo de confirm)
  showConfirmModal(message) {
    return new Promise((resolve) => {
      // Helper para escapar HTML
      const escapeHtml = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };
      
      const overlay = document.createElement('div');
      overlay.className = 'custom-modal-overlay';
      
      overlay.innerHTML = `
        <div class="custom-modal">
          <div class="custom-modal-title">Confirmar acción</div>
          <div class="custom-modal-message">${escapeHtml(message).replace(/\n/g, '<br>')}</div>
          <div class="custom-modal-buttons">
            <button class="custom-modal-btn custom-modal-btn-secondary" data-action="cancel">Cancelar</button>
            <button class="custom-modal-btn custom-modal-btn-primary" data-action="accept">Aceptar</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      const acceptBtn = overlay.querySelector('[data-action="accept"]');
      const cancelBtn = overlay.querySelector('[data-action="cancel"]');
      
      const close = (value) => {
        overlay.remove();
        resolve(value);
      };
      
      acceptBtn.onclick = () => close(true);
      cancelBtn.onclick = () => close(false);
      
      // Escape para cancelar
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape') {
          close(false);
          document.removeEventListener('keydown', escapeHandler);
        }
      });
      
      // Click fuera del modal para cancelar
      overlay.onclick = (e) => {
        if (e.target === overlay) close(false);
      };
    });
  }
}

console.log('=== INVENTARIO PRO - INICIANDO ===');
console.log('Versión: 2.0');

const okrModule = {
  state: {
    objectives: [],
    keyResults: [],
    initiatives: [],
    filters: {
      cycle: 'all',
      owner: 'all',
      status: 'all',
      tag: 'all',
      search: ''
    },
    dataLoaded: false
  },
  elements: {},
  headerAliasList: [
    { key: 'objective', aliases: ['objective', 'objetivo', 'okr objetivo', 'objective name'] },
    { key: 'cycle', aliases: ['cycle', 'ciclo', 'quarter', 'periodo', 'period'] },
    { key: 'objectiveOwner', aliases: ['objective owner', 'owner objetivo', 'dueno objetivo', 'responsable objetivo', 'lider objetivo'] },
    { key: 'owner', aliases: ['owner', 'responsable', 'lider', 'lead'] },
    { key: 'team', aliases: ['team', 'equipo', 'area'] },
    { key: 'objectiveStatus', aliases: ['objective status', 'estado objetivo', 'status objetivo', 'estado general'] },
    { key: 'objectiveProgress', aliases: ['objective progress', 'progreso objetivo', 'avance objetivo', 'progress objetivo'] },
    { key: 'objectiveCategory', aliases: ['category', 'categoria', 'pilar', 'tema'] },
    { key: 'objectiveNotes', aliases: ['objective notes', 'notas objetivo', 'descripcion objetivo', 'descripcion general'] },
    { key: 'keyResult', aliases: ['key result', 'resultado clave', 'kr', 'resultado okr'] },
    { key: 'krOwner', aliases: ['kr owner', 'responsable rc', 'responsable resultado', 'dueno rc', 'owner rc'] },
    { key: 'krMetric', aliases: ['metric', 'metrica', 'indicador', 'measure'] },
    { key: 'krBaseline', aliases: ['baseline', 'linea base', 'valor inicial'] },
    { key: 'krTarget', aliases: ['target', 'meta', 'objetivo kr', 'expected'] },
    { key: 'krCurrent', aliases: ['current', 'actual', 'valor actual', 'resultado actual'] },
    { key: 'krProgress', aliases: ['kr progress', 'progreso kr', 'avance kr', 'progress rc'] },
    { key: 'krConfidence', aliases: ['kr confidence', 'confidence', 'confianza', 'confidence level'] },
    { key: 'krStatus', aliases: ['kr status', 'estado kr', 'estado rc', 'status rc'] },
    { key: 'initiatives', aliases: ['initiatives', 'iniciativas', 'initiative', 'iniciativa'] },
    { key: 'initiativeOwner', aliases: ['initiative owner', 'owner iniciativa', 'responsable iniciativa', 'lider iniciativa'] },
    { key: 'initiativeStatus', aliases: ['initiative status', 'estado iniciativa', 'status iniciativa'] },
    { key: 'initiativeDue', aliases: ['due date', 'fecha objetivo', 'fecha limite', 'deadline', 'fecha compromiso'] },
    { key: 'confidence', aliases: ['confidence global', 'confianza global'] },
    { key: 'tags', aliases: ['tags', 'etiquetas', 'labels', 'temas'] },
    { key: 'alignment', aliases: ['alignment', 'alineacion', 'alineacion estrategica', 'pillar'] },
    { key: 'priority', aliases: ['priority', 'prioridad'] },
    { key: 'notes', aliases: ['notes', 'notas', 'comentarios', 'observaciones'] }
  ],
  statusAliasMap: {
    on_track: ['on track', 'en curso', 'en marcha', 'a tiempo', 'verde', 'cumpliendo'],
    at_risk: ['at risk', 'con riesgo', 'riesgo', 'amarillo', 'alerta'],
    off_track: ['off track', 'retrasado', 'fuera de plan', 'rojo', 'bloqueado', 'critico', 'crtico'],
    completed: ['completed', 'completado', 'alcanzado', 'logrado', 'finalizado', 'cerrado'],
    not_started: ['not started', 'sin iniciar', 'pendiente', 'por iniciar', 'no iniciado'],
    paused: ['paused', 'pausado', 'en pausa', 'aplazado']
  },
  init() {
    this.cacheElements();
    if (!this.elements.container) {
      console.warn('[OKR] Contenedor no encontrado, se omite inicialización.');
      return;
    }
    this.bindEvents();
    this.renderEmptyState();
  },
  cacheElements() {
    this.elements = {
      container: document.getElementById('okr'),
      summary: document.getElementById('okrSummary'),
      filters: document.getElementById('okrFilters'),
      dropzone: document.getElementById('okrDropzone'),
      fileInput: document.getElementById('okrExcelInput'),
      filterCycle: document.getElementById('okrFilterCycle'),
      filterOwner: document.getElementById('okrFilterOwner'),
      filterStatus: document.getElementById('okrFilterStatus'),
      filterTag: document.getElementById('okrFilterTag'),
      searchInput: document.getElementById('okrSearchInput'),
      resetFilters: document.getElementById('okrResetFilters'),
      objectives: document.getElementById('okrObjectives'),
      insights: document.getElementById('okrInsights'),
      keyResults: document.getElementById('okrKeyResults'),
      initiatives: document.getElementById('okrInitiatives'),
      templateBtn: document.getElementById('okrDownloadTemplate'),
      demoBtn: document.getElementById('okrLoadDemo')
    };
  },
  bindEvents() {
    const els = this.elements;
    if (!els.container) return;

    if (els.fileInput) {
      els.fileInput.addEventListener('change', (event) => {
        this.handleFileList(event.target.files);
        event.target.value = '';
      });
    }

    if (els.dropzone) {
      const prevent = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };
      ['dragenter', 'dragover'].forEach(evt => {
        els.dropzone.addEventListener(evt, (event) => {
          prevent(event);
          els.dropzone.classList.add('is-dragover');
        });
      });
      ['dragleave', 'dragend', 'drop'].forEach(evt => {
        els.dropzone.addEventListener(evt, (event) => {
          prevent(event);
          if (evt === 'drop') {
            this.handleFileList(event.dataTransfer?.files);
          }
          els.dropzone.classList.remove('is-dragover');
        });
      });
      els.dropzone.addEventListener('click', () => {
        els.fileInput?.click();
      });
    }

    const filterSelects = [
      { el: els.filterCycle, key: 'cycle' },
      { el: els.filterOwner, key: 'owner' },
      { el: els.filterStatus, key: 'status' },
      { el: els.filterTag, key: 'tag' }
    ];
    filterSelects.forEach(({ el, key }) => {
      if (!el) return;
      el.addEventListener('change', (event) => {
        this.state.filters[key] = event.target.value;
        this.renderDashboard();
      });
    });

    if (els.searchInput) {
      let searchTimeout;
      els.searchInput.addEventListener('input', (event) => {
        clearTimeout(searchTimeout);
        const value = event.target.value;
        searchTimeout = setTimeout(() => {
          this.state.filters.search = value;
          this.renderDashboard();
        }, 180);
      });
    }

    if (els.resetFilters) {
      els.resetFilters.addEventListener('click', () => this.resetFilters());
    }

    if (els.templateBtn) {
      els.templateBtn.addEventListener('click', () => this.downloadTemplate());
    }

    if (els.demoBtn) {
      els.demoBtn.addEventListener('click', () => this.loadDemoData());
    }
  },
  async handleFileList(fileList) {
    if (!fileList || !fileList.length) {
      this.showToast('No se detect archivo para importar.', 'warning', 2500);
      return;
    }
    const file = fileList[0];
    try {
      const workbook = await this.readWorkbookFromFile(file);
      const dataset = this.parseWorkbook(workbook);
      this.setData(dataset);
      this.showToast(`OKR importados desde ${file.name}`, 'success', 3200);
    } catch (error) {
      console.error('[OKR] Error importando Excel:', error);
      this.showToast(`Error al procesar el archivo: ${error.message}`, 'error', 4800);
    }
  },
  readWorkbookFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error('No se pudo leer el archivo'));
      reader.onload = (event) => {
        try {
          const data = event.target?.result;
          const workbook = XLSX.read(data, { type: 'array' });
          resolve(workbook);
        } catch (error) {
          reject(error);
        }
      };
      reader.readAsArrayBuffer(file);
    });
  },
  parseWorkbook(workbook) {
    if (!workbook || !workbook.SheetNames?.length) {
      throw new Error('El archivo no contiene hojas válidas.');
    }
    const firstSheet = workbook.SheetNames[0];
    const sheet = workbook.Sheets[firstSheet];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    if (!rows.length) {
      throw new Error('La hoja seleccionada está vacía.');
    }

    const headerRow = rows[0].map(cell => this.normalizeHeader(cell));
    const headerKeys = headerRow.map(header => this.resolveHeaderAlias(header));

    const dataRows = rows.slice(1);
    const normalizedRows = [];
    let lastObjective = '';

    dataRows.forEach((row) => {
      if (!row || row.every(cell => cell === null || cell === undefined || String(cell).trim() === '')) {
        return;
      }
      const record = {};
      headerKeys.forEach((key, index) => {
        if (!key) return;
        record[key] = row[index];
      });

      if (!record.objective || !String(record.objective).trim()) {
        record.objective = lastObjective;
      }

      if (!record.objective || !String(record.objective).trim()) {
        return;
      }

      lastObjective = record.objective;
      normalizedRows.push(record);
    });

    if (!normalizedRows.length) {
      throw new Error('No se encontraron filas con objetivos válidos.');
    }

    return this.transformRows(normalizedRows, true);
  },
  normalizeHeader(value) {
    return String(value || '')
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, ' ')
      .trim();
  },
  resolveHeaderAlias(normalized) {
    if (!normalized) return null;
    for (const entry of this.headerAliasList) {
      if (entry.aliases.includes(normalized)) {
        return entry.key;
      }
      if (entry.aliases.some(alias => normalized.startsWith(alias))) {
        return entry.key;
      }
    }
    return null;
  },
  transformRows(rows, alreadyNormalized = false) {
    const objectivesMap = new Map();
    const keyResults = [];
    const initiatives = [];
    let objectiveCounter = 0;
    let krCounter = 0;

    rows.forEach((rawRow) => {
      if (!rawRow) return;
      const row = alreadyNormalized ? { ...rawRow } : { ...rawRow };

      if (!row.objective || !String(row.objective).trim()) {
        return;
      }
      const objectiveName = String(row.objective).trim();
      const objectiveKey = objectiveName.toLowerCase();

      if (!objectivesMap.has(objectiveKey)) {
        objectiveCounter += 1;
        objectivesMap.set(objectiveKey, {
          id: `obj-${objectiveCounter}`,
          name: objectiveName,
          owner: row.objectiveOwner || row.owner || '',
          team: row.team || '',
          cycle: row.cycle || '',
          status: this.normalizeStatus(row.objectiveStatus || row.status || null, 'objective'),
          progress: this.clampProgress(this.parsePercent(row.objectiveProgress ?? row.progress)),
          confidence: null,
          category: row.objectiveCategory || '',
          tags: this.parseTags(row.tags),
          notes: row.objectiveNotes || row.notes || '',
          alignment: row.alignment || '',
          priority: row.priority || '',
          keyResults: []
        });
      }

      const objective = objectivesMap.get(objectiveKey);

      if (row.cycle && !objective.cycle) objective.cycle = row.cycle;
      if (row.objectiveOwner) objective.owner = row.objectiveOwner;
      if (row.team && !objective.team) objective.team = row.team;
      if (row.objectiveStatus) objective.status = this.normalizeStatus(row.objectiveStatus, 'objective');
      if (row.objectiveProgress !== undefined && row.objectiveProgress !== null && row.objectiveProgress !== '') {
        objective.progress = this.clampProgress(this.parsePercent(row.objectiveProgress));
      }
      if (row.alignment) objective.alignment = row.alignment;
      if (row.priority) objective.priority = row.priority;
      if (row.objectiveNotes) objective.notes = row.objectiveNotes;
      if (row.tags) {
        const merged = new Set([...objective.tags, ...this.parseTags(row.tags)]);
        objective.tags = Array.from(merged);
      }

      const krNameRaw = row.keyResult || row.kr || row.resultadoClave;
      const krName = krNameRaw ? String(krNameRaw).trim() : '';
      const metric = row.krMetric || row.metric || '';
      const baseline = this.parseNumber(row.krBaseline ?? row.baseline);
      const target = this.parseNumber(row.krTarget ?? row.target);
      const current = this.parseNumber(row.krCurrent ?? row.current);
      const progressFromRow = this.parsePercent(row.krProgress);
      let krProgress = progressFromRow !== null ? progressFromRow : null;

      if (krProgress === null && target !== null && current !== null) {
        if (baseline !== null && target !== baseline) {
          krProgress = ((current - baseline) / (target - baseline)) * 100;
        } else if (target !== 0) {
          krProgress = (current / target) * 100;
        }
      }

      const krStatus = this.normalizeStatus(row.krStatus || row.status || null, 'kr');
      const krConfidence = this.parseNumber(row.krConfidence ?? row.confidence);
      const krOwner = row.krOwner || row.owner || objective.owner;

      if (krName) {
        krCounter += 1;
        const kr = {
          id: `kr-${krCounter}`,
          objectiveId: objective.id,
          objectiveName: objective.name,
          name: krName,
          owner: krOwner,
          metric,
          baseline,
          target,
          current,
          progress: krProgress !== null ? this.clampProgress(krProgress) : null,
          status: krStatus,
          confidence: Number.isFinite(krConfidence) ? krConfidence : null,
          tags: this.parseTags(row.tags),
          notes: row.notes || ''
        };
        objective.keyResults.push(kr);
        keyResults.push(kr);

        const initiativesRaw = this.splitText(row.initiatives || row.initiative);
        if (initiativesRaw.length) {
          initiativesRaw.forEach((title) => {
            if (!title) return;
            const dueDate = this.parseDate(row.initiativeDue);
            initiatives.push({
              id: `init-${initiatives.length + 1}`,
              title,
              owner: row.initiativeOwner || krOwner || objective.owner,
              status: this.normalizeStatus(row.initiativeStatus || row.krStatus || null, 'initiative'),
              due: dueDate,
              dueLabel: dueDate ? this.formatDate(dueDate) : '',
              objectiveId: objective.id,
              objectiveName: objective.name,
              keyResultId: kr.id,
              keyResultName: kr.name,
              cycle: objective.cycle,
              tags: this.parseTags(row.tags)
            });
          });
        }
      }
    });

    const objectives = Array.from(objectivesMap.values()).map((objective) => {
      const validProgress = objective.keyResults
        .map(kr => kr.progress)
        .filter(value => typeof value === 'number' && !Number.isNaN(value));
      if ((!Number.isFinite(objective.progress) || objective.progress === null) && validProgress.length) {
        const avg = validProgress.reduce((sum, value) => sum + value, 0) / validProgress.length;
        objective.progress = this.clampProgress(avg);
      }
      if (!Number.isFinite(objective.progress)) {
        objective.progress = 0;
      }
      const confidences = objective.keyResults
        .map(kr => kr.confidence)
        .filter(value => typeof value === 'number' && !Number.isNaN(value));
      objective.confidence = confidences.length
        ? Number((confidences.reduce((sum, value) => sum + value, 0) / confidences.length).toFixed(1))
        : null;
      return objective;
    });

    return { objectives, keyResults, initiatives };
  },
  parseNumber(value) {
    if (value === null || value === undefined || value === '') return null;
    if (typeof value === 'number' && !Number.isNaN(value)) return value;
    const normalized = String(value)
      .replace(/\s/g, '')
      .replace(/%/g, '')
      .replace(/,/g, '.')
      .replace(/[^0-9.+\-]/g, '');
    if (!normalized) return null;
    const number = parseFloat(normalized);
    return Number.isFinite(number) ? number : null;
  },
  parsePercent(value) {
    if (value === null || value === undefined || value === '') return null;
    const number = this.parseNumber(value);
    if (number === null) return null;
    const raw = String(value).trim();
    if (raw.includes('%')) {
      return number;
    }
    if (Math.abs(number) <= 1 && /[.,]\d+/.test(raw)) {
      return number * 100;
    }
    return number;
  },
  clampProgress(value) {
    if (!Number.isFinite(value)) return 0;
    return Math.max(0, Math.min(150, Number(value)));
  },
  parseDate(value) {
    if (value === null || value === undefined || value === '') return null;
    if (value instanceof Date && !Number.isNaN(value.getTime())) {
      return value;
    }
    if (typeof value === 'number' && typeof XLSX !== 'undefined' && XLSX?.SSF?.parse_date_code) {
      const parsed = XLSX.SSF.parse_date_code(value);
      if (parsed) {
        return new Date(parsed.y, parsed.m - 1, parsed.d);
      }
    }
    const str = String(value).trim();
    if (!str) return null;
    const date = new Date(str);
    if (!Number.isNaN(date.getTime())) return date;

    const normalized = str.replace(/-/g, '/');
    const parts = normalized.split('/');
    if (parts.length === 3) {
      if (parts[0].length === 4) {
        const dateFromIso = new Date(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]));
        if (!Number.isNaN(dateFromIso.getTime())) return dateFromIso;
      } else {
        const day = Number(parts[0]);
        const month = Number(parts[1]) - 1;
        const year = Number(parts[2].length === 2 ? `20${parts[2]}` : parts[2]);
        const parsedDate = new Date(year, month, day);
        if (!Number.isNaN(parsedDate.getTime())) return parsedDate;
      }
    }
    return null;
  },
  formatDate(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
    return date.toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric' });
  },
  parseTags(value) {
    if (value === null || value === undefined || value === '') return [];
    if (Array.isArray(value)) {
      return value.map(tag => String(tag).trim()).filter(Boolean);
    }
    return String(value)
      .split(/[,;|]/)
      .map(tag => tag.trim())
      .filter(Boolean);
  },
  splitText(value) {
    if (!value && value !== 0) return [];
    if (Array.isArray(value)) {
      return value.map(item => String(item).trim()).filter(Boolean);
    }
    return String(value)
      .split(/[\n;|]/)
      .map(item => item.trim())
      .filter(Boolean);
  },
  normalizeStatus(value, scope = 'objective') {
    if (value === null || value === undefined || value === '') {
      return scope === 'initiative' ? 'not_started' : 'on_track';
    }
    const normalized = this.normalizeHeader(value);
    if (!normalized) {
      return scope === 'initiative' ? 'not_started' : 'on_track';
    }
    for (const [status, aliases] of Object.entries(this.statusAliasMap)) {
      if (aliases.includes(normalized) || aliases.some(alias => normalized.startsWith(alias))) {
        return status;
      }
    }
    if (scope === 'objective' && /100/.test(String(value))) {
      return 'completed';
    }
    return scope === 'initiative' ? 'not_started' : 'on_track';
  },
  getStatusColor(status) {
    const palette = {
      on_track: 'var(--success)',
      at_risk: 'var(--warning)',
      off_track: 'var(--danger)',
      completed: 'var(--primary-light)',
      not_started: 'var(--text-muted)',
      paused: 'var(--secondary)'
    };
    return palette[status] || 'var(--primary-light)';
  },
  formatStatusLabel(status) {
    switch (status) {
      case 'on_track':
        return 'En curso';
      case 'at_risk':
        return 'Con riesgo';
      case 'off_track':
        return 'Fuera de plan';
      case 'completed':
        return 'Completado';
      case 'paused':
        return 'Pausado';
      case 'not_started':
      default:
        return 'Pendiente';
    }
  },
  setData(dataset) {
    if (!dataset || !Array.isArray(dataset.objectives)) {
      throw new Error('Dataset OKR inválido.');
    }
    this.state.objectives = dataset.objectives;
    this.state.keyResults = dataset.keyResults || [];
    this.state.initiatives = dataset.initiatives || [];
    this.state.dataLoaded = true;
    this.resetFilters(false);
    this.updateFilterOptions();
    this.renderDashboard();
  },
  resetFilters(shouldRender = true) {
    this.state.filters = {
      cycle: 'all',
      owner: 'all',
      status: 'all',
      tag: 'all',
      search: ''
    };
    if (this.elements.filterCycle) this.elements.filterCycle.value = 'all';
    if (this.elements.filterOwner) this.elements.filterOwner.value = 'all';
    if (this.elements.filterStatus) this.elements.filterStatus.value = 'all';
    if (this.elements.filterTag) this.elements.filterTag.value = 'all';
    if (this.elements.searchInput) this.elements.searchInput.value = '';
    if (shouldRender) {
      this.renderDashboard();
    }
  },
  updateFilterOptions() {
    if (!this.elements.container || !this.state.objectives.length) {
      return;
    }
    const cycles = new Set();
    const owners = new Set();
    const statuses = new Set();
    const tags = new Set();

    this.state.objectives.forEach((obj) => {
      if (obj.cycle) cycles.add(obj.cycle);
      if (obj.owner) owners.add(obj.owner);
      if (obj.status) statuses.add(obj.status);
      (obj.tags || []).forEach(tag => tags.add(tag));
    });

    this.populateSelect(this.elements.filterCycle, cycles, 'Todos');
    this.populateSelect(this.elements.filterOwner, owners, 'Todos');
    this.populateSelect(this.elements.filterStatus, statuses, 'Todos', { isStatus: true });
    this.populateSelect(this.elements.filterTag, tags, 'Todas');
  },
  populateSelect(select, values, placeholder, options = {}) {
    if (!select) return;
    const currentValue = select.value || 'all';
    const sorted = Array.from(values)
      .filter(Boolean)
      .sort((a, b) => String(a).localeCompare(String(b), 'es', { sensitivity: 'base' }));
    let html = `<option value="all">${placeholder}</option>`;
    sorted.forEach((value) => {
      const label = options.isStatus ? this.formatStatusLabel(value) : value;
      html += `<option value="${this.escapeHtml(value)}">${this.escapeHtml(label)}</option>`;
    });
    select.innerHTML = html;
    if (sorted.includes(currentValue)) {
      select.value = currentValue;
    } else {
      select.value = 'all';
    }
  },
  applyFilters() {
    if (!this.state.objectives.length) return [];
    const { cycle, owner, status, tag, search } = this.state.filters;
    const term = (search || '').trim().toLowerCase();
    return this.state.objectives.filter((obj) => {
      if (cycle !== 'all' && obj.cycle !== cycle) return false;
      if (owner !== 'all' && obj.owner !== owner) return false;
      if (status !== 'all' && obj.status !== status) return false;
      if (tag !== 'all' && !(obj.tags || []).includes(tag)) return false;
      if (term) {
        const haystack = [
          obj.name,
          obj.owner,
          obj.cycle,
          obj.team,
          (obj.tags || []).join(' '),
          obj.keyResults.map(kr => `${kr.name} ${kr.owner} ${kr.metric}`).join(' ')
        ].join(' ').toLowerCase();
        if (!haystack.includes(term)) {
          return false;
        }
      }
      return true;
    });
  },
  renderDashboard() {
    if (!this.elements.container) return;
    if (!this.state.objectives.length) {
      this.renderEmptyState();
      return;
    }
    const filteredObjectives = this.applyFilters();
    this.lastFilteredIds = new Set(filteredObjectives.map(obj => obj.id));

    this.toggleFilters(true);
    this.toggleInsights(true);
    this.renderSummary(filteredObjectives);
    this.renderObjectives(filteredObjectives);
    this.renderKeyResults(filteredObjectives);
    this.renderInitiatives(filteredObjectives);
  },
  renderSummary(objectives) {
    const summaryEl = this.elements.summary;
    if (!summaryEl) return;
    if (!this.state.objectives.length) {
      summaryEl.classList.remove('is-visible');
      summaryEl.innerHTML = '';
      return;
    }

    summaryEl.classList.add('is-visible');

    if (!objectives.length) {
      summaryEl.innerHTML = `
        <div class="okr-empty-panel">
          <strong>Sin coincidencias con los filtros aplicados.</strong>
          <span>Ajusta los criterios para visualizar tus OKR.</span>
        </div>
      `;
      return;
    }

    const totalObjectives = objectives.length;
    const relatedKeyResults = this.state.keyResults.filter(kr => this.lastFilteredIds.has(kr.objectiveId));
    const avgProgress = totalObjectives
      ? objectives.reduce((sum, obj) => sum + (Number.isFinite(obj.progress) ? obj.progress : 0), 0) / totalObjectives
      : 0;
    const validConfidences = relatedKeyResults.filter(kr => Number.isFinite(kr.confidence));
    const avgConfidence = validConfidences.length
      ? validConfidences.reduce((sum, kr) => sum + kr.confidence, 0) / validConfidences.length
      : null;

    const atRisk = objectives.filter(obj => obj.status === 'at_risk').length;
    const offTrack = objectives.filter(obj => obj.status === 'off_track').length;
    const completed = objectives.filter(obj => obj.status === 'completed').length;
    const initiatives = this.state.initiatives.filter(init => this.lastFilteredIds.has(init.objectiveId));
    const upcoming = initiatives
      .filter(init => init.due)
      .sort((a, b) => a.due - b.due)
      .slice(0, 1);
    const nextMilestone = upcoming[0]?.dueLabel || 'Sin hitos próximos';
    const riskKRs = relatedKeyResults.filter(kr => kr.status === 'at_risk' || kr.status === 'off_track').length;

    summaryEl.innerHTML = `
      <div class="okr-summary-grid">
        <article class="okr-summary-card">
          <span class="okr-summary-label">Objetivos activos</span>
          <span class="okr-summary-value">${this.formatNumber(totalObjectives)}</span>
          <span class="okr-summary-sub">${this.formatNumber(relatedKeyResults.length)} resultados clave</span>
        </article>
        <article class="okr-summary-card">
          <span class="okr-summary-label">Avance promedio</span>
          <span class="okr-summary-value">${this.formatDecimal(avgProgress, 0)}%</span>
          <span class="okr-summary-sub">${avgConfidence === null ? 'Sin dato de confianza' : `Confianza media ${this.formatDecimal(avgConfidence, 1)}/10`}</span>
        </article>
        <article class="okr-summary-card">
          <span class="okr-summary-label">Estado del portfolio</span>
          <span class="okr-summary-value">${this.formatNumber(completed)} ✔︎</span>
          <span class="okr-summary-sub">${this.formatNumber(atRisk)} con riesgo · ${this.formatNumber(offTrack)} fuera de plan</span>
        </article>
        <article class="okr-summary-card">
          <span class="okr-summary-label">Próximo hito</span>
          <span class="okr-summary-value">${this.escapeHtml(nextMilestone)}</span>
          <span class="okr-summary-sub">${riskKRs ? `${this.formatNumber(riskKRs)} resultados clave necesitan foco` : 'Sin alertas'}</span>
        </article>
      </div>
    `;
  },
  renderObjectives(objectives) {
    const container = this.elements.objectives;
    if (!container) return;
    if (!this.state.objectives.length) {
      container.innerHTML = '';
      return;
    }
    if (!objectives.length) {
      container.innerHTML = `
        <div class="okr-empty">
          <h3>No hay resultados para los filtros actuales</h3>
          <p>Amplía la búsqueda o restablece los filtros para visualizar tus OKR.</p>
        </div>
      `;
      return;
    }
    container.innerHTML = objectives.map(obj => this.renderObjectiveCard(obj)).join('');
  },
  renderObjectiveCard(objective) {
    const progress = Number.isFinite(objective.progress) ? Math.round(objective.progress) : 0;
    const progressDeg = Math.max(0, Math.min(100, progress)) * 3.6;
    const color = this.getStatusColor(objective.status);
    const tags = (objective.tags || []).length
      ? `<div class="okr-tags">${objective.tags.map(tag => `<span class="okr-chip tag">${this.escapeHtml(tag)}</span>`).join('')}</div>`
      : '';
    const metaLine = [
      objective.alignment ? `<span class="okr-meta-item">Alinea: ${this.escapeHtml(objective.alignment)}</span>` : '',
      Number.isFinite(objective.confidence) ? `<span class="okr-meta-item">Confianza ${this.formatDecimal(objective.confidence, 1)}/10</span>` : '',
      objective.priority ? `<span class="okr-meta-item">Prioridad ${this.escapeHtml(objective.priority)}</span>` : ''
    ].filter(Boolean).join('');

    const keyResults = objective.keyResults.length
      ? objective.keyResults.map(kr => this.renderKeyResultChip(kr)).join('')
      : `<div class="okr-empty-panel">Agrega resultados clave para este objetivo.</div>`;

    return `
      <article class="okr-card" data-okr-objective="${objective.id}">
        <header class="okr-card-header">
          <div class="okr-progress-ring" style="--progress:${progressDeg}; --progress-color:${color};">
            <span>${this.formatDecimal(progress, 0)}%</span>
          </div>
          <div class="okr-card-title">
            <h3>${this.escapeHtml(objective.name)}</h3>
            <div class="okr-card-meta">
              <span class="okr-chip status status-${objective.status}">${this.formatStatusLabel(objective.status)}</span>
              ${objective.cycle ? `<span class="okr-chip muted">${this.escapeHtml(objective.cycle)}</span>` : ''}
              ${objective.owner ? `<span class="okr-chip muted">👤 ${this.escapeHtml(objective.owner)}</span>` : ''}
              ${objective.team ? `<span class="okr-chip muted">🧩 ${this.escapeHtml(objective.team)}</span>` : ''}
            </div>
          </div>
        </header>
        <div class="okr-card-body">
          ${objective.notes ? `<p class="okr-card-notes">${this.escapeHtml(objective.notes)}</p>` : ''}
          ${metaLine ? `<div class="okr-metadata-line">${metaLine}</div>` : ''}
          <div class="okr-kr-list">
            ${keyResults}
          </div>
          ${tags}
        </div>
      </article>
    `;
  },
  renderKeyResultChip(kr) {
    const progress = Number.isFinite(kr.progress) ? `${this.formatDecimal(kr.progress, 0)}%` : '--';
    const metricSegments = [];
    if (Number.isFinite(kr.current)) metricSegments.push(`Actual ${this.formatDecimal(kr.current, 1)}`);
    if (Number.isFinite(kr.target)) metricSegments.push(`Meta ${this.formatDecimal(kr.target, 1)}`);
    const metricLine = metricSegments.length ? metricSegments.join(' · ') : (kr.metric ? this.escapeHtml(kr.metric) : '');
    const confidence = Number.isFinite(kr.confidence)
      ? `<span class="okr-chip mini muted">Confianza ${this.formatDecimal(kr.confidence, 1)}</span>`
      : '';

    return `
      <div class="okr-kr-card">
        <div class="okr-kr-top">
          <span class="okr-kr-name">${this.escapeHtml(kr.name)}</span>
          <span class="okr-kr-progress" style="color:${this.getStatusColor(kr.status)};">${progress}</span>
        </div>
        ${metricLine ? `<div class="okr-kr-meta">${metricLine}</div>` : ''}
        <div class="okr-kr-footer">
          ${kr.owner ? `<span class="okr-chip mini muted">👤 ${this.escapeHtml(kr.owner)}</span>` : ''}
          <span class="okr-chip mini status status-${kr.status || 'on_track'}">${this.formatStatusLabel(kr.status)}</span>
          ${confidence}
        </div>
      </div>
    `;
  },
  renderKeyResults(objectives) {
    const listEl = this.elements.keyResults;
    if (!listEl) return;
    if (!this.state.objectives.length) {
      listEl.innerHTML = '';
      return;
    }
    if (!objectives.length) {
      listEl.innerHTML = `<div class="okr-empty-panel">No hay resultados clave para los filtros actuales.</div>`;
      return;
    }

    const keyResults = this.state.keyResults.filter(kr => this.lastFilteredIds.has(kr.objectiveId));
    if (!keyResults.length) {
      listEl.innerHTML = `<div class="okr-empty-panel">Agrega resultados clave para ver métricas de foco.</div>`;
      return;
    }

    const focusList = [...keyResults]
      .sort((a, b) => {
        const weight = (status) => {
          switch (status) {
            case 'off_track':
              return 0;
            case 'at_risk':
              return 1;
            case 'not_started':
              return 2;
            case 'on_track':
              return 3;
            case 'completed':
              return 4;
            default:
              return 5;
          }
        };
        const diff = weight(a.status) - weight(b.status);
        if (diff !== 0) return diff;
        const progressA = Number.isFinite(a.progress) ? a.progress : 101;
        const progressB = Number.isFinite(b.progress) ? b.progress : 101;
        return progressA - progressB;
      })
      .slice(0, 6);

    listEl.innerHTML = focusList.map((kr) => {
      const progress = Number.isFinite(kr.progress) ? `${this.formatDecimal(kr.progress, 0)}%` : '--';
      return `
        <div class="okr-kr-row">
          <div class="okr-row-top">
            <span class="okr-row-title">${this.escapeHtml(kr.name)}</span>
            <span class="okr-kr-progress">${progress}</span>
          </div>
          <div class="okr-row-meta">
            <span>${this.escapeHtml(kr.objectiveName)}</span>
            ${kr.owner ? `<span>👤 ${this.escapeHtml(kr.owner)}</span>` : ''}
            <span>${this.formatStatusLabel(kr.status)}</span>
            ${Number.isFinite(kr.confidence) ? `<span>Confianza ${this.formatDecimal(kr.confidence, 1)}</span>` : ''}
          </div>
        </div>
      `;
    }).join('');
  },
  renderInitiatives(objectives) {
    const container = this.elements.initiatives;
    if (!container) return;
    if (!this.state.objectives.length) {
      container.innerHTML = '';
      return;
    }
    if (!objectives.length) {
      container.innerHTML = `<div class="okr-empty-panel">No hay iniciativas para los filtros aplicados.</div>`;
      return;
    }
    const initiatives = this.state.initiatives.filter(init => this.lastFilteredIds.has(init.objectiveId));
    if (!initiatives.length) {
      container.innerHTML = `<div class="okr-empty-panel">Registra iniciativas con fechas objetivo para planificar.</div>`;
      return;
    }
    const sorted = initiatives
      .slice()
      .sort((a, b) => {
        if (a.due && b.due) return a.due - b.due;
        if (a.due) return -1;
        if (b.due) return 1;
        return a.title.localeCompare(b.title, 'es', { sensitivity: 'base' });
      })
      .slice(0, 6);

    container.innerHTML = sorted.map((init) => `
      <div class="okr-initiative-row">
        <div class="okr-row-top">
          <span class="okr-row-title">${this.escapeHtml(init.title)}</span>
          <span class="okr-chip mini status status-${init.status || 'not_started'}">${this.formatStatusLabel(init.status)}</span>
        </div>
        <div class="okr-row-meta">
          <span>Objetivo: ${this.escapeHtml(init.objectiveName)}</span>
          ${init.owner ? `<span>👤 ${this.escapeHtml(init.owner)}</span>` : ''}
          <span>${init.dueLabel ? `Fecha: ${this.escapeHtml(init.dueLabel)}` : 'Sin fecha'}</span>
        </div>
      </div>
    `).join('');
  },
  renderEmptyState() {
    if (!this.elements.container) return;
    this.toggleFilters(false);
    this.toggleInsights(false);
    if (this.elements.summary) {
      this.elements.summary.classList.remove('is-visible');
      this.elements.summary.innerHTML = '';
    }
    if (this.elements.objectives) {
      this.elements.objectives.innerHTML = `
        <div class="okr-empty">
          <h3>Importa tus OKR para empezar</h3>
          <p>Descarga la plantilla de Excel o arrastra tu archivo existente para visualizar objetivos, resultados clave e iniciativas.</p>
          <ul>
            <li>Una fila por Resultado Clave asociado a su Objetivo.</li>
            <li>Incluye columnas de métrica, meta, actual y confianza.</li>
            <li>Opcional: iniciativas, fecha objetivo, etiquetas y notas.</li>
          </ul>
        </div>
      `;
    }
    if (this.elements.keyResults) {
      this.elements.keyResults.innerHTML = `<div class="okr-empty-panel">Aquí verás los resultados clave que requieren atención.</div>`;
    }
    if (this.elements.initiatives) {
      this.elements.initiatives.innerHTML = `<div class="okr-empty-panel">Registra iniciativas para seguir los hitos críticos.</div>`;
    }
  },
  toggleFilters(visible) {
    if (this.elements.filters) {
      this.elements.filters.classList.toggle('is-active', Boolean(visible));
    }
  },
  toggleInsights(visible) {
    if (this.elements.insights) {
      this.elements.insights.classList.toggle('okr-hidden', !visible);
    }
  },
  showToast(message, type = 'info', duration = 3200) {
    if (typeof app !== 'undefined' && typeof app.showToast === 'function') {
      app.showToast(message, type, duration);
    } else {
      console.log(`[OKR] ${type.toUpperCase()}: ${message}`);
    }
  },
  downloadTemplate() {
    try {
      const headers = [
        'Ciclo',
        'Objetivo',
        'Dueño Objetivo',
        'Estado Objetivo',
        'Progreso Objetivo',
        'Resultado Clave',
        'Dueño RC',
        'Métrica',
        'Línea Base',
        'Meta',
        'Actual',
        'Confianza',
        'Estado RC',
        'Iniciativa',
        'Dueño Iniciativa',
        'Estado Iniciativa',
        'Fecha Objetivo',
        'Etiquetas',
        'Notas'
      ];
      const sample = [
        ['Q1 2026', 'Incrementar conversión web', 'Marketing', 'En curso', '35', 'Aumentar conversión del 1,8% al 2,5%', 'Camila Soto', '% conversión', '1.8', '2.5', '2.1', '6', 'Con riesgo', 'Optimizar flujo de compra', 'UX Team', 'En curso', '2026-02-15', 'Growth;Web', 'Prioridad mobile'],
        ['Q1 2026', 'Incrementar conversión web', '', '', '', 'Reducir tiempo de carga a 2s', 'TI', 'Segundos', '3.8', '2', '2.6', '7', 'En curso', 'Auditoría de performance', 'TI', 'En curso', '2026-01-30', 'Tecnología', ''],
        ['Q1 2026', 'Incrementar conversión web', '', '', '', 'Generar 300 leads vía referidos', 'Growth', 'Leads', '0', '300', '120', '5', 'En riesgo', 'Diseñar incentivos', 'Growth', 'Pendiente', '2026-03-10', 'Alianzas', '']
      ];
      const worksheet = XLSX.utils.aoa_to_sheet([headers, ...sample]);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'OKR');
      XLSX.writeFile(workbook, 'plantilla_OKR_visual.xlsx');
      this.showToast('Plantilla OKR descargada.', 'success', 2800);
    } catch (error) {
      console.error('[OKR] Error generando plantilla:', error);
      this.showToast('No se pudo generar la plantilla', 'error', 3200);
    }
  },
  loadDemoData() {
    try {
      const rows = this.buildDemoRows();
      const dataset = this.transformRows(rows, true);
      this.setData(dataset);
      this.showToast('Demo OKR cargada.', 'success', 2800);
    } catch (error) {
      console.error('[OKR] Error cargando demo:', error);
      this.showToast('No se pudo cargar la demo', 'error', 3200);
    }
  },
  buildDemoRows() {
    return [
      {
        objective: 'Incrementar conversión web',
        cycle: 'Q1 2026',
        objectiveOwner: 'Marketing',
        objectiveStatus: 'En curso',
        objectiveProgress: '35%',
        keyResult: 'Aumentar la tasa de conversión del 1,8% al 2,5%',
        krOwner: 'Camila Soto',
        krMetric: '% conversión',
        krBaseline: '1.8',
        krTarget: '2.5',
        krCurrent: '2.1',
        krConfidence: '6',
        krStatus: 'Con riesgo',
        initiatives: 'Optimizar flujo de compra;Validar mensajes clave',
        initiativeOwner: 'UX Team',
        initiativeStatus: 'En curso',
        initiativeDue: '2026-02-15',
        tags: 'Growth;Web',
        notes: 'Prioridad mobile'
      },
      {
        objective: 'Incrementar conversión web',
        cycle: 'Q1 2026',
        objectiveOwner: 'Marketing',
        keyResult: 'Reducir tiempo de carga promedio a 2 segundos',
        krOwner: 'Equipo TI',
        krMetric: 'Segundos / página',
        krBaseline: '3.8',
        krTarget: '2',
        krCurrent: '2.6',
        krConfidence: '7',
        krStatus: 'En curso',
        initiatives: 'Auditoría de performance;Implementar CDN',
        initiativeOwner: 'Equipo TI',
        initiativeStatus: 'En curso',
        initiativeDue: '2026-01-30',
        tags: 'Tecnología;Performance'
      },
      {
        objective: 'Incrementar conversión web',
        cycle: 'Q1 2026',
        objectiveOwner: 'Marketing',
        keyResult: 'Generar 300 leads nuevos vía programa de referidos',
        krOwner: 'Growth',
        krMetric: 'Leads',
        krTarget: '300',
        krCurrent: '120',
        krConfidence: '5',
        krStatus: 'Con riesgo',
        initiatives: 'Diseñar incentivos referidos',
        initiativeOwner: 'Growth',
        initiativeStatus: 'Pendiente',
        initiativeDue: '2026-03-10',
        tags: 'Alianzas'
      },
      {
        objective: 'Reducir churn de clientes enterprise',
        cycle: 'Q1 2026',
        objectiveOwner: 'Customer Success',
        objectiveStatus: 'Con riesgo',
        objectiveProgress: '48%',
        keyResult: 'Reducir el churn del 8% al 5%',
        krOwner: 'Ana Villar',
        krMetric: '% churn',
        krBaseline: '8',
        krTarget: '5',
        krCurrent: '6.1',
        krConfidence: '4',
        krStatus: 'Con riesgo',
        initiatives: 'Implementar programa de health checks',
        initiativeOwner: 'Customer Success',
        initiativeStatus: 'En curso',
        initiativeDue: '2026-02-05',
        tags: 'Retention;Clientes',
        notes: 'Enfoque en cuentas clave'
      },
      {
        objective: 'Reducir churn de clientes enterprise',
        cycle: 'Q1 2026',
        objectiveOwner: 'Customer Success',
        keyResult: 'Lograr NPS promedio de 45 puntos',
        krOwner: 'Equipo CX',
        krMetric: 'NPS',
        krBaseline: '32',
        krTarget: '45',
        krCurrent: '41',
        krConfidence: '7',
        krStatus: 'En curso',
        initiatives: 'Diseñar playbook de onboarding avanzado',
        initiativeOwner: 'Equipo CX',
        initiativeStatus: 'En curso',
        initiativeDue: '2026-02-20',
        tags: 'Experiencia'
      },
      {
        objective: 'Escalar plataforma de datos',
        cycle: 'Q1 2026',
        objectiveOwner: 'Tecnología',
        objectiveStatus: 'En curso',
        keyResult: 'Migrar 80% de cargas a arquitectura evento-driven',
        krOwner: 'Data Engineering',
        krMetric: '% workloads',
        krTarget: '80',
        krCurrent: '52',
        krConfidence: '8',
        krStatus: 'En curso',
        initiatives: 'Habilitar bus de eventos para facturación',
        initiativeOwner: 'Data Engineering',
        initiativeStatus: 'En curso',
        initiativeDue: '2026-02-28',
        tags: 'Plataforma;Data',
        alignment: 'Eficiencia operacional'
      }
    ];
  },
  formatNumber(value, options = {}) {
    const number = Number(value);
    if (!Number.isFinite(number)) return '0';
    return number.toLocaleString('es-ES', options);
  },
  formatDecimal(value, digits = 0) {
    const number = Number(value);
    if (!Number.isFinite(number)) return (digits === 0 ? '0' : Number(0).toFixed(digits));
    return number.toLocaleString('es-ES', { minimumFractionDigits: digits, maximumFractionDigits: digits });
  },
  escapeHtml(value) {
    if (value === null || value === undefined) return '';
    return String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
};

const app = new InventarioCompleto();

// ========================================
// BACKUP MANAGER - Sistema de backups por inactividad
// ========================================
const backupManager = {
  inactivityTimer: null,
  inactivityDelay: 60000, // 1 minuto (60,000 ms)
  hayCambiosPendientes: false,
  backupEnProgreso: false,
  ultimoBackupTimestamp: null,
  inactivityStartTime: null,
  countdownInterval: null,
  
  // Inicializar listeners de actividad
  init() {
    console.log('🔄 Backup Manager inicializado');
    
    // Eventos que detectan actividad del usuario
    const eventos = ['mousemove', 'mousedown', 'keypress', 'scroll', 'touchstart', 'click'];
    
    eventos.forEach(evento => {
      document.addEventListener(evento, () => this.reiniciarTimer(), { passive: true });
    });
    
    // Iniciar timer
    this.reiniciarTimer();
    
    // Actualizar UI cada segundo (para el countdown)
    setInterval(() => this.actualizarUI(), 1000);
    
    // Actualizar UI inicial
    setTimeout(() => this.actualizarUI(), 1000);
  },
  
  // Marcar que hay cambios pendientes de backup
  marcarCambiosPendientes() {
    console.log('📝 ===== CAMBIOS PENDIENTES MARCADOS =====');
    console.log('   El próximo backup se creará después de 1 minuto de inactividad');
    this.hayCambiosPendientes = true;
    this.actualizarUI();
  },
  
  // Reiniciar contador de inactividad
  reiniciarTimer() {
    // Cancelar timer anterior
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
    }
    
    // Marcar inicio de inactividad
    this.inactivityStartTime = Date.now();
    
    // Crear nuevo timer
    this.inactivityTimer = setTimeout(() => {
      this.ejecutarBackupSiNecesario();
    }, this.inactivityDelay);
  },
  
  // Ejecutar backup si hay cambios pendientes
  async ejecutarBackupSiNecesario() {
    console.log('\n⏱️ ===== TIMER EXPIRADO - Verificando condiciones para backup =====');
    console.log(`📊 Estado actual:`);
    console.log(`   - hayCambiosPendientes: ${this.hayCambiosPendientes}`);
    console.log(`   - backupEnProgreso: ${this.backupEnProgreso}`);
    console.log(`   - fsManager.isFileSystemMode: ${fsManager.isFileSystemMode}`);
    
    // Verificar condiciones
    if (!this.hayCambiosPendientes) {
      console.log('❌ BACKUP OMITIDO: No hay cambios pendientes');
      if (app && app.showToast) {
        app.showToast('ℹ️ No hay cambios para respaldar', 'info', 3000);
      }
      return;
    }
    
    if (this.backupEnProgreso) {
      console.log('❌ BACKUP OMITIDO: Ya hay un backup en progreso');
      return;
    }
    
    if (!fsManager.isFileSystemMode) {
      console.log('❌ BACKUP OMITIDO: FileSystem no activo');
      if (app && app.showToast) {
        app.showToast('⚠️ FileSystem no conectado - Backup omitido', 'warning', 3000);
      }
      return;
    }
    
    console.log('✅ TODAS LAS CONDICIONES CUMPLIDAS - Iniciando backup...');
    this.backupEnProgreso = true;
    
    // Mostrar barra de progreso
    this.mostrarBarraProgreso();
    
    try {
      // Crear backup con progreso
      await this.crearBackupConProgreso();
      
      // Marcar como completado
      this.hayCambiosPendientes = false;
      this.ultimoBackupTimestamp = Date.now();
      this.actualizarProgreso(100);
      this.actualizarUI();
      
      // Esperar un momento para que se vea el 100%
      await new Promise(resolve => setTimeout(resolve, 800));
      
      console.log('✅ Backup automático completado');
      app.showToast('✅ Backup automático creado', 'success', 3000);
      
    } catch (error) {
      console.error('❌ Error en backup automático:', error);
      app.showToast('⚠️ Error creando backup automático', 'error');
    } finally {
      this.backupEnProgreso = false;
      this.ocultarBarraProgreso();
    }
  },
  
  // Crear backup con reporte de progreso
  async crearBackupConProgreso() {
    if (!configuracion || typeof configuracion.crearBackupAutomatico !== 'function') {
      throw new Error('Función de backup no disponible');
    }
    
    // Simular progreso mientras se ejecuta el backup real
    const progresoSimulado = setInterval(() => {
      const barraFill = document.getElementById('backupProgressFill');
      if (barraFill) {
        const anchoActual = parseFloat(barraFill.style.width) || 0;
        if (anchoActual < 90) {
          this.actualizarProgreso(anchoActual + 10);
        }
      }
    }, 200);
    
    try {
      // Ejecutar backup real
      await configuracion.crearBackupAutomatico();
    } finally {
      clearInterval(progresoSimulado);
    }
  },
  
  // Mostrar barra de progreso
  mostrarBarraProgreso() {
    const barra = document.getElementById('backupProgressBar');
    if (barra) {
      barra.style.display = 'block';
      this.actualizarProgreso(0);
    }
  },
  
  // Ocultar barra de progreso
  ocultarBarraProgreso() {
    const barra = document.getElementById('backupProgressBar');
    if (barra) {
      setTimeout(() => {
        barra.style.display = 'none';
      }, 1000);
    }
  },
  
  // Actualizar progreso visual
  actualizarProgreso(porcentaje) {
    const fill = document.getElementById('backupProgressFill');
    const percent = document.getElementById('backupProgressPercent');
    
    if (fill) fill.style.width = `${porcentaje}%`;
    if (percent) percent.textContent = `${Math.round(porcentaje)}%`;
  },
  
  // Actualizar UI del panel de estado en configuración
  actualizarUI() {
    const statusIcon = document.getElementById('backupStatusIcon');
    const statusText = document.getElementById('backupStatusText');
    const lastTime = document.getElementById('backupLastTime');
    const nextTime = document.getElementById('backupNextTime');
    const pendingChanges = document.getElementById('backupPendingChanges');
    
    // Si los elementos no existen (usuario no está en configuración), salir
    if (!statusIcon || !statusText) return;
    
    // Estado del sistema
    if (!fsManager.isFileSystemMode) {
      statusIcon.textContent = '⚪';
      statusText.textContent = 'Sistema desactivado (FileSystem no conectado)';
      statusText.style.color = 'var(--text-secondary)';
      if (lastTime) lastTime.textContent = '---';
      if (nextTime) nextTime.textContent = '---';
      if (pendingChanges) pendingChanges.style.display = 'none';
      return;
    }
    
    if (this.backupEnProgreso) {
      statusIcon.textContent = '🔵';
      statusText.textContent = 'Creando backup...';
      statusText.style.color = 'var(--info)';
    } else if (this.hayCambiosPendientes) {
      statusIcon.textContent = '🟡';
      statusText.textContent = 'Cambios pendientes - Esperando inactividad';
      statusText.style.color = 'var(--warning)';
      if (pendingChanges) pendingChanges.style.display = 'block';
    } else {
      statusIcon.textContent = '🟢';
      statusText.textContent = 'Sistema activo - Todo respaldado';
      statusText.style.color = 'var(--success)';
      if (pendingChanges) pendingChanges.style.display = 'none';
    }
    
    // Último backup
    if (lastTime) {
      if (this.ultimoBackupTimestamp) {
        const minutos = Math.floor((Date.now() - this.ultimoBackupTimestamp) / 60000);
        if (minutos === 0) {
          lastTime.textContent = 'Hace menos de 1 min';
        } else if (minutos < 60) {
          lastTime.textContent = `Hace ${minutos} min`;
        } else {
          const horas = Math.floor(minutos / 60);
          lastTime.textContent = `Hace ${horas}h ${minutos % 60}min`;
        }
      } else {
        lastTime.textContent = 'Sin backups aún';
      }
    }
    
    // Contador de inactividad
    const countdown = document.getElementById('backupCountdown');
    if (countdown) {
      if (!fsManager.isFileSystemMode) {
        countdown.textContent = '---';
        countdown.style.color = 'var(--text-secondary)';
      } else if (this.backupEnProgreso) {
        countdown.textContent = 'Creando...';
        countdown.style.color = 'var(--info)';
      } else if (!this.hayCambiosPendientes) {
        // Sin cambios pendientes - mostrar estado inactivo
        countdown.textContent = 'Sin cambios';
        countdown.style.color = 'var(--text-secondary)';
      } else if (this.inactivityStartTime) {
        const tiempoTranscurrido = Date.now() - this.inactivityStartTime;
        const tiempoRestante = Math.max(0, this.inactivityDelay - tiempoTranscurrido);
        const segundosRestantes = Math.ceil(tiempoRestante / 1000);
        
        if (segundosRestantes <= 0) {
          countdown.textContent = '0:00';
          countdown.style.color = 'var(--warning)';
        } else {
          const mins = Math.floor(segundosRestantes / 60);
          const secs = segundosRestantes % 60;
          countdown.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
          
          // Cambiar color según tiempo restante
          if (segundosRestantes <= 10) {
            countdown.style.color = 'var(--error)';
          } else if (segundosRestantes <= 30) {
            countdown.style.color = 'var(--warning)';
          } else {
            countdown.style.color = 'var(--success)';
          }
        }
      } else {
        countdown.textContent = '1:00';
        countdown.style.color = 'var(--text-primary)';
      }
    }
    
    // Próximo backup
    if (nextTime) {
      if (this.hayCambiosPendientes) {
        nextTime.textContent = 'En inactividad (1 min)';
        nextTime.style.color = 'var(--warning)';
      } else {
        nextTime.textContent = 'Al detectar cambios';
        nextTime.style.color = 'var(--text-primary)';
      }
    }
  }
};

// ========================================
// OBJETO CONFIGURACION - Gestión centralizada
// ========================================
const configuracion = {
  // Renderizar UI de almacenamiento según plataforma
  renderStorageUI() {
    const container = document.getElementById('storage-config-content');
    const isMobile = app.isMobile;
    const hasFileSystem = app.hasFileSystemAPI;
    
    if (hasFileSystem) {
      // Verificar si hay carpeta guardada
      const hasSavedFolder = localStorage.getItem('fsDirectory') === 'enabled';
      
      // UI PARA PC
      container.innerHTML = `
        <h3 style="color: var(--text-primary); margin-bottom: 16px; font-size: 1.1rem; font-weight: 600;">Almacenamiento</h3>
        
        <div style="display: grid; gap: 12px;">
          <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; border: 1px solid var(--border-color);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <strong style="color: var(--text-primary); font-size: 0.95rem;">Estado:</strong>
              <span id="config-fs-status" style="padding: 6px 12px; border-radius: 6px; font-size: 0.85rem; font-weight: 600;">
                ${fsManager.isFileSystemMode ? '🟢 Conectado' : '❌ No conectado'}
              </span>
            </div>
            <div id="config-fs-path" style="color: var(--text-secondary); font-size: 0.85rem; font-family: monospace; padding: 10px; background: rgba(0,0,0,0.15); border-radius: 6px; min-height: 40px;">
              ${fsManager.folderPath || (hasSavedFolder ? 'Carpeta guardada (click Conectar)' : 'Sistema no configurado')}
            </div>
          </div>
          
          ${hasSavedFolder && !fsManager.isFileSystemMode ? `
            <!-- Botón Conectar cuando hay carpeta guardada pero no está conectado -->
            <button onclick="configuracion.conectarRapido()" class="btn btn-success" style="width: 100%; padding: 14px; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <span style="font-size: 1.2rem;">🔌</span>
              <span>Conectar</span>
            </button>
          ` : ''}
          
          ${fsManager.isFileSystemMode ? `
            <!-- Botón Desconectar cuando está conectado -->
            <button onclick="configuracion.desconectar()" class="btn" style="width: 100%; padding: 14px; font-size: 1rem; background: var(--danger); color: white; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <span style="font-size: 1.2rem;">🔴</span>
              <span>Desconectar</span>
            </button>
          ` : ''}
          
          <!-- Botón Cambiar Carpeta (siempre visible) -->
          <button onclick="configuracion.seleccionarCarpetaTrabajo()" class="btn ${fsManager.isFileSystemMode ? 'btn-secondary' : 'btn-primary'}" style="width: 100%; padding: ${fsManager.isFileSystemMode ? '12px' : '14px'}; font-size: ${fsManager.isFileSystemMode ? '0.9rem' : '1rem'};">
            ${fsManager.isFileSystemMode ? '📁 Cambiar Carpeta' : '📂 Seleccionar Carpeta'}
          </button>
          
          ${fsManager.isFileSystemMode ? `
            <button onclick="configuracion.vincularImagenesAutomaticamente()" class="btn btn-success" style="width: 100%; padding: 12px; font-size: 0.95rem;">
              🔗 Vincular Imágenes
            </button>
          ` : ''}
        </div>
      `;
    } else {
      // UI PARA MÓVIL
      container.innerHTML = `
        <h3 style="color: var(--text-primary); margin-bottom: 16px; font-size: 1.1rem; font-weight: 600;">Almacenamiento Móvil</h3>
        
        <div style="display: grid; gap: 12px;">
          <div id="mobile-storage-stats" style="background: var(--bg-primary); padding: 14px; border-radius: 8px; border: 1px solid var(--border-color);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <strong style="color: var(--text-primary); font-size: 0.95rem;">Almacenamiento:</strong>
              <span id="mobile-storage-size" style="padding: 6px 12px; background: var(--primary); color: white; border-radius: 6px; font-weight: 600; font-size: 0.85rem;">
                0 MB
              </span>
            </div>
            <div style="display: flex; justify-content: space-between; color: var(--text-secondary); font-size: 0.85rem;">
              <span>Imágenes:</span>
              <strong id="mobile-storage-count" style="color: var(--primary);">0</strong>
            </div>
          </div>
          
          <button onclick="configuracion.actualizarEstadisticasMovil()" class="btn btn-primary" style="width: 100%; padding: 12px; font-size: 0.95rem;">
            Actualizar Estadísticas
          </button>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <button onclick="configuracion.exportarJSONConImagenesMovil()" class="btn btn-success" style="padding: 12px; font-size: 0.85rem;">
              Exportar
            </button>
            <button onclick="configuracion.importarJSONConImagenesMovil()" class="btn btn-primary" style="padding: 12px; font-size: 0.85rem;">
              Importar
            </button>
          </div>
          
          <button onclick="configuracion.limpiarCacheMovil()" class="btn" style="width: 100%; padding: 12px; font-size: 0.9rem; background: var(--danger); color: white;">
            Limpiar Imágenes
          </button>
        </div>
      `;
      
      // Actualizar estadísticas automáticamente
      setTimeout(() => this.actualizarEstadisticasMovil(), 500);
    }
  },
  
  // Actualizar estadísticas de almacenamiento móvil
  async actualizarEstadisticasMovil() {
    try {
      const stats = await indexedDBManager.getStorageStats();
      document.getElementById('mobile-storage-size').textContent = stats.sizeFormatted;
      document.getElementById('mobile-storage-count').textContent = stats.count;
      
      console.log('📱 Estadísticas IndexedDB:', stats);
    } catch (error) {
      console.error('Error obteniendo estadísticas:', error);
    }
  },
  
  // Limpiar caché de imágenes móvil
  async limpiarCacheMovil() {
    const confirmacion = confirm(
      '⚠️ ADVERTENCIA\n\n' +
      'Esto eliminará TODAS las imágenes almacenadas en IndexedDB.\n' +
      'Los datos del inventario (nombres, códigos, etc.) NO se eliminarán.\n\n' +
      '¿Estás seguro de continuar?'
    );
    
    if (!confirmacion) return;
    
    try {
      await indexedDBManager.clearAll();
      await this.actualizarEstadisticasMovil();
      app.showToast('✅ Todas las imágenes eliminadas', 'success');
      
      // Recargar inventario para limpiar referencias
      await app.loadData();
      await app.render();
    } catch (error) {
      console.error('Error limpiando caché:', error);
      app.showToast('❌ Error al limpiar caché', 'error');
    }
  },
  
  // ===================================================================
  // SINCRONIZACIÓN PC ↔️ MÓVIL
  // ===================================================================
  
  // Exportar JSON con imágenes para móvil (incluye base64)
  async exportarJSONConImagenesMovil() {
    try {
      console.log('📤 Exportando inventario con imágenes embebidas...');
      
      const exportData = {
        version: '2.5-mobile',
        exportDate: new Date().toISOString(),
        platform: app.isMobile ? 'mobile' : 'desktop',
        storageMode: app.storageMode,
        repuestos: []
      };
      
      // Procesar cada repuesto y cargar sus imágenes
      for (const repuesto of app.repuestos) {
        const repuestoExport = { ...repuesto };
        
        // Si tiene multimedia, convertir a base64
        if (repuesto.multimedia && repuesto.multimedia.length > 0) {
          const multimediaBase64 = [];
          
          for (const media of repuesto.multimedia) {
            if (media.type === 'image') {
              // Si es IndexedDB ID, cargar y convertir
              if (media.isIndexedDB && media.url.startsWith('img_')) {
                try {
                  const imageData = await indexedDBManager.getImage(media.url);
                  if (imageData && imageData.url) {
                    // Convertir Blob URL a base64
                    const response = await fetch(imageData.url);
                    const blob = await response.blob();
                    const base64 = await this.blobToBase64(blob);
                    
                    multimediaBase64.push({
                      type: 'image',
                      url: base64,
                      name: media.name,
                      size: media.size
                    });
                  }
                } catch (err) {
                  console.error(`❌ Error convirtiendo imagen ${media.url}:`, err);
                }
              } 
              // Si ya es base64, mantener
              else if (typeof media.url === 'string' && media.url.startsWith('data:image')) {
                multimediaBase64.push(media);
              }
              // Si es FileSystem path, informar que no se puede exportar
              else if (media.isFileSystem) {
                console.warn(`⚠️ Imagen FileSystem no exportada: ${media.url}`);
              }
            }
          }
          
          repuestoExport.multimedia = multimediaBase64;
        }
        
        exportData.repuestos.push(repuestoExport);
      }
      
      const jsonString = JSON.stringify(exportData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
      
      // Descargar archivo
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inventario_movil_${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log(`✅ Exportado: ${exportData.repuestos.length} repuestos, ${sizeMB}MB`);
      app.showToast(`✅ Inventario exportado (${sizeMB}MB) con imágenes`, 'success');
    } catch (error) {
      console.error('Error exportando JSON con imágenes:', error);
      app.showToast('❌ Error al exportar: ' + error.message, 'error');
    }
  },
  
  // Importar JSON con imágenes para móvil
  async importarJSONConImagenesMovil() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        console.log('📥 Importando inventario con imágenes...');
        const text = await file.text();
        const data = JSON.parse(text);
        
        if (!data.repuestos || !Array.isArray(data.repuestos)) {
          throw new Error('Formato de JSON inválido');
        }
        
        // Obtener ruta iCloud predefinida (si existe)
        const icloudPath = this.getICloudPath();
        console.log(`☁️ Ruta iCloud configurada: ${icloudPath || 'Ninguna'}`);
        
        // Procesar cada repuesto e importar imágenes a IndexedDB
        for (const repuesto of data.repuestos) {
          if (repuesto.multimedia && repuesto.multimedia.length > 0) {
            const multimediaIndexedDB = [];
            
            for (const media of repuesto.multimedia) {
              if (media.type === 'image') {
                let imageBlob = null;
                let imageName = media.name || 'imagen.webp';
                
                // CASO 1: Imagen embebida en base64
                if (media.url && media.url.startsWith('data:image')) {
                  imageBlob = await this.base64ToBlob(media.url);
                  console.log(`✅ Imagen base64 embebida: ${imageName}`);
                }
                // CASO 2: Imagen NO embebida - intentar buscar en ruta iCloud
                else if (icloudPath && media.name) {
                  console.log(`🔍 Buscando imagen en iCloud: ${icloudPath}/${media.name}`);
                  
                  // NOTA: En iOS, no podemos acceder directamente a archivos por ruta
                  // Esta es una funcionalidad limitada - la imagen debe estar embebida
                  // o el usuario debe seleccionarla manualmente
                  console.warn(`⚠️ Imagen no embebida: ${media.name}`);
                  console.warn(`⚠️ iOS no permite acceso directo a carpetas`);
                  console.warn(`⚠️ Recomendación: Embeber imágenes en el JSON al exportar`);
                  
                  // Saltar esta imagen - no se puede cargar automáticamente en iOS
                  continue;
                }
                
                // Si tenemos un Blob, guardarlo en IndexedDB
                if (imageBlob) {
                  const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                  await indexedDBManager.saveImage(imageId, repuesto.id, imageBlob);
                  
                  multimediaIndexedDB.push({
                    type: 'image',
                    url: imageId,
                    name: imageName,
                    size: imageBlob.size,
                    isIndexedDB: true
                  });
                  
                  console.log(`✅ Imagen importada a IndexedDB: ${imageId}`);
                }
              }
            }
            
            repuesto.multimedia = multimediaIndexedDB;
          }
        }
        
        // Guardar en localStorage
        app.repuestos = data.repuestos;
        localStorage.setItem('repuestos', JSON.stringify(app.repuestos));
        
        // Actualizar UI
        await app.loadData();
        await app.render();
        await this.actualizarEstadisticasMovil();
        
        app.showToast(`✅ ${data.repuestos.length} repuestos importados`, 'success');
        console.log(`✅ Importación completada: ${data.repuestos.length} repuestos`);
      } catch (error) {
        console.error('Error importando JSON:', error);
        app.showToast('❌ Error al importar: ' + error.message, 'error');
      }
    };
    
    input.click();
  },
  
  // Convertir Blob a base64
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  },
  
  // Convertir base64 a Blob
  base64ToBlob(base64) {
    return new Promise((resolve) => {
      fetch(base64)
        .then(res => res.blob())
        .then(blob => resolve(blob));
    });
  },

  // 🔌 NUEVO: Conectar rápido usando carpeta guardada
  async conectarRapido() {
    try {
      console.log('🔌 Conexión rápida - usando carpeta guardada');
      await app.connectWorkspace(true, false); // isReconnect=true, promptUser=false (auto-reconexión)
      
      // Actualizar UI
      this.renderStorageUI();
    } catch (error) {
      console.error('Error en conexión rápida:', error);
      app.showToast('❌ Error al conectar. Intenta "Cambiar Carpeta".', 'error');
    }
  },

  // 🔴 NUEVO: Desconectar
  async desconectar() {
    const confirmar = confirm(
      '¿Desconectar carpeta INVENTARIO_STORAGE?\n\n' +
      'Los datos no se perderán, pero deberás reconectar para continuar trabajando.'
    );
    
    if (!confirmar) return;
    
    try {
      // Limpiar estado de FileSystem
      fsManager.isFileSystemMode = false;
      fsManager.directoryHandle = null;
      fsManager.imagesFolder = null;
      fsManager.folderPath = '';
      
      // NO eliminar localStorage para mantener sesión guardada
      // localStorage.removeItem('fsDirectory');
      
      // Limpiar mapStorage
      if (mapStorage) {
        mapStorage.initialized = false;
        mapStorage.isConnected = false;
      }
      
      // Actualizar badges
      app.updateAllConnectionBadges(false);
      
      // Actualizar UI
      this.renderStorageUI();
      
      app.showToast('🔴 Desconectado - Datos guardados', 'info');
      console.log('🔴 Sistema desconectado');
    } catch (error) {
      console.error('Error al desconectar:', error);
      app.showToast('❌ Error al desconectar', 'error');
    }
  },

  // Seleccionar carpeta de trabajo
  async seleccionarCarpetaTrabajo() {
    // 🔌 USAR MÉTODO CENTRALIZADO
    try {
      console.log(`📦 [DEBUG] Caché global ANTES de reconectar: ${globalBlobCache.size} entradas`);
      
      await app.connectWorkspace(false, true); // isReconnect=false, promptUser=true
      
      console.log(`📦 [DEBUG] Caché global DESPUÉS de conectar: ${globalBlobCache.size} entradas`);
    } catch (error) {
      console.error('Error seleccionando carpeta:', error);
      app.showToast('❌ Error al seleccionar carpeta', 'error');
    }
  },

  // Actualizar interfaz de estado
  actualizarEstadoUI() {
    console.log('🔄 actualizarEstadoUI llamado');
    console.log('   fsManager.isFileSystemMode:', fsManager.isFileSystemMode);
    console.log('   fsManager.folderPath:', fsManager.folderPath);
    
    // 🔥 NUEVO: Re-renderizar toda la UI para reflejar estado actual
    this.renderStorageUI();
  },

  // Exportar JSON a carpeta
  async exportarJSON() {
    if (!fsManager.isFileSystemMode) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }
    
    try {
      await app.exportarJSON();
      app.showToast('✅ JSON exportado correctamente a la carpeta', 'success');
    } catch (error) {
      console.error('Error exportando JSON:', error);
      app.showToast('❌ Error al exportar JSON', 'error');
    }
  },

  // Exportar Excel
  async exportarExcel() {
    try {
      await app.exportarExcel();
      app.showToast('✅ Excel exportado a Descargas', 'success');
    } catch (error) {
      console.error('Error exportando Excel:', error);
      app.showToast('❌ Error al exportar Excel', 'error');
    }
  },

  // Exportar JSON ligero (sin multimedia)
  async exportarJSONLigero() {
    try {
      const data = app.repuestos.map(r => {
        const { multimedia, ...resto } = r;
        return resto;
      });
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inventario_sin_imagenes_${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      app.showToast('✅ JSON ligero exportado a Descargas', 'success');
    } catch (error) {
      console.error('Error exportando JSON ligero:', error);
      app.showToast('❌ Error al exportar JSON ligero', 'error');
    }
  },

  // Importar JSON con fusión
  async importarJSONFusion() {
    if (!fsManager.isFileSystemMode) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }
    
    try {
      await app.importarJSON();
      app.showToast('✅ Datos fusionados correctamente', 'success');
    } catch (error) {
      console.error('Error importando JSON:', error);
      app.showToast('❌ Error al importar JSON', 'error');
    }
  },

  // Importar archivo externo
  async importarArchivoExterno() {
    const confirmacion = confirm(
      '⚠️ ADVERTENCIA\n\n' +
      'Esta acción REEMPLAZARÁ completamente el inventario actual.\n' +
      'Se perderán todos los datos y multimedia actuales.\n\n' +
      '¿Estás seguro de continuar?'
    );
    
    if (!confirmacion) return;
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        
        if (!Array.isArray(data)) {
          throw new Error('El archivo no contiene un array válido');
        }
        
        // Reemplazar datos
        app.repuestos = data.map((item, index) => {
          if (!item.id) {
            item.id = `repuesto-${Date.now()}-${index}`;
          }
          if (!item.multimedia || !Array.isArray(item.multimedia)) {
            item.multimedia = [];
          }
          return item;
        });
        
        // Guardar y renderizar
        await app.saveData();
        await app.render();
        app.renderFilters();
        app.updateAutocompleteData();
        
        app.showToast(`✅ ${data.length} repuestos importados correctamente`, 'success');
      } catch (error) {
        console.error('Error importando archivo:', error);
        app.showToast('❌ Error al importar archivo: ' + error.message, 'error');
      }
    };
    
    input.click();
  },

  // Convertir imágenes a WebP
  async convertirImagenesWebP() {
    if (!fsManager.isFileSystemMode || !fsManager.imagesFolder) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }
    
    const confirmacion = confirm(
      '⚡ CONVERSIÓN A WEBP\n\n' +
      'Se convertirán todas las imágenes JPG/PNG a formato WebP.\n' +
      'Los archivos originales se ELIMINARÁN después de la conversión.\n\n' +
      '¿Deseas continuar?'
    );
    
    if (!confirmacion) return;
    
    try {
      const statusDiv = document.getElementById('conversion-status');
      const progressText = document.getElementById('conversion-progress');
      const progressBar = document.getElementById('conversion-bar');
      
      statusDiv.style.display = 'block';
      
      // Obtener todas las imágenes de la carpeta
      const imagenes = [];
      for await (const entry of fsManager.imagesFolder.values()) {
        if (entry.kind === 'file') {
          const name = entry.name.toLowerCase();
          if (name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png')) {
            imagenes.push(entry);
          }
        }
      }
      
      if (imagenes.length === 0) {
        app.showToast('ℹ️ No se encontraron imágenes JPG/PNG para convertir', 'info');
        statusDiv.style.display = 'none';
        return;
      }
      
      progressText.textContent = `0 / ${imagenes.length}`;
      let convertidas = 0;
      
      for (const fileHandle of imagenes) {
        try {
          const file = await fileHandle.getFile();
          
          // Cargar imagen
          const img = new Image();
          const blob = await file;
          const url = URL.createObjectURL(blob);
          
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            img.src = url;
          });
          
          // Convertir a WebP
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          
          const webpBlob = await new Promise(resolve => {
            canvas.toBlob(resolve, 'image/webp', 0.85);
          });
          
          URL.revokeObjectURL(url);
          
          // Guardar WebP
          const newName = file.name.replace(/\.(jpg|jpeg|png)$/i, '.webp');
          const newFileHandle = await fsManager.imagesFolder.getFileHandle(newName, { create: true });
          const writable = await newFileHandle.createWritable();
          await writable.write(webpBlob);
          await writable.close();
          
          // Eliminar original
          await fsManager.imagesFolder.removeEntry(file.name);
          
          // Actualizar referencias en el inventario
          app.repuestos.forEach(repuesto => {
            if (repuesto.multimedia && Array.isArray(repuesto.multimedia)) {
              repuesto.multimedia.forEach(media => {
                if (media.url && media.url.includes(file.name)) {
                  media.url = media.url.replace(/\.(jpg|jpeg|png)$/i, '.webp');
                  media.name = media.name ? media.name.replace(/\.(jpg|jpeg|png)$/i, '.webp') : newName;
                }
              });
            }
          });
          
          convertidas++;
          progressText.textContent = `${convertidas} / ${imagenes.length}`;
          progressBar.style.width = `${(convertidas / imagenes.length) * 100}%`;
          
          console.log(`✅ Convertido: ${file.name} → ${newName}`);
        } catch (error) {
          console.error(`❌ Error convirtiendo ${fileHandle.name}:`, error);
        }
      }
      
      // Guardar cambios en el inventario
      await app.saveData();
      
      app.showToast(`✅ ${convertidas} imágenes convertidas a WebP`, 'success');
      
      setTimeout(() => {
        statusDiv.style.display = 'none';
        progressBar.style.width = '0%';
      }, 3000);
      
    } catch (error) {
      console.error('Error en conversión WebP:', error);
      app.showToast('❌ Error durante la conversión', 'error');
    }
  },

  // Ver estadísticas de almacenamiento
  async verEstadisticasAlmacenamiento() {
    if (!fsManager.isFileSystemMode || !fsManager.imagesFolder) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }
    
    try {
      let totalImagenes = 0;
      let totalTamano = 0;
      const formatos = {};
      
      for await (const entry of fsManager.imagesFolder.values()) {
        if (entry.kind === 'file') {
          totalImagenes++;
          const file = await entry.getFile();
          totalTamano += file.size;
          
          const ext = file.name.split('.').pop().toLowerCase();
          formatos[ext] = (formatos[ext] || 0) + 1;
        }
      }
      
      const tamanoMB = (totalTamano / (1024 * 1024)).toFixed(2);
      
      // 📂 OBTENER RUTAS COMPLETAS
      let carpetaNombre = localStorage.getItem('fsFolderName') || 'INVENTARIO_PORTABLE';
      
      // 🔧 CORREGIR: Si tiene /INVENTARIO_STORAGE, quitarlo (solo queremos el nombre de la carpeta base)
      if (carpetaNombre.includes('INVENTARIO_STORAGE')) {
        carpetaNombre = carpetaNombre.split('/')[0].split('\\')[0];
      }
      
      const rutaBase = `📁 Carpeta base: ${carpetaNombre}`;
      const rutaStorage = `📁 Storage: ${carpetaNombre}/INVENTARIO_STORAGE`;
      const rutaImagenes = `📁 Imágenes: ${carpetaNombre}/INVENTARIO_STORAGE/imagenes/`;
      const rutaJSON = `📄 JSON: ${carpetaNombre}/INVENTARIO_STORAGE/inventario.json`;
      
      // 🔍 VERIFICAR LOCALSTORAGE
      const localStorageData = localStorage.getItem('inventarioData');
      let localStorageMB = 0;
      let imagenesBase64 = 0;
      
      if (localStorageData) {
        localStorageMB = (new Blob([localStorageData]).size / (1024 * 1024)).toFixed(2);
        const data = JSON.parse(localStorageData);
        data.forEach(item => {
          if (item.multimedia && item.multimedia.length > 0) {
            item.multimedia.forEach(media => {
              if (media.url && media.url.startsWith('data:image')) {
                imagenesBase64++;
              }
            });
          }
        });
      }
      
      let mensaje = `📊 ESTADÍSTICAS DE ALMACENAMIENTO\n\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `️ RUTAS ACTIVAS:\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `${rutaBase}\n`;
      mensaje += `${rutaStorage}\n`;
      mensaje += `${rutaImagenes}\n`;
      mensaje += `${rutaJSON}\n\n`;
      
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `📸 IMÁGENES EN FILESYSTEM:\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `📁 Total de archivos: ${totalImagenes}\n`;
      mensaje += `💾 Espacio ocupado: ${tamanoMB} MB\n`;
      mensaje += `🎨 Sin límites de almacenamiento\n\n`;
      
      mensaje += ` Por formato:\n`;
      for (const [ext, count] of Object.entries(formatos)) {
        mensaje += `  • ${ext.toUpperCase()}: ${count} archivos\n`;
      }
      
      mensaje += `\n═════════════════════════════════════\n`;
      mensaje += `📦 REPUESTOS:\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `✅ Con imágenes: ${app.repuestos.filter(r => r.multimedia && r.multimedia.length > 0).length}\n`;
      mensaje += `⚪ Sin imágenes: ${app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0).length}\n`;
      mensaje += `📊 Total: ${app.repuestos.length}\n\n`;
      
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `💾 LOCALSTORAGE (Solo datos):\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `📊 Tamaño: ${localStorageMB} MB\n`;
      mensaje += `❌ Imágenes base64 obsoletas: ${imagenesBase64}\n`;
      mensaje += `${imagenesBase64 === 0 ? '✅ LIMPIO - Solo guarda nombres/precios/cantidades' : '⚠️ Usar botón "Limpiar Imágenes localStorage"'}\n\n`;
      
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `✨ RESUMEN:\n`;
      mensaje += `═════════════════════════════════════\n`;
      mensaje += `✅ Todas las referencias desde: ${carpetaNombre}\n`;
      mensaje += `✅ Imágenes: FileSystem (sin límites)\n`;
      mensaje += `✅ Datos: JSON + localStorage (backup)\n`;
      mensaje += `✅ Sin referencias externas\n`;
      
      // Construir HTML del modal (REEMPLAZANDO ALERT)
      let html = `
        <!-- Sección Rutas -->
        <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--primary);">
          <h3 style="margin: 0 0 16px 0; color: var(--primary); display: flex; align-items: center; gap: 10px; font-size: 1.3rem;">
            <span style="font-size: 1.5rem;">🗂️</span>
            <span>Rutas Activas</span>
          </h3>
          <div style="display: grid; gap: 12px; font-size: 0.9rem;">
            
            <!-- Carpeta Base -->
            <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; border-left: 4px solid var(--primary);">
              <div style="display: flex; align-items: start; gap: 12px;">
                <span style="font-size: 1.8rem;">📁</span>
                <div style="flex: 1;">
                  <strong style="color: var(--primary); font-size: 1.05rem;">Carpeta Base</strong>
                  <div style="font-family: 'Courier New', monospace; color: var(--text-primary); margin: 6px 0; background: rgba(59, 130, 246, 0.1); padding: 8px 12px; border-radius: 4px;">
                    ${carpetaNombre}
                  </div>
                  <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.5; margin-top: 8px;">
                    💡 <strong>Carpeta principal del proyecto.</strong> Contiene el archivo HTML de la aplicación y la carpeta INVENTARIO_STORAGE. Es portable: puedes copiarla a cualquier ubicación (PC, USB, disco externo).
                  </div>
                </div>
              </div>
            </div>

            <!-- Storage -->
            <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; border-left: 4px solid var(--info);">
              <div style="display: flex; align-items: start; gap: 12px;">
                <span style="font-size: 1.8rem;">🗄️</span>
                <div style="flex: 1;">
                  <strong style="color: var(--info); font-size: 1.05rem;">Carpeta Storage</strong>
                  <div style="font-family: 'Courier New', monospace; color: var(--text-primary); margin: 6px 0; background: rgba(59, 130, 246, 0.1); padding: 8px 12px; border-radius: 4px;">
                    ${carpetaNombre}/INVENTARIO_STORAGE
                  </div>
                  <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.5; margin-top: 8px;">
                    💡 <strong>Almacenamiento central de datos.</strong> Contiene el archivo JSON con toda la información de repuestos (nombres, precios, cantidades, etc.) y la carpeta de imágenes. Se crea automáticamente al seleccionar la carpeta base.
                  </div>
                </div>
              </div>
            </div>

            <!-- Imágenes -->
            <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; border-left: 4px solid var(--success);">
              <div style="display: flex; align-items: start; gap: 12px;">
                <span style="font-size: 1.8rem;">🖼️</span>
                <div style="flex: 1;">
                  <strong style="color: var(--success); font-size: 1.05rem;">Carpeta Imágenes</strong>
                  <div style="font-family: 'Courier New', monospace; color: var(--text-primary); margin: 6px 0; background: rgba(16, 185, 129, 0.1); padding: 8px 12px; border-radius: 4px;">
                    ${carpetaNombre}/INVENTARIO_STORAGE/imagenes/
                  </div>
                  <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.5; margin-top: 8px;">
                    💡 <strong>Todas las fotos de repuestos.</strong> Almacenamiento ilimitado usando FileSystem Access API. Las imágenes se guardan como archivos físicos (JPG, PNG, WebP). El sistema solo guarda las rutas en el JSON, no las imágenes en base64.
                  </div>
                </div>
              </div>
            </div>

            <!-- JSON -->
            <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; border-left: 4px solid var(--warning);">
              <div style="display: flex; align-items: start; gap: 12px;">
                <span style="font-size: 1.8rem;">📄</span>
                <div style="flex: 1;">
                  <strong style="color: var(--warning); font-size: 1.05rem;">Archivo JSON Principal</strong>
                  <div style="font-family: 'Courier New', monospace; color: var(--text-primary); margin: 6px 0; background: rgba(245, 158, 11, 0.1); padding: 8px 12px; border-radius: 4px;">
                    ${carpetaNombre}/INVENTARIO_STORAGE/inventario.json
                  </div>
                  <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.5; margin-top: 8px;">
                    💡 <strong>Base de datos completa del inventario.</strong> Contiene: nombres, códigos SAP, categorías, áreas, equipos, cantidades, stock mínimo, precios, historial de conteos y rutas a las imágenes. Se actualiza automáticamente cada vez que guardas cambios.
                  </div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- Grid 2 columnas -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
          
          <!-- Imágenes FileSystem -->
          <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.1)); padding: 20px; border-radius: 12px; border: 2px solid var(--success);">
            <h3 style="margin: 0 0 16px 0; color: var(--success); display: flex; align-items: center; gap: 10px; font-size: 1.2rem;">
              <span style="font-size: 1.4rem;">📸</span>
              <span>Imágenes FileSystem</span>
            </h3>
            
            <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; margin-bottom: 14px;">
              <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6;">
                💡 <strong>Almacenamiento ilimitado.</strong> Las imágenes se guardan como archivos físicos en tu disco. No hay límites de tamaño o cantidad. Solo se guardan las rutas en el JSON.
              </div>
            </div>
            
            <div style="display: grid; gap: 12px;">
              <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${totalImagenes}</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">Total de archivos</div>
                <div style="font-size: 0.75rem; color: var(--success); font-weight: 600;">∞ Sin límites</div>
              </div>
              
              <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                <div style="font-size: 2rem; font-weight: 700; color: var(--info);">${tamanoMB} MB</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">Espacio ocupado</div>
                <div style="font-size: 0.75rem; color: var(--info);">Archivos físicos en disco</div>
              </div>
              
              <div style="background: linear-gradient(135deg, var(--success), #059669); color: white; padding: 12px; border-radius: 8px; text-align: center; font-weight: 600; font-size: 0.95rem;">
                <div style="font-size: 1.5rem; margin-bottom: 4px;">🚀</div>
                <div>Capacidad ilimitada</div>
                <div style="font-size: 0.75rem; opacity: 0.9; margin-top: 4px;">FileSystem Access API</div>
              </div>
            </div>
            
            ${Object.keys(formatos).length > 0 ? `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
              <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 10px;">Por formato:</div>
              <div style="display: grid; gap: 8px;">
                ${Object.entries(formatos).map(([ext, count]) => `
                  <div style="display: flex; justify-content: space-between; background: var(--bg-primary); padding: 8px 12px; border-radius: 6px;">
                    <span style="color: var(--text-primary); font-weight: 500;">${ext.toUpperCase()}</span>
                    <span style="color: var(--success); font-weight: 700;">${count} archivos</span>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
          </div>

          <!-- Repuestos -->
          <div style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(124, 58, 237, 0.1)); padding: 20px; border-radius: 12px; border: 2px solid var(--secondary);">
            <h3 style="margin: 0 0 16px 0; color: var(--secondary); display: flex; align-items: center; gap: 10px; font-size: 1.2rem;">
              <span style="font-size: 1.4rem;">📦</span>
              <span>Repuestos en Inventario</span>
            </h3>
            
            <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; margin-bottom: 14px;">
              <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6;">
                💡 <strong>Productos registrados en el sistema.</strong> Cada repuesto tiene: nombre, código SAP, categoría, área, equipo, cantidad actual, stock mínimo, precio e historial de conteos.
              </div>
            </div>
            
            <div style="display: grid; gap: 12px;">
              <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${app.repuestos.filter(r => r.multimedia && r.multimedia.length > 0).length}</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">✅ Con imágenes</div>
                <div style="font-size: 0.75rem; color: var(--success);">Totalmente identificados</div>
              </div>
              
              <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                <div style="font-size: 2rem; font-weight: 700; color: ${app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0).length > 0 ? 'var(--warning)' : 'var(--success)'};">${app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0).length}</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">📷 Sin imágenes</div>
                ${app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0).length > 0 ? `
                  <div style="font-size: 0.75rem; color: var(--warning);">Pendientes de fotografiar</div>
                ` : `
                  <div style="font-size: 0.75rem; color: var(--success);">Todos tienen fotos</div>
                `}
              </div>
              
              <div style="background: linear-gradient(135deg, var(--secondary), var(--primary)); color: white; padding: 14px; border-radius: 8px; text-align: center;">
                <div style="font-size: 2rem; font-weight: 700;">${app.repuestos.length}</div>
                <div style="font-size: 0.85rem; margin-bottom: 4px;">📊 Total registrados</div>
                <div style="font-size: 0.75rem; opacity: 0.9;">En inventario completo</div>
              </div>
              
              ${app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0).length > 0 ? `
                <div style="background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 6px; border-left: 4px solid var(--warning);">
                  <div style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5;">
                    💡 <strong>Tip:</strong> Usa el botón <strong>"Vincular Imágenes de la Carpeta"</strong> en Configuración para asociar automáticamente las fotos con los repuestos.
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
        </div>

        <!-- localStorage -->
        <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid ${imagenesBase64 === 0 ? 'var(--success)' : 'var(--warning)'};">
          <h3 style="margin: 0 0 16px 0; color: ${imagenesBase64 === 0 ? 'var(--success)' : 'var(--warning)'}; display: flex; align-items: center; gap: 10px; font-size: 1.2rem;">
            <span style="font-size: 1.4rem;">💾</span>
            <span>localStorage (Backup del navegador)</span>
          </h3>
          
          <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
            <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
              💡 <strong>Copia de seguridad automática en el navegador.</strong> Guarda una copia de los datos (nombres, códigos, precios, cantidades) como respaldo. Límite: 5-10 MB. <strong>NO debe contener imágenes</strong> para evitar saturar el espacio.
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
            <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; text-align: center;">
              <div style="font-size: 1.8rem; font-weight: 700; color: var(--info);">${localStorageMB} MB</div>
              <div style="font-size: 0.85rem; color: var(--text-secondary);">Tamaño usado</div>
              <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">Límite: ~10 MB</div>
            </div>
            
            <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; text-align: center;">
              <div style="font-size: 1.8rem; font-weight: 700; color: ${imagenesBase64 === 0 ? 'var(--success)' : 'var(--danger)'};">${imagenesBase64}</div>
              <div style="font-size: 0.85rem; color: var(--text-secondary);">Imágenes base64</div>
              <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">Debe ser: 0</div>
            </div>
            
            <div style="background: ${imagenesBase64 === 0 ? 'var(--success)' : 'var(--warning)'}; color: white; padding: 14px; border-radius: 8px; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 600; font-size: 0.95rem;">
              <div style="font-size: 1.8rem; margin-bottom: 6px;">${imagenesBase64 === 0 ? '✅' : '⚠️'}</div>
              <div>${imagenesBase64 === 0 ? 'LIMPIO' : 'Necesita limpieza'}</div>
            </div>
          </div>
          
          ${imagenesBase64 === 0 ? `
            <div style="margin-top: 12px; padding: 14px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; border-left: 4px solid var(--success);">
              <div style="color: var(--success); font-weight: 600; margin-bottom: 6px;">✅ Estado óptimo</div>
              <div style="color: var(--text-secondary); font-size: 0.85rem;">
                Solo contiene datos esenciales (nombres, precios, cantidades). Las imágenes se cargan desde FileSystem, dejando el localStorage libre para su función de backup.
              </div>
            </div>
          ` : `
            <div style="margin-top: 12px; padding: 14px; background: rgba(199, 83, 0, 0.15); border-radius: 8px; border-left: 4px solid #C75300;">
              <div style="color: #C75300; font-weight: 600; margin-bottom: 6px;">⚠️ Requiere limpieza</div>
              <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 8px;">
                Contiene ${imagenesBase64} imágenes base64 obsoletas que ocupan espacio innecesario.
              </div>
              <div style="background: #334155; padding: 10px; border-radius: 6px; font-size: 0.85rem; color: #cbd5e1; border: 1px solid #475569;">
                <strong style="color: #e2e8f0;">👉 Solución:</strong> Ve a <strong style="color: #C75300;">Configuración → Herramientas Adicionales → Limpiar Imágenes localStorage</strong>
              </div>
            </div>
          `}
        </div>

        <!-- Resumen Final -->
        <div style="background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white; padding: 24px; border-radius: 12px; text-align: center;">
          <h3 style="margin: 0 0 16px 0; font-size: 1.4rem; display: flex; align-items: center; justify-content: center; gap: 10px;">
            <span style="font-size: 1.6rem;">✨</span>
            <span>Resumen</span>
          </h3>
          
          <div style="display: grid; gap: 10px; text-align: left; font-size: 1rem;">
            <div style="display: flex; align-items: center; gap: 10px;">
              <span style="font-size: 1.4rem;">✅</span>
              <span>Todas las referencias desde: <strong>${carpetaNombre}</strong></span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span style="font-size: 1.4rem;">✅</span>
              <span>Imágenes: <strong>FileSystem (sin límites)</strong></span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span style="font-size: 1.4rem;">✅</span>
              <span>Datos: <strong>JSON + localStorage (backup)</strong></span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span style="font-size: 1.4rem;">✅</span>
              <span>Sin referencias externas</span>
            </div>
          </div>
        </div>
      `;
      
      // Mostrar modal en lugar de alert
      document.getElementById('estadisticasContent').innerHTML = html;
      document.getElementById('modalEstadisticas').style.display = 'block';
      
    } catch (error) {
      console.error('Error obteniendo estadísticas:', error);
      app.showToast('❌ Error al obtener estadísticas', 'error');
    }
  },

  // Limpiar caché temporal
  async limpiarCacheTemporal() {
    const confirmacion = confirm(
      '🧹 LIMPIAR CACHÉ\n\n' +
      'Se eliminarán los datos temporales y caché del navegador.\n' +
      'Los datos del inventario NO se verán afectados.\n\n' +
      '¿Continuar?'
    );
    
    if (!confirmacion) return;
    
    try {
      // Limpiar localStorage temporal (mantener inventario)
      const inventarioBackup = localStorage.getItem('inventarioData');
      const fsBackup = localStorage.getItem('fsDirectory');
      const folderBackup = localStorage.getItem('fsFolderName');
      
      localStorage.clear();
      
      if (inventarioBackup) localStorage.setItem('inventarioData', inventarioBackup);
      if (fsBackup) localStorage.setItem('fsDirectory', fsBackup);
      if (folderBackup) localStorage.setItem('fsFolderName', folderBackup);
      
      app.showToast('✅ Caché limpiado correctamente', 'success');
    } catch (error) {
      console.error('Error limpiando caché:', error);
      app.showToast('❌ Error al limpiar caché', 'error');
    }
  },

  // Limpiar imágenes base64 del localStorage
  async limpiarImagenesLocalStorage() {
    const confirmacion = confirm(
      '🧹 LIMPIAR IMÁGENES DE LOCALSTORAGE\n\n' +
      'Se eliminarán todas las imágenes base64 almacenadas en localStorage.\n' +
      'Esto liberará espacio y evitará conflictos.\n\n' +
      '⚠️ Los datos de repuestos NO se borrarán (nombres, precios, cantidades)\n' +
      '⚠️ Las imágenes de FileSystem NO se verán afectadas\n\n' +
      '¿Continuar?'
    );
    
    if (!confirmacion) return;
    
    try {
      const localData = localStorage.getItem('inventarioData');
      
      if (!localData) {
        app.showToast('ℹ️ No hay datos en localStorage', 'info');
        return;
      }
      
      const data = JSON.parse(localData);
      let imagenesEliminadas = 0;
      let tamañoAntesKB = new Blob([localData]).size / 1024;
      
      // Limpiar imágenes base64 de cada repuesto
      data.forEach(item => {
        if (item.multimedia && item.multimedia.length > 0) {
          const multimediaLimpia = item.multimedia.filter(media => {
            const esBase64 = media.url && media.url.startsWith('data:image');
            if (esBase64) {
              imagenesEliminadas++;
              console.log(`🧹 Eliminada imagen base64 de: ${item.nombre}`);
            }
            return !esBase64; // Mantener solo rutas de FileSystem
          });
          
          item.multimedia = multimediaLimpia;
        }
      });
      
      // Guardar datos limpios
      const datosLimpios = JSON.stringify(data);
      localStorage.setItem('inventarioData', datosLimpios);
      
      const tamañoDespuesKB = new Blob([datosLimpios]).size / 1024;
      const espacioLiberadoKB = tamañoAntesKB - tamañoDespuesKB;
      
      const mensaje = 
        `✅ Limpieza completada:\n\n` +
        `🧹 ${imagenesEliminadas} imágenes base64 eliminadas\n` +
        `📦 Tamaño anterior: ${tamañoAntesKB.toFixed(2)} KB\n` +
        `📦 Tamaño actual: ${tamañoDespuesKB.toFixed(2)} KB\n` +
        `💾 Espacio liberado: ${espacioLiberadoKB.toFixed(2)} KB\n\n` +
        `💡 Ahora solo se usan imágenes de FileSystem (sin límites)`;
      
      alert(mensaje);
      app.showToast(`🎉 ${imagenesEliminadas} imágenes eliminadas - ${espacioLiberadoKB.toFixed(0)} KB liberados`, 'success');
      
    } catch (error) {
      console.error('Error limpiando localStorage:', error);
      app.showToast('❌ Error al limpiar localStorage: ' + error.message, 'error');
    }
  },

  // Vincular automáticamente las imágenes de la carpeta a los repuestos
  async vincularImagenesAutomaticamente() {
    if (!fsManager.isFileSystemMode || !fsManager.imagesFolder) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return;
    }
    
    const confirmacion = confirm(
      '� REPARAR Y VINCULAR IMÁGENES\n\n' +
      'Esta función hará lo siguiente:\n\n' +
      '✅ Detectar imágenes rotas (archivos que ya no existen)\n' +
      '✅ Buscar reemplazos automáticos por nombre\n' +
      '✅ Vincular repuestos sin imágenes\n' +
      '✅ Usa timestamps para encontrar las versiones más recientes\n\n' +
      '💡 INTELIGENTE: Busca coincidencias por nombre del repuesto\n\n' +
      '¿Continuar?'
    );
    
    if (!confirmacion) return;
    
    try {
      app.showToast('� Reparando y vinculando imágenes...', 'info');
      
      // Usar la nueva función de reparación inteligente
      await app.repararImagenesRotas();
      
    } catch (error) {
      console.error('❌ Error:', error);
      app.showToast('❌ Error: ' + error.message, 'error');
    }
  },

  // ===================================================================
  // EXPORTAR HTML CON DATOS EMBEBIDOS (PARA SINCRONIZACIÓN MÓVIL)
  // ===================================================================
  
  async exportarHTMLConDatosEmbebidos() {
    try {
      console.log('📱 Exportando HTML con datos embebidos para móvil...');
      
      // 1. Obtener datos actuales SIN multimedia
      const datosParaMovil = app.repuestos.map(repuesto => {
        const { multimedia, ...repuestoSinMultimedia } = repuesto;
        return repuestoSinMultimedia;
      });
      
      console.log(`📦 Preparando ${datosParaMovil.length} repuestos para móvil (sin imágenes)`);
      
      // 2. Leer el archivo HTML actual
      const response = await fetch(window.location.href);
      let htmlContent = await response.text();
      
      // 3. Crear el objeto EMBEDDED_DATA actualizado
      const embeddedDataString = `const EMBEDDED_DATA = {
  version: '1.0-mobile',
  lastUpdate: '${new Date().toISOString()}',
  platform: 'mobile-embedded',
  note: 'Datos sin multimedia - Solo texto y números para máxima compatibilidad',
  repuestos: ${JSON.stringify(datosParaMovil, null, 2)}
};`;
      
      // 4. Reemplazar el EMBEDDED_DATA en el HTML
      const regex = /const EMBEDDED_DATA = \{[\s\S]*?\};/;
      if (regex.test(htmlContent)) {
        htmlContent = htmlContent.replace(regex, embeddedDataString);
        console.log('✅ EMBEDDED_DATA reemplazado correctamente');
      } else {
        console.error('❌ No se encontró EMBEDDED_DATA en el HTML');
        app.showToast('❌ Error: No se encontró EMBEDDED_DATA', 'error');
        return;
      }
      
      // 5. Crear Blob y descargar
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `inventario_MOVIL_${new Date().toISOString().split('T')[0]}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      const mensaje = 
        `✅ HTML para móvil exportado:\n\n` +
        `📱 ${datosParaMovil.length} repuestos incluidos\n` +
        `📦 Tamaño: ${sizeMB} MB\n` +
        `📅 Fecha: ${new Date().toLocaleString('es-ES')}\n\n` +
        `🔄 Para sincronizar:\n` +
        `1. Copia este HTML al móvil\n` +
        `2. Ábrelo en Edge iOS\n` +
        `3. ¡Listo! Verás todos los datos actualizados\n\n` +
        `💡 Las fotos NO se incluyen (solo datos)`;
      
      alert(mensaje);
      app.showToast(`📱 HTML móvil exportado: ${datosParaMovil.length} repuestos`, 'success');
      
    } catch (error) {
      console.error('Error exportando HTML:', error);
      app.showToast('❌ Error al exportar HTML: ' + error.message, 'error');
    }
  },

  // ===================================================================
  // CONFIGURACIÓN DE RUTA ICLOUD DRIVE (PARA IPHONE)
  // ===================================================================
  
  // Guardar ruta predefinida de iCloud Drive
  saveICloudPath(path) {
    if (!path || path.trim() === '') {
      app.showToast('⚠️ Por favor ingresa un nombre de carpeta', 'warning');
      return;
    }
    
    const cleanPath = path.trim();
    localStorage.setItem('icloudImagePath', cleanPath);
    
    // Mostrar confirmación
    const statusDiv = document.getElementById('icloud-path-status');
    if (statusDiv) {
      statusDiv.style.display = 'block';
      statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
      statusDiv.style.borderLeft = '4px solid var(--success)';
      statusDiv.style.color = 'var(--success)';
      statusDiv.innerHTML = `
        <strong>✅ Ruta guardada:</strong><br>
        <code style="background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 4px; font-size: 0.9rem;">
          iCloud Drive/${cleanPath}/
        </code>
      `;
      
      // Ocultar después de 5 segundos
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }
    
    app.showToast(`✅ Ruta iCloud guardada: ${cleanPath}`, 'success');
    console.log(`☁️ Ruta iCloud configurada: ${cleanPath}`);
  },
  
  // Borrar ruta predefinida de iCloud Drive
  clearICloudPath() {
    localStorage.removeItem('icloudImagePath');
    
    const input = document.getElementById('icloudImagePath');
    if (input) {
      input.value = '';
    }
    
    const statusDiv = document.getElementById('icloud-path-status');
    if (statusDiv) {
      statusDiv.style.display = 'block';
      statusDiv.style.background = 'rgba(220, 38, 38, 0.1)';
      statusDiv.style.borderLeft = '4px solid var(--danger)';
      statusDiv.style.color = 'var(--danger)';
      statusDiv.innerHTML = `<strong>🗑️ Ruta eliminada</strong>`;
      
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 3000);
    }
    
    app.showToast('🗑️ Ruta iCloud eliminada', 'info');
    console.log('☁️ Ruta iCloud borrada');
  },
  
  // Obtener ruta predefinida de iCloud Drive
  getICloudPath() {
    return localStorage.getItem('icloudImagePath') || null;
  },
  
  // Cargar configuración de ruta iCloud en el input
  loadICloudPathConfig() {
    const savedPath = this.getICloudPath();
    const input = document.getElementById('icloudImagePath');
    
    if (input && savedPath) {
      input.value = savedPath;
      console.log(`☁️ Ruta iCloud cargada: ${savedPath}`);
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // 🔄 SISTEMA DE BACKUP COMPLETO AUTOMÁTICO (TODO incluido)
  // ═══════════════════════════════════════════════════════════════════
  
  async crearBackupAutomatico() {
    if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
      console.log('⚠️ Backup automático omitido: No hay FileSystem activo');
      return null;
    }

    try {
      console.log('🔄 Creando backup completo automático...');
      
      // 1. Obtener/crear carpeta de backups
      const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: true });
      const automaticosDir = await backupsDir.getDirectoryHandle('automaticos', { create: true });
      
      // 2. Obtener lista de backups existentes (ahora son CARPETAS)
      const backups = [];
      for await (const entry of automaticosDir.values()) {
        if (entry.kind === 'directory' && entry.name.startsWith('backup_')) {
          try {
            // Intentar leer datos.json para obtener timestamp
            const datosHandle = await entry.getDirectoryHandle().then(dir => dir.getFileHandle('datos.json', { create: false }));
            const file = await datosHandle.getFile();
            backups.push({
              name: entry.name,
              handle: entry,
              timestamp: file.lastModified
            });
          } catch (e) {
            // Si no tiene datos.json, es un backup corrupto - usar nombre de carpeta
            console.warn(`⚠️ Backup sin datos.json: ${entry.name}`);
            backups.push({
              name: entry.name,
              handle: entry,
              timestamp: 0 // Lo marcamos como muy antiguo para eliminarlo
            });
          }
        }
      }
      
      // 3. Ordenar por fecha (más antiguo primero)
      backups.sort((a, b) => a.timestamp - b.timestamp);
      
      // 4. Eliminar backups antiguos si hay 5 o más (ahora solo elimina la CARPETA completa)
      while (backups.length >= 5) {
        const antiguo = backups.shift();
        try {
          await automaticosDir.removeEntry(antiguo.name, { recursive: true });
          console.log(`🗑️ Backup completo eliminado: ${antiguo.name}`);
        } catch (e) {
          console.warn(`⚠️ No se pudo eliminar backup: ${antiguo.name}`, e);
        }
      }
      
      // 5. Crear timestamp para el nuevo backup
      const ahora = new Date();
      const anio = ahora.getFullYear();
      const mes = String(ahora.getMonth() + 1).padStart(2, '0');
      const dia = String(ahora.getDate()).padStart(2, '0');
      const hora = String(ahora.getHours()).padStart(2, '0');
      const minutos = String(ahora.getMinutes()).padStart(2, '0');
      const segundos = String(ahora.getSeconds()).padStart(2, '0');
      const timestamp = `${anio}-${mes}-${dia}_${hora}-${minutos}-${segundos}`;
      const backupFolderName = `backup_${timestamp}`;
      
      // 6. Crear carpeta del backup
      const backupDir = await automaticosDir.getDirectoryHandle(backupFolderName, { create: true });
      console.log(`📁 Carpeta de backup creada: ${backupFolderName}`);
      
      // 7. Obtener mapas y áreas si existen
      let mapas = [];
      let areas = [];
      let totalMapas = 0;
      let totalAreas = 0;
      
      if (mapStorage && mapStorage.initialized) {
        try {
          mapas = await mapStorage.getMaps();
          areas = await mapStorage.getAreas();
          totalMapas = mapas.length;
          totalAreas = areas.length;
        } catch (error) {
          console.warn('⚠️ No se pudieron cargar mapas/áreas:', error);
        }
      }
      
      // 8. Contar ubicaciones de repuestos en mapas
      let totalUbicaciones = 0;
      app.repuestos.forEach(r => {
        if (r.ubicaciones && Array.isArray(r.ubicaciones)) {
          totalUbicaciones += r.ubicaciones.length;
        }
      });
      
      // 9. Recopilar lista de imágenes USADAS (no copiar huérfanas)
      const imagenesUsadas = new Set();
      app.repuestos.forEach(r => {
        if (r.imagen) {
          // Extraer nombre de archivo de la ruta
          const nombreImg = r.imagen.split('/').pop();
          imagenesUsadas.add(nombreImg);
        }
        if (r.multimedia && Array.isArray(r.multimedia)) {
          r.multimedia.forEach(media => {
            if (media.url) {
              const nombreImg = media.url.split('/').pop();
              imagenesUsadas.add(nombreImg);
            }
          });
        }
      });
      
      const totalImagenes = imagenesUsadas.size;
      
      // 10. Crear backup completo con TODO
      const data = {
        timestamp: new Date().toISOString(),
        version: '5.3.2',
        tipo: 'BACKUP_COMPLETO',
        
        // Estadísticas
        estadisticas: {
          totalRepuestos: app.repuestos.length,
          totalMapas: totalMapas,
          totalAreas: totalAreas,
          totalUbicacionesEnMapas: totalUbicaciones,
          totalImagenes: totalImagenes
        },
        
        // Datos completos
        repuestos: app.repuestos,
        mapas: mapas,
        areas: areas,
        
        // Metadata adicional
        metadata: {
          navegador: navigator.userAgent,
          plataforma: navigator.platform,
          idioma: navigator.language
        }
      };
      
      // 11. Guardar datos.json dentro de la carpeta del backup
      const datosHandle = await backupDir.getFileHandle('datos.json', { create: true });
      const writable = await datosHandle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      console.log(`✅ datos.json creado`);
      
      // 12. COPIAR SOLO IMÁGENES USADAS al backup
      let imagenesCopied = 0;
      try {
        if (imagenesUsadas.size > 0) {
          // Crear subcarpeta imagenes/ dentro del backup
          const backupImgDir = await backupDir.getDirectoryHandle('imagenes', { create: true });
          
          // Obtener carpeta de imágenes original
          const imagenesDir = await fsManager.directoryHandle.getDirectoryHandle('imagenes', { create: false });
          
          // Copiar SOLO las imágenes que están siendo usadas
          for (const nombreImagen of imagenesUsadas) {
            try {
              const originalHandle = await imagenesDir.getFileHandle(nombreImagen, { create: false });
              const originalFile = await originalHandle.getFile();
              
              const backupFileHandle = await backupImgDir.getFileHandle(nombreImagen, { create: true });
              const backupWritable = await backupFileHandle.createWritable();
              await backupWritable.write(await originalFile.arrayBuffer());
              await backupWritable.close();
              
              imagenesCopied++;
            } catch (imgError) {
              console.warn(`⚠️ No se pudo copiar imagen: ${nombreImagen}`, imgError);
            }
          }
          
          console.log(`📸 ${imagenesCopied}/${imagenesUsadas.size} imágenes copiadas al backup`);
        } else {
          console.log(`ℹ️ No hay imágenes para respaldar`);
        }
        
      } catch (imgError) {
        console.warn('⚠️ Error al copiar imágenes:', imgError);
        console.log('ℹ️ El backup de datos se creó correctamente, pero sin imágenes');
      }
      
      console.log(`✅ Backup COMPLETO creado en: ${backupFolderName}/`);
      console.log(`📊 Contenido: ${data.estadisticas.totalRepuestos} repuestos, ${totalMapas} mapas, ${totalAreas} áreas`);
      console.log(`📊 Imágenes: ${imagenesCopied} archivos copiados`);
      console.log(`📊 Total de backups: ${backups.length + 1}/5`);
      
      return backupFolderName; // Devolver nombre de la carpeta creada
      
    } catch (error) {
      console.error('❌ Error creando backup automático:', error);
      return null;
    }
  },

  // Listar backups completos disponibles
  async listarBackups() {
    if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta', 'warning');
      return [];
    }

    try {
      const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: true });
      const automaticosDir = await backupsDir.getDirectoryHandle('automaticos', { create: true });
      
      const backups = [];
      for await (const entry of automaticosDir.values()) {
        // Ahora buscamos CARPETAS que empiecen con backup_
        if (entry.kind === 'directory' && entry.name.startsWith('backup_')) {
          try {
            // Leer datos.json de dentro de la carpeta
            const backupDir = await automaticosDir.getDirectoryHandle(entry.name);
            const datosHandle = await backupDir.getFileHandle('datos.json', { create: false });
            const file = await datosHandle.getFile();
            const data = JSON.parse(await file.text());
            
            // Extraer estadísticas del backup completo
            const stats = data.estadisticas || {};
            
            backups.push({
              name: entry.name,
              handle: backupDir, // 🔧 FIX: Usar backupDir en lugar de entry
              timestamp: file.lastModified,
              fecha: new Date(file.lastModified).toLocaleString('es-ES'),
              size: (file.size / 1024).toFixed(2) + ' KB',
              
              // Datos completos
              totalRepuestos: stats.totalRepuestos || data.totalRepuestos || data.repuestos?.length || 0,
              totalMapas: stats.totalMapas || 0,
              totalAreas: stats.totalAreas || 0,
              totalUbicaciones: stats.totalUbicacionesEnMapas || 0,
              totalImagenes: stats.totalImagenes || 0,
              
              version: data.version || 'N/A',
              tipo: data.tipo || 'BACKUP'
            });
          } catch (e) {
            console.warn(`⚠️ No se pudo leer backup: ${entry.name}`, e);
          }
        }
      }
      
      // Ordenar por fecha (más reciente primero)
      backups.sort((a, b) => b.timestamp - a.timestamp);
      
      return backups;
      
    } catch (error) {
      console.error('❌ Error listando backups:', error);
      return [];
    }
  },

  // Restaurar desde backup completo
  async restaurarBackup(backupHandle) {
    try {
      // backupHandle ahora es un DirectoryHandle de la carpeta backup_TIMESTAMP
      const backupDir = backupHandle; // 🔧 FIX: Usar directamente el handle recibido
      
      // Leer datos.json de dentro de la carpeta
      const datosHandle = await backupDir.getFileHandle('datos.json', { create: false });
      const file = await datosHandle.getFile();
      const data = JSON.parse(await file.text());
      
      // 🔍 DEBUG: Ver qué trae el backup
      console.log('🔍 DATOS DEL BACKUP:', {
        totalRepuestos: data.repuestos?.length || 0,
        totalMapas: data.mapas?.length || 0,
        totalAreas: data.areas?.length || 0,
        estadisticas: data.estadisticas
      });
      
      // Contar ubicaciones en el backup
      let ubicacionesEnBackup = 0;
      if (data.repuestos) {
        data.repuestos.forEach(r => {
          if (r.ubicaciones && Array.isArray(r.ubicaciones)) {
            const validas = r.ubicaciones.filter(ub => 
              ub.mapId && ub.markerX !== undefined && ub.markerY !== undefined
            );
            if (validas.length > 0) {
              console.log(`🔍 BACKUP: "${r.nombre}" -> ${validas.length} ubicaciones`, validas);
            }
            ubicacionesEnBackup += validas.length;
          }
        });
      }
      console.log(`🔍 TOTAL ubicaciones en backup: ${ubicacionesEnBackup}`);
      
      const stats = data.estadisticas || {};
      
      const confirmacion = confirm(
        `🔄 RESTAURAR BACKUP COMPLETO\n\n` +
        `� Backup: ${backupHandle.name}\n` +
        `�📅 Fecha: ${new Date(file.lastModified).toLocaleString('es-ES')}\n` +
        `📦 Repuestos: ${stats.totalRepuestos || data.repuestos?.length || 0}\n` +
        `🗺️ Mapas: ${stats.totalMapas || 0}\n` +
        `📍 Áreas: ${stats.totalAreas || 0}\n` +
        `📌 Ubicaciones en mapas: ${stats.totalUbicaciones || 0}\n` +
        `🖼️ Imágenes: ${stats.totalImagenes || 0}\n` +
        `📊 Versión: ${data.version || 'N/A'}\n\n` +
        `⚠️ Esto reemplazará TODOS los datos actuales (repuestos, mapas, áreas, imágenes).\n\n` +
        `¿Continuar con la restauración completa?`
      );
      
      if (!confirmacion) return;
      
      // Restaurar repuestos
      app.repuestos = data.repuestos || [];
      
      // 🔍 DEBUG: Contar ubicaciones ANTES de guardar
      let ubicacionesAntesSave = 0;
      app.repuestos.forEach(r => {
        if (r.ubicaciones && Array.isArray(r.ubicaciones)) {
          const ubicValidas = r.ubicaciones.filter(ub => 
            ub.mapId && ub.markerX !== undefined && ub.markerY !== undefined
          );
          if (ubicValidas.length > 0) {
            console.log(`📍 Repuesto "${r.nombre}" tiene ${ubicValidas.length} ubicaciones:`, ubicValidas);
          }
          ubicacionesAntesSave += ubicValidas.length;
        }
      });
      console.log(`🔍 ANTES de saveData(): ${ubicacionesAntesSave} ubicaciones en repuestos`);
      
      await app.saveData();
      
      // 🔍 DEBUG: Contar ubicaciones DESPUÉS de guardar
      let ubicacionesDespuesSave = 0;
      app.repuestos.forEach(r => {
        if (r.ubicaciones && Array.isArray(r.ubicaciones)) {
          const ubicValidas = r.ubicaciones.filter(ub => 
            ub.mapId && ub.markerX !== undefined && ub.markerY !== undefined
          );
          ubicacionesDespuesSave += ubicValidas.length;
        }
      });
      console.log(`🔍 DESPUÉS de saveData(): ${ubicacionesDespuesSave} ubicaciones en repuestos`);
      
      // Restaurar mapas y áreas si existen
      if (mapStorage && mapStorage.initialized) {
        if (data.mapas && Array.isArray(data.mapas)) {
          await mapStorage.saveMaps(data.mapas, { action: 'restore_backup', detail: 'Restauración desde backup' });
          console.log(`📍 ${data.mapas.length} mapas restaurados`);
        }
        
        if (data.areas && Array.isArray(data.areas)) {
          await mapStorage.saveAreas(data.areas, { action: 'restore_backup', detail: 'Restauración desde backup' });
          console.log(`📍 ${data.areas.length} áreas restauradas`);
        }
      }
      
      // RESTAURAR IMÁGENES desde la subcarpeta imagenes/ del backup
      let imagenesRestauradas = 0;
      try {
        // Intentar obtener subcarpeta imagenes/ del backup
        const backupImgDir = await backupDir.getDirectoryHandle('imagenes', { create: false });
        
        // Obtener/crear carpeta de imágenes destino
        const imagenesDir = await fsManager.directoryHandle.getDirectoryHandle('imagenes', { create: true });
        
        // Copiar todas las imágenes del backup a la carpeta actual
        for await (const entry of backupImgDir.values()) {
          if (entry.kind === 'file') {
            try {
              const backupFile = await entry.getFile();
              const destFileHandle = await imagenesDir.getFileHandle(entry.name, { create: true });
              const destWritable = await destFileHandle.createWritable();
              await destWritable.write(await backupFile.arrayBuffer());
              await destWritable.close();
              imagenesRestauradas++;
            } catch (imgError) {
              console.warn(`⚠️ No se pudo restaurar imagen: ${entry.name}`, imgError);
            }
          }
        }
        
        console.log(`📸 ${imagenesRestauradas} imágenes restauradas`);
      } catch (imgError) {
        console.warn('⚠️ No se pudieron restaurar las imágenes:', imgError);
        console.log('ℹ️ El backup de datos se restauró correctamente, pero sin imágenes');
      }
      
      await app.render();
      app.renderFilters();
      app.updateAutocompleteData();
      
      // 🔧 FIX: Recargar mapas en el controlador después de restaurar
      if (mapController && typeof mapController.loadData === 'function') {
        await mapController.loadData({ force: true });
        console.log('🗺️ Mapas recargados en el controlador');
      }
      
      // 📊 Contar ubicaciones reales restauradas
      let ubicacionesRestauradas = 0;
      app.repuestos.forEach(r => {
        if (r.ubicaciones && Array.isArray(r.ubicaciones)) {
          ubicacionesRestauradas += r.ubicaciones.filter(ub => 
            ub.mapId && ub.markerX !== undefined && ub.markerY !== undefined
          ).length;
        }
      });
      
      const mensaje = `✅ Backup completo restaurado:\n` +
        `• ${stats.totalRepuestos || 0} repuestos\n` +
        `• ${stats.totalMapas || 0} mapas\n` +
        `• ${stats.totalAreas || 0} áreas\n` +
        `• ${ubicacionesRestauradas} ubicaciones en mapas\n` +
        `• ${imagenesRestauradas} imágenes restauradas`;
      
      app.showToast(mensaje, 'success', 8000);
      
    } catch (error) {
      console.error('❌ Error restaurando backup:', error);
      app.showToast('❌ Error al restaurar backup: ' + error.message, 'error');
    }
  },

  // Función auxiliar para mostrar modal de detalles
  mostrarModal(contenidoHTML) {
    const modal = document.getElementById('modalDetalles');
    const contenido = document.getElementById('modalDetallesContenido');
    
    if (!modal || !contenido) {
      console.error('❌ Modal de detalles no encontrado');
      return false;
    }
    
    contenido.innerHTML = contenidoHTML;
    modal.style.display = 'block';
    return true;
  },

  // Función auxiliar para cerrar modal de detalles
  cerrarModal() {
    const modal = document.getElementById('modalDetalles');
    if (modal) {
      modal.style.display = 'none';
    }
  },

  // Descargar último ZIP al navegador (Downloads)
  async descargarUltimoZip(filename) {
    try {
      const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: false });
      const zipDir = await backupsDir.getDirectoryHandle('zip', { create: false });
      
      const fileHandle = await zipDir.getFileHandle(filename, { create: false });
      const file = await fileHandle.getFile();
      
      // Crear link de descarga
      const url = URL.createObjectURL(file);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      app.showToast(`💾 Descargando ${filename} a la carpeta Downloads del navegador...`, 'success', 4000);
      this.cerrarModal();
      
    } catch (error) {
      console.error('Error descargando ZIP:', error);
      app.showToast('❌ Error al descargar el archivo ZIP', 'error');
    }
  },

  // Mostrar barra de progreso para PDF
  mostrarProgresoPDF(porcentaje, mensaje) {
    const modal = document.getElementById('modalDetalles');
    const contenido = document.getElementById('modalDetallesContenido');
    
    if (!modal || !contenido) return;
    
    const html = `
      <div class="modal-content" style="max-width: 500px; text-align: center;">
        <h3 style="margin: 0 0 20px 0; color: #2c3e50; display: flex; align-items: center; gap: 10px; justify-content: center;">
          <span style="font-size: 32px;">📄</span>
          <span>Generando PDF</span>
        </h3>
        
        <div style="margin: 20px 0;">
          <div style="font-size: 48px; font-weight: bold; color: #2196F3; margin-bottom: 10px;">
            ${Math.round(porcentaje)}%
          </div>
          <div style="color: #666; font-size: 14px; margin-bottom: 20px;">
            ${mensaje}
          </div>
        </div>
        
        <div style="width: 100%; height: 30px; background: #e0e0e0; border-radius: 15px; overflow: hidden; position: relative;">
          <div style="height: 100%; background: linear-gradient(90deg, #2196F3, #1976D2); width: ${porcentaje}%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center;">
            <span style="color: white; font-size: 12px; font-weight: bold; position: absolute; width: 100%; text-align: center;">
              ${Math.round(porcentaje)}%
            </span>
          </div>
        </div>
        
        <div style="margin-top: 20px; padding: 12px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #2196F3;">
          <p style="margin: 0; font-size: 13px; color: #0d47a1;">
            ⏳ Por favor espera... Este proceso puede tardar varios minutos dependiendo de la cantidad de repuestos e imágenes.
          </p>
        </div>
      </div>
    `;
    
    contenido.innerHTML = html;
    modal.style.display = 'flex';
  },

  // Mostrar modal de gestión de backups
  async mostrarGestionBackups() {
    const backups = await this.listarBackups();
    
    let html = `
      <div style="max-height: 400px; overflow-y: auto;">
        <h3 style="margin: 0 0 16px 0; color: var(--primary);">
          🔄 Historial de Backups (${backups.length}/5)
        </h3>
    `;
    
    if (backups.length === 0) {
      html += `
        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
          <div style="font-size: 3rem; margin-bottom: 16px;">📭</div>
          <p>No hay backups disponibles</p>
          <p style="font-size: 0.9rem; margin-top: 8px;">
            Los backups se crean automáticamente al guardar cambios
          </p>
        </div>
      `;
    } else {
      backups.forEach((backup, index) => {
        html += `
          <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid var(--primary);">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
              <div style="flex: 1;">
                <strong style="color: var(--text-primary);">${backup.name}</strong>
                <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 4px;">
                  📅 ${backup.fecha}
                </div>
              </div>
              <span style="background: var(--primary); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; white-space: nowrap;">
                ${index === 0 ? '🌟 Reciente' : `#${index + 1}`}
              </span>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 10px; font-size: 0.8rem;">
              <div style="background: rgba(59, 130, 246, 0.1); padding: 6px; border-radius: 4px; text-align: center;">
                <div style="color: var(--text-secondary); font-size: 0.7rem;">📦 Repuestos</div>
                <div style="color: var(--primary); font-weight: 600;">${backup.totalRepuestos}</div>
              </div>
              <div style="background: rgba(16, 185, 129, 0.1); padding: 6px; border-radius: 4px; text-align: center;">
                <div style="color: var(--text-secondary); font-size: 0.7rem;">🗺️ Mapas</div>
                <div style="color: #10b981; font-weight: 600;">${backup.totalMapas}</div>
              </div>
              <div style="background: rgba(245, 158, 11, 0.1); padding: 6px; border-radius: 4px; text-align: center;">
                <div style="color: var(--text-secondary); font-size: 0.7rem;">📍 Áreas</div>
                <div style="color: #f59e0b; font-weight: 600;">${backup.totalAreas}</div>
              </div>
              <div style="background: rgba(139, 92, 246, 0.1); padding: 6px; border-radius: 4px; text-align: center;">
                <div style="color: var(--text-secondary); font-size: 0.7rem;">📌 Ubicaciones</div>
                <div style="color: #8b5cf6; font-weight: 600;">${backup.totalUbicaciones}</div>
              </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 10px;">
              <span>💾 ${backup.size}</span>
              <span>🖼️ ${backup.totalImagenes} imágenes</span>
              <span>📊 v${backup.version}</span>
            </div>
            
            <button onclick="configuracion.restaurarBackupPorIndice(${index})" 
                    class="btn btn-primary" 
                    style="width: 100%; padding: 10px; font-size: 0.9rem;">
              🔄 Restaurar Este Backup Completo
            </button>
          </div>
        `;
      });
    }
    
    html += `
      </div>
      <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--border-color);">
        <button onclick="configuracion.crearBackupManual()" 
                class="btn btn-success" 
                style="width: 100%; padding: 12px;">
          💾 Crear Backup Manual Ahora
        </button>
      </div>
    `;
    
    this.mostrarModal(html);
  },

  // Crear backup manual
  async crearBackupManual() {
    const backupName = await this.crearBackupAutomatico();
    
    if (backupName) {
      const rutaBackup = `INVENTARIO_STORAGE/backups/automaticos/${backupName}`;
      
      // Obtener estadísticas del último backup
      const backups = await this.listarBackups();
      const ultimoBackup = backups[0]; // El más reciente
      
      // Mostrar modal con información del backup
      const html = `
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 3rem; margin-bottom: 16px;">✅</div>
          <h3 style="color: var(--success); margin-bottom: 16px;">Backup Completo Creado</h3>
          
          <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; margin: 20px 0; text-align: left;">
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">📁 Ruta:</strong>
              <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; margin-top: 6px; font-family: monospace; font-size: 0.85rem; color: var(--primary); word-break: break-all;">
                ${rutaBackup}
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">📅 Fecha:</strong>
              <div style="color: var(--text-secondary); margin-top: 4px;">
                ${new Date().toLocaleString('es-ES')}
              </div>
            </div>
            
            ${ultimoBackup ? `
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
              <strong style="color: var(--text-primary); display: block; margin-bottom: 12px;">📊 Contenido del Backup:</strong>
              
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                <div style="background: rgba(59, 130, 246, 0.15); padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 4px;">📦 Repuestos</div>
                  <div style="color: var(--primary); font-weight: 700; font-size: 1.2rem;">${ultimoBackup.totalRepuestos}</div>
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.15); padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 4px;">🗺️ Mapas</div>
                  <div style="color: #10b981; font-weight: 700; font-size: 1.2rem;">${ultimoBackup.totalMapas}</div>
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.15); padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 4px;">📍 Áreas</div>
                  <div style="color: #f59e0b; font-weight: 700; font-size: 1.2rem;">${ultimoBackup.totalAreas}</div>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.15); padding: 10px; border-radius: 6px; text-align: center;">
                  <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 4px;">📌 Ubicaciones</div>
                  <div style="color: #8b5cf6; font-weight: 700; font-size: 1.2rem;">${ultimoBackup.totalUbicaciones}</div>
                </div>
              </div>
              
              <div style="margin-top: 10px; text-align: center; font-size: 0.85rem; color: var(--text-secondary);">
                🖼️ ${ultimoBackup.totalImagenes} imágenes • 💾 ${ultimoBackup.size}
              </div>
            </div>
            ` : ''}
          </div>
          
          <div style="display: grid; gap: 10px; margin-top: 20px;">
            <button onclick="configuracion.abrirCarpetaBackups()" class="btn btn-primary" style="width: 100%; padding: 12px;">
              📂 Ir a Ver Carpeta de Backups
            </button>
            
            <button onclick="configuracion.cerrarModal()" class="btn btn-secondary" style="width: 100%; padding: 12px;">
              Cerrar
            </button>
          </div>
        </div>
      `;
      
      this.mostrarModal(html);
    } else {
      app.showToast('⚠️ No se pudo crear el backup. Verifica que FileSystem esté conectado.', 'warning');
    }
  },

  // Abrir carpeta de backups en el explorador de archivos
  async abrirCarpetaBackups() {
    try {
      if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
        app.showToast('⚠️ FileSystem no está activo', 'warning');
        return;
      }

      // Obtener la ruta de la carpeta base
      const carpetaBase = fsManager.directoryHandle.name || 'INVENTARIO_STORAGE';
      const rutaCompleta = `${carpetaBase}\\backups\\automaticos`;
      
      // Mostrar modal con instrucciones detalladas
      const html = `
        <div class="modal-content" style="max-width: 500px;">
          <h3 style="margin: 0 0 20px 0; color: #2c3e50; display: flex; align-items: center; gap: 10px;">
            📂 <span>Ubicación de Backups Automáticos</span>
          </h3>
          
          <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <p style="margin: 0 0 10px 0; font-weight: bold; color: #495057;">Ruta completa:</p>
            <code style="display: block; padding: 10px; background: white; border: 1px solid #dee2e6; border-radius: 4px; word-break: break-all; font-size: 13px;">
              ${rutaCompleta}
            </code>
          </div>
          
          <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
            <p style="margin: 0 0 10px 0; font-weight: bold; color: #1976D2;">💡 ¿Cómo llegar?</p>
            <ol style="margin: 0; padding-left: 20px; color: #495057; font-size: 14px;">
              <li>Abre el Explorador de Archivos (Windows + E)</li>
              <li>Navega a la carpeta donde está INVENTARIO_STORAGE</li>
              <li>Entra en: <strong>backups → automaticos</strong></li>
            </ol>
          </div>
          
          <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #ffc107;">
            <p style="margin: 0; font-size: 13px; color: #856404;">
              ⚠️ <strong>Nota:</strong> Por seguridad, los navegadores no permiten abrir carpetas automáticamente.
              Debes navegar manualmente usando el Explorador de Archivos.
            </p>
          </div>
          
          <div style="margin-top: 20px;">
            <button onclick="configuracion.cerrarModal()" class="btn btn-primary" style="width: 100%; padding: 12px;">
              Entendido
            </button>
          </div>
        </div>
      `;
      
      this.mostrarModal(html);
      
    } catch (error) {
      console.error('Error:', error);
      app.showToast('⚠️ Navega manualmente a: INVENTARIO_STORAGE\\backups\\automaticos', 'warning', 5000);
    }
  },

  // Variable temporal para almacenar lista de backups
  _backupsCache: [],

  async restaurarBackupPorIndice(index) {
    const backups = await this.listarBackups();
    if (backups[index]) {
      await this.restaurarBackup(backups[index].handle);
      this.cerrarModal();
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // 📄 EXPORTACIÓN A PDF CON JERARQUÍAS Y FOTOS
  // ═══════════════════════════════════════════════════════════════════
  
  mostrarOpcionesPDF() {
    const html = `
      <div class="modal-content" style="max-width: 600px;">
        <h3 style="margin: 0 0 20px 0; color: #2c3e50;">📄 Exportar Inventario a PDF</h3>
        
        <div style="display: flex; flex-direction: column; gap: 16px;">
          
          <!-- Exportación por jerarquía (única opción) -->
          <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; border: 2px solid var(--primary);">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
              <span style="font-weight: 600; color: var(--text-primary); font-size: 1.1rem;">🌳 Exportar por Nivel Jerárquico</span>
            </div>
            <p style="margin: 0 0 16px 0; font-size: 0.85rem; color: var(--text-secondary);">
              Selecciona la planta/empresa y opcionalmente profundiza en niveles específicos
            </p>
            
            <!-- Selectores de jerarquía (siempre visibles) -->
            <div id="jerarquiaSelectors">
              <div style="display: flex; flex-direction: column; gap: 10px;">
                
                <!-- Nivel 1: Planta/Empresa -->
                <div>
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    🏭 Planta/Empresa <span style="color: #e74c3c;">*</span>
                  </label>
                  <select id="nivel_planta" onchange="configuracion.actualizarNivelesJerarquia(1)" class="form-control" style="width: 100%;">
                    <option value="">-- Seleccionar Planta --</option>
                  </select>
                </div>
                
                <!-- Nivel 2: Área General -->
                <div id="container_areaGeneral" style="display: none;">
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    1️⃣ Área General
                  </label>
                  <select id="nivel_areaGeneral" onchange="configuracion.actualizarNivelesJerarquia(2)" class="form-control" style="width: 100%;">
                    <option value="">-- Todas (detener aquí) --</option>
                  </select>
                </div>
                
                <!-- Nivel 3: Sub-Área -->
                <div id="container_subArea" style="display: none;">
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    2️⃣ Sub-Área
                  </label>
                  <select id="nivel_subArea" onchange="configuracion.actualizarNivelesJerarquia(3)" class="form-control" style="width: 100%;">
                    <option value="">-- Todas (detener aquí) --</option>
                  </select>
                </div>
                
                <!-- Nivel 4: Sistema/Equipo -->
                <div id="container_sistemaEquipo" style="display: none;">
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    3️⃣ Sistema/Equipo
                  </label>
                  <select id="nivel_sistemaEquipo" onchange="configuracion.actualizarNivelesJerarquia(4)" class="form-control" style="width: 100%;">
                    <option value="">-- Todos (detener aquí) --</option>
                  </select>
                </div>
                
                <!-- Nivel 5: Sub-Sistema -->
                <div id="container_subSistema" style="display: none;">
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    4️⃣ Sub-Sistema
                  </label>
                  <select id="nivel_subSistema" onchange="configuracion.actualizarNivelesJerarquia(5)" class="form-control" style="width: 100%;">
                    <option value="">-- Todos (detener aquí) --</option>
                  </select>
                </div>
                
                <!-- Nivel 6: Sección -->
                <div id="container_seccion" style="display: none;">
                  <label style="display: block; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px;">
                    5️⃣ Sección
                  </label>
                  <select id="nivel_seccion" class="form-control" style="width: 100%;">
                    <option value="">-- Todas (detener aquí) --</option>
                  </select>
                </div>
                
              </div>
              
              <!-- Opciones adicionales -->
              <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 8px;">
                  <input type="checkbox" id="incluirArbolJerarquico" checked style="width: 16px; height: 16px;">
                  <span style="font-size: 0.9rem;">📊 Incluir árbol jerárquico en página 1</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                  <input type="checkbox" id="agruparPorNiveles" checked style="width: 16px; height: 16px;">
                  <span style="font-size: 0.9rem;">🗂️ Agrupar repuestos por niveles</span>
                </label>
              </div>
              
              <!-- Vista previa de conteo -->
              <div id="previewConteo" style="display: none; margin-top: 12px; padding: 10px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid var(--primary);">
                <div style="font-size: 0.85rem; color: var(--text-secondary);">
                  <strong style="color: var(--primary);">Vista previa:</strong><br>
                  <span id="conteoRepuestos">0 repuestos</span> serán exportados
                </div>
              </div>
            </div>
          </div>
          
          <!-- Botones de acción -->
          <div style="display: flex; gap: 10px; margin-top: 8px;">
            <button onclick="configuracion.ejecutarExportPDF()" class="btn btn-success" style="flex: 1; padding: 12px; font-weight: 600;">
              📥 Exportar PDF
            </button>
            <button onclick="configuracion.cerrarModal()" class="btn btn-secondary" style="padding: 12px 20px;">
              Cancelar
            </button>
          </div>
        </div>
      </div>
    `;
    
    this.mostrarModal(html);
    
    // Inicializar primer nivel (Planta/Empresa)
    this.cargarOpcionesNivel('planta', null);
  },
  
  // Toggle para mostrar/ocultar opciones de jerarquía (ya no se usa, siempre visible)
  toggleExportOptions(tipo) {
    // Función deprecada - los selectores ahora siempre están visibles
  },
  
  // Cargar opciones para un nivel específico
  cargarOpcionesNivel(campo, filtros = {}) {
    const select = document.getElementById(`nivel_${campo}`);
    if (!select) return;
    
    // Obtener valores únicos para este campo
    const valores = new Set();
    app.repuestos.forEach(r => {
      // Aplicar filtros de niveles superiores
      let cumpleFiltros = true;
      for (const [key, value] of Object.entries(filtros || {})) {
        if (value && r[key] !== value) {
          cumpleFiltros = false;
          break;
        }
      }
      
      if (cumpleFiltros && r[campo]) {
        valores.add(r[campo]);
      }
    });
    
    // Limpiar y llenar select
    select.innerHTML = campo === 'areaGeneral' 
      ? '<option value="">-- Seleccionar --</option>'
      : '<option value="">-- Todos (detener aquí) --</option>';
    
    Array.from(valores).sort().forEach(valor => {
      const option = document.createElement('option');
      option.value = valor;
      option.textContent = valor;
      select.appendChild(option);
    });
  },
  
  // Actualizar niveles jerárquicos al cambiar selección
  actualizarNivelesJerarquia(nivelActual) {
    const mapaNiveles = {
      1: { campo: 'planta', siguiente: 'areaGeneral', container: 'container_areaGeneral' },
      2: { campo: 'areaGeneral', siguiente: 'subArea', container: 'container_subArea' },
      3: { campo: 'subArea', siguiente: 'sistemaEquipo', container: 'container_sistemaEquipo' },
      4: { campo: 'sistemaEquipo', siguiente: 'subSistema', container: 'container_subSistema' },
      5: { campo: 'subSistema', siguiente: 'seccion', container: 'container_seccion' }
    };
    
    const nivel = mapaNiveles[nivelActual];
    if (!nivel) return;
    
    const valorSeleccionado = document.getElementById(`nivel_${nivel.campo}`).value;
    
    // Construir filtros acumulados
    const filtros = {};
    if (nivelActual >= 1) filtros.planta = document.getElementById('nivel_planta').value;
    if (nivelActual >= 2) filtros.areaGeneral = document.getElementById('nivel_areaGeneral').value;
    if (nivelActual >= 3) filtros.subArea = document.getElementById('nivel_subArea').value;
    if (nivelActual >= 4) filtros.sistemaEquipo = document.getElementById('nivel_sistemaEquipo').value;
    if (nivelActual >= 5) filtros.subSistema = document.getElementById('nivel_subSistema').value;
    
    // Mostrar siguiente nivel si hay valor seleccionado
    const siguienteContainer = document.getElementById(nivel.container);
    if (valorSeleccionado) {
      siguienteContainer.style.display = 'block';
      this.cargarOpcionesNivel(nivel.siguiente, filtros);
    } else {
      // Ocultar niveles siguientes
      siguienteContainer.style.display = 'none';
      if (nivelActual < 5) {
        const siguienteNivel = mapaNiveles[nivelActual + 1];
        if (siguienteNivel) {
          document.getElementById(siguienteNivel.container).style.display = 'none';
        }
      }
    }
    
    // Actualizar conteo de repuestos
    this.actualizarConteoPreview();
  },
  
  // Actualizar conteo de repuestos que serán exportados
  actualizarConteoPreview() {
    const previewDiv = document.getElementById('previewConteo');
    const conteoSpan = document.getElementById('conteoRepuestos');
    
    if (!previewDiv || !conteoSpan) return;
    
    // Obtener filtros seleccionados
    const filtros = {};
    const planta = document.getElementById('nivel_planta').value;
    if (planta) {
      filtros.planta = planta;
      
      const areaGeneral = document.getElementById('nivel_areaGeneral').value;
      if (areaGeneral) {
        filtros.areaGeneral = areaGeneral;
        
        const subArea = document.getElementById('nivel_subArea').value;
        if (subArea) {
          filtros.subArea = subArea;
          
          const sistemaEquipo = document.getElementById('nivel_sistemaEquipo').value;
          if (sistemaEquipo) {
            filtros.sistemaEquipo = sistemaEquipo;
            
            const subSistema = document.getElementById('nivel_subSistema').value;
            if (subSistema) {
              filtros.subSistema = subSistema;
              
              const seccion = document.getElementById('nivel_seccion').value;
              if (seccion) {
                filtros.seccion = seccion;
              }
            }
          }
        }
      }
    }
    
    // Contar repuestos que cumplen filtros
    let count = 0;
    app.repuestos.forEach(r => {
      let cumple = true;
      for (const [key, value] of Object.entries(filtros)) {
        if (value && r[key] !== value) {
          cumple = false;
          break;
        }
      }
      if (cumple) count++;
    });
    
    if (Object.keys(filtros).length > 0) {
      previewDiv.style.display = 'block';
      conteoSpan.textContent = `${count} repuesto${count !== 1 ? 's' : ''}`;
    } else {
      previewDiv.style.display = 'none';
    }
  },
  
  // Ejecutar exportación según opciones seleccionadas
  async ejecutarExportPDF() {
    // Validar que se haya seleccionado al menos la planta
    const planta = document.getElementById('nivel_planta').value;
    
    if (!planta) {
      app.showToast('⚠️ Selecciona al menos una Planta/Empresa', 'warning');
      return;
    }
    
    // Construir filtros de exportación
    const filtros = {};
    filtros.planta = planta;
    
    const areaGeneral = document.getElementById('nivel_areaGeneral').value;
    if (areaGeneral) {
      filtros.areaGeneral = areaGeneral;
      
      const subArea = document.getElementById('nivel_subArea').value;
      if (subArea) {
        filtros.subArea = subArea;
        
        const sistemaEquipo = document.getElementById('nivel_sistemaEquipo').value;
        if (sistemaEquipo) {
          filtros.sistemaEquipo = sistemaEquipo;
          
          const subSistema = document.getElementById('nivel_subSistema').value;
          if (subSistema) {
            filtros.subSistema = subSistema;
            
            const seccion = document.getElementById('nivel_seccion').value;
            if (seccion) {
              filtros.seccion = seccion;
            }
          }
        }
      }
    }
    
    // Opciones adicionales
    const incluirArbol = document.getElementById('incluirArbolJerarquico').checked;
    const agruparNiveles = document.getElementById('agruparPorNiveles').checked;
    
    this.cerrarModal();
    await this.exportarPDFJerarquico(filtros, incluirArbol, agruparNiveles);
  },
  
  async exportarPDFJerarquico(filtros, incluirArbol, agruparNiveles) {
    // Filtrar repuestos según jerarquía seleccionada
    const repuestosFiltrados = app.repuestos.filter(r => {
      for (const [key, value] of Object.entries(filtros)) {
        if (value && r[key] !== value) {
          return false;
        }
      }
      return true;
    });
    
    if (repuestosFiltrados.length === 0) {
      app.showToast('⚠️ No hay repuestos en esta jerarquía', 'warning');
      return;
    }
    
    // Llamar a exportación con opciones especiales
    await this.exportarPDFCompleto(filtros, repuestosFiltrados, incluirArbol, agruparNiveles);
  },
  
  async exportarPDFPorArea(areaNombre) {
    // Filtrar repuestos del área seleccionada
    const repuestosFiltrados = app.repuestos.filter(r => r.area === areaNombre);
    
    if (repuestosFiltrados.length === 0) {
      app.showToast(`❌ No hay repuestos en el área: ${areaNombre}`, 'error');
      return;
    }
    
    console.log(`📋 Exportando PDF del área: ${areaNombre} (${repuestosFiltrados.length} repuestos)`);
    
    // Exportar PDF con los repuestos filtrados
    await this.exportarPDFCompleto(areaNombre, repuestosFiltrados);
  },
  
  async exportarPDFCompleto(filtrosJerarquia = null, repuestosFiltrados = null, incluirArbol = false, agruparNiveles = false) {
    if (!window.jspdf || !window.jspdf.jsPDF) {
      app.showToast('❌ Error: Librería jsPDF no cargada', 'error');
      return;
    }

    try {
      console.log('🚀 Iniciando generación de PDF...');
      console.log('📋 Parámetros recibidos:', { filtrosJerarquia, repuestosFiltrados: repuestosFiltrados?.length || 0, incluirArbol, agruparNiveles });
      
      // 🔍 VERIFICAR Y CONFIGURAR SISTEMA DE IMÁGENES
      console.log('📂 Estado del FileSystem:');
      console.log('   - isFileSystemMode:', fsManager.isFileSystemMode);
      console.log('   - directoryHandle:', !!fsManager.directoryHandle);
      console.log('   - imagesFolder:', !!fsManager.imagesFolder);
      
      // ⚠️ ADVERTENCIA si NO está en modo FileSystem
      if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
        console.error('❌ ADVERTENCIA: Sistema de archivos NO conectado');
        console.error('❌ Las imágenes NO se cargarán en el PDF');
        
        const conectar = confirm(
          '⚠️ SISTEMA DE ARCHIVOS NO CONECTADO\n\n' +
          'No has conectado la carpeta INVENTARIO_STORAGE.\n' +
          'Las imágenes NO aparecerán en el PDF (solo placeholders).\n\n' +
          '¿Deseas conectar la carpeta ahora antes de exportar el PDF?'
        );
        
        if (conectar) {
          try {
            console.log('🔌 Solicitando acceso a carpeta...');
            await fsManager.requestDirectoryAccess();
            console.log('✅ FileSystem conectado exitosamente');
            
            // Reintentar la exportación ahora que está conectado
            console.log('🔄 Reintentando exportación con FileSystem conectado...');
            return await this.exportarPDFCompleto(repuestosFiltrados, filtrosJerarquia, incluirArbol, agruparNiveles);
          } catch (error) {
            console.error('❌ Error conectando FileSystem:', error);
            alert('No se pudo conectar la carpeta. El PDF se generará SIN IMÁGENES.');
          }
        } else {
          console.warn('⚠️ Usuario decidió continuar sin conectar FileSystem');
          console.warn('⚠️ Se usarán SOLO placeholders en el PDF');
        }
      }
      
      // Si estamos en modo FileSystem pero no tenemos la carpeta de imágenes, intentar obtenerla
      if (fsManager.isFileSystemMode && fsManager.directoryHandle && !fsManager.imagesFolder) {
        try {
          console.log('⚙️ Intentando obtener carpeta de imágenes...');
          fsManager.imagesFolder = await fsManager.directoryHandle.getDirectoryHandle('imagenes', { create: false });
          console.log('✅ Carpeta de imágenes obtenida correctamente');
        } catch (error) {
          console.warn('⚠️ No se pudo acceder a carpeta de imágenes:', error.message);
          console.warn('⚠️ Se usarán placeholders para todas las imágenes');
        }
      }
      
      // Determinar título según filtros
      let tituloExport = 'Inventario Completo';
      if (filtrosJerarquia && typeof filtrosJerarquia === 'object') {
        // Es exportación por jerarquía
        const niveles = [];
        if (filtrosJerarquia.areaGeneral) niveles.push(filtrosJerarquia.areaGeneral);
        if (filtrosJerarquia.subArea) niveles.push(filtrosJerarquia.subArea);
        if (filtrosJerarquia.sistemaEquipo) niveles.push(filtrosJerarquia.sistemaEquipo);
        if (filtrosJerarquia.subSistema) niveles.push(filtrosJerarquia.subSistema);
        if (filtrosJerarquia.seccion) niveles.push(filtrosJerarquia.seccion);
        tituloExport = niveles.join(' > ');
        console.log('📂 Título generado:', tituloExport);
      } else if (typeof filtrosJerarquia === 'string') {
        // Compatibilidad con versión anterior (areaNombre)
        tituloExport = `Área: ${filtrosJerarquia}`;
        console.log('📂 Título (compatibilidad):', tituloExport);
      }
      
      // Mostrar progreso inicial
      this.mostrarProgresoPDF(0, `Exportando: ${tituloExport}...`);
      
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Función para limpiar texto con caracteres especiales
      const limpiarTexto = (texto) => {
        if (!texto) return '';
        return String(texto)
          .replace(/á/g, 'a').replace(/Á/g, 'A')
          .replace(/é/g, 'e').replace(/É/g, 'E')
          .replace(/í/g, 'i').replace(/Í/g, 'I')
          .replace(/ó/g, 'o').replace(/Ó/g, 'O')
          .replace(/ú/g, 'u').replace(/Ú/g, 'U')
          .replace(/ñ/g, 'n').replace(/Ñ/g, 'N')
          .replace(/ü/g, 'u').replace(/Ü/g, 'U')
          .replace(/¿/g, '').replace(/¡/g, '')
          .replace(/[^\x00-\x7F]/g, ''); // Eliminar cualquier otro carácter no-ASCII
      };
      
      let yPos = 10;
      const pageHeight = doc.internal.pageSize.height;
      const pageWidth = doc.internal.pageSize.width;
      const margin = 10;
      const imgMaxWidth = 50; // Ancho máximo en mm (50mm = 5cm)
      const imgMaxHeight = 35; // Alto máximo en mm (35mm = 3.5cm)
      
      // Función para agregar pie de página con versión
      const agregarPiePagina = () => {
        const pageCount = doc.internal.getNumberOfPages();
        doc.setFontSize(7);
        doc.setTextColor(150, 150, 150);
        doc.text('v5.3.2', pageWidth - margin - 10, pageHeight - 5, { align: 'right' });
      };
      
      // Función para agregar nueva página si es necesario
      const checkNewPage = (neededSpace = 15) => {
        if (yPos + neededSpace > pageHeight - margin) {
          agregarPiePagina(); // Agregar versión antes de cambiar de página
          doc.addPage();
          yPos = 10;
          return true;
        }
        return false;
      };
      
      // Función para calcular dimensiones de imagen SIN DEFORMAR (mantiene proporciones exactas)
      const calcularDimensionesImagen = (imgData) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const originalWidth = img.width;
            const originalHeight = img.height;
            const aspectRatio = originalWidth / originalHeight;
            
            let width, height;
            
            // Estrategia: Escalar proporcionalmente hasta que uno de los lados toque el límite
            // Calcular escala basada en el lado más restrictivo
            const scaleByWidth = imgMaxWidth / originalWidth;
            const scaleByHeight = imgMaxHeight / originalHeight;
            
            // Usar la escala menor para asegurar que quepa en ambos límites
            const scale = Math.min(scaleByWidth, scaleByHeight, 0.15); // Máximo 0.15mm por pixel
            
            width = originalWidth * scale;
            height = originalHeight * scale;
            
            // Asegurar dimensiones mínimas visibles
            const minSize = 20; // 20mm mínimo
            if (width < minSize && height < minSize) {
              if (aspectRatio > 1) {
                // Horizontal: ajustar desde el ancho
                width = minSize;
                height = width / aspectRatio;
              } else {
                // Vertical: ajustar desde la altura
                height = minSize;
                width = height * aspectRatio;
              }
            }
            
            // Redondear a 1 decimal
            width = Math.round(width * 10) / 10;
            height = Math.round(height * 10) / 10;
            
            resolve({ 
              width, 
              height, 
              aspectRatio, 
              debeRotar: false, // Nunca rotar, mantener orientación original
              originalWidth, 
              originalHeight 
            });
          };
          img.onerror = () => resolve({ 
            width: 40, 
            height: 30, 
            aspectRatio: 1.33, 
            debeRotar: false 
          });
          img.src = imgData;
        });
      };
      
      // Imagen placeholder (definida aquí para usarla sin llamar a fsManager)
      const placeholderImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACWCAYAAACb3McZAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR4nO3dy0pDQRRF0ZOI///L4sPIQNAY86h0n7X2gDvJoKu7TqeqngEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP/q9cV7AK7w+uXlbYwxvr5/f/sewKV+hOPx+Ph8fHwc3wW40I9wjDHG4/Fx8R7Ahb6F4/n5+eE9gAt9C8cY4+49gAt9D8er9wAu9CMcz+N1eA/gQj/CMcZr8x7AhSYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTqGkSwlhPoKZJCGM9gZomIYz1BGqahDDWE6hpEsJYT6CmSQhjPYGaJiGM9QRqmoQw1hOoaRLCWE+gpkkIYz2BmiYhjPUEapqEMNYTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgFv6AyRmU3vlastLAAAAAElFTkSuQmCC';
      
      // Función para cargar imagen como base64 (con timeout extendido)
      const getImageBase64 = async (repuesto) => {
        try {
          // Obtener la primera imagen del array multimedia
          if (repuesto.multimedia && Array.isArray(repuesto.multimedia)) {
            const primeraImagen = repuesto.multimedia.find(m => m.type === 'image');
            
            if (primeraImagen && primeraImagen.url) {
              let imagePath = primeraImagen.url;
              
              console.log(`🖼️ [${repuesto.nombre}] URL original: "${imagePath}"`);
              
              // Normalizar ruta de imagen
              if (imagePath.startsWith('./imagenes/')) {
                imagePath = imagePath.substring(11);
              } else if (imagePath.startsWith('imagenes/')) {
                imagePath = imagePath.substring(9);
              } else if (imagePath.startsWith('INVENTARIO_STORAGE/imagenes/')) {
                imagePath = imagePath.substring(28);
              }
              
              console.log(`📂 [${repuesto.nombre}] Ruta normalizada: "${imagePath}"`);
              console.log(`🔍 Estado FileSystem: isFileSystemMode=${fsManager.isFileSystemMode}, imagesFolder=${!!fsManager.imagesFolder}`);
              
              // Intentar cargar desde FileSystem con timeout extendido
              if (fsManager.isFileSystemMode && fsManager.imagesFolder) {
                console.log(`✅ FileSystem disponible, intentando getFileHandle("${imagePath}")...`);
                try {
                  const fileHandle = await fsManager.imagesFolder.getFileHandle(imagePath);
                  const file = await fileHandle.getFile();
                  
                  console.log(`✅ [${repuesto.nombre}] Archivo encontrado: ${file.name}, tamaño: ${(file.size/1024).toFixed(1)}KB, tipo: ${file.type}`);
                  
                  // Timeout de 5 segundos por imagen (más tiempo para cargar)
                  const imageData = await Promise.race([
                    new Promise((resolve) => {
                      const reader = new FileReader();
                      reader.onload = () => {
                        console.log(`✅ [${repuesto.nombre}] Imagen CARGADA exitosamente (${(reader.result.length/1024).toFixed(1)}KB base64)`);
                        resolve(reader.result);
                      };
                      reader.onerror = (err) => {
                        console.error(`❌ [${repuesto.nombre}] Error leyendo archivo:`, err);
                        resolve(null);
                      };
                      reader.readAsDataURL(file);
                    }),
                    new Promise((resolve) => setTimeout(() => {
                      console.warn(`⏱️ [${repuesto.nombre}] TIMEOUT (5s) cargando imagen`);
                      resolve(null);
                    }, 5000))
                  ]);
                  
                  // Si se cargó correctamente, devolverla
                  if (imageData) {
                    return imageData;
                  }
                  
                  // Si timeout o error, usar placeholder
                  console.warn(`⚠️ [${repuesto.nombre}] Usando PLACEHOLDER (imageData fue null)`);
                  return placeholderImage;
                  
                } catch (error) {
                  // Imagen no encontrada, usar placeholder
                  console.warn(`❌ [${repuesto.nombre}] Archivo NO encontrado en carpeta: ${error.message}`);
                  return placeholderImage;
                }
              } else {
                console.error(`❌ [${repuesto.nombre}] FileSystem NO disponible (isFileSystemMode=${fsManager.isFileSystemMode}, imagesFolder=${!!fsManager.imagesFolder})`);
              }
            } else {
              console.log(`📷 [${repuesto.nombre}] No tiene imagen en multimedia (primeraImagen=${!!primeraImagen})`);
            }
          } else {
            console.log(`📷 [${repuesto.nombre}] No tiene array multimedia`);
          }
        } catch (error) {
          console.error(`❌ [${repuesto.nombre}] Error general cargando imagen:`, error);
        }
        // Retornar placeholder si no hay imagen
        console.log(`📷 [${repuesto.nombre}] Retornando PLACEHOLDER`);
        return placeholderImage;
      };
      
      console.log('📝 Creando portada...');
      this.mostrarProgresoPDF(5, 'Creando portada del documento...');
      
      // Usar repuestos filtrados o todos
      const repuestosParaPDF = repuestosFiltrados || app.repuestos;
      
      // Determinar el título según el nivel seleccionado (el más profundo)
      let tituloDocumento = 'Inventario de Repuestos';
      let subtituloDocumento = 'Todos los repuestos';
      
      if (filtrosJerarquia && typeof filtrosJerarquia === 'object') {
        // Buscar el nivel más profundo seleccionado
        if (filtrosJerarquia.seccion) {
          tituloDocumento = filtrosJerarquia.seccion;
          subtituloDocumento = `Seccion dentro de ${filtrosJerarquia.subSistema || 'sistema'}`;
        } else if (filtrosJerarquia.subSistema) {
          tituloDocumento = filtrosJerarquia.subSistema;
          subtituloDocumento = `Sub-Sistema dentro de ${filtrosJerarquia.sistemaEquipo || 'equipo'}`;
        } else if (filtrosJerarquia.sistemaEquipo) {
          tituloDocumento = filtrosJerarquia.sistemaEquipo;
          subtituloDocumento = filtrosJerarquia.subArea ? `Sistema/Equipo dentro de ${filtrosJerarquia.subArea}` : `Sistema/Equipo dentro de ${filtrosJerarquia.areaGeneral}`;
        } else if (filtrosJerarquia.subArea) {
          tituloDocumento = filtrosJerarquia.subArea;
          subtituloDocumento = `Sub-Area dentro de ${filtrosJerarquia.areaGeneral || 'area general'}`;
        } else if (filtrosJerarquia.areaGeneral) {
          tituloDocumento = filtrosJerarquia.areaGeneral;
          subtituloDocumento = 'Area General';
        }
      } else if (tituloExport !== 'Inventario Completo') {
        tituloDocumento = tituloExport;
      }
      
      // PORTADA COMPACTA
      doc.setFontSize(18);
      doc.setTextColor(59, 130, 246);
      doc.text(limpiarTexto(tituloDocumento), pageWidth / 2, 20, { align: 'center' });
      
      doc.setFontSize(9);
      doc.setTextColor(100, 100, 100);
      doc.text(limpiarTexto(subtituloDocumento), pageWidth / 2, 26, { align: 'center' });
      doc.text(`${new Date().toLocaleDateString('es-ES')} | Total: ${repuestosParaPDF.length} repuestos`, pageWidth / 2, 31, { align: 'center' });
      
      // Estadísticas compactas
      const sinStock = repuestosParaPDF.filter(r => r.cantidad === 0).length;
      const stockBajo = repuestosParaPDF.filter(r => r.cantidad > 0 && r.cantidad <= (r.minimo || 5)).length;
      const stockOK = repuestosParaPDF.length - sinStock - stockBajo;
      
      yPos = 39;
      doc.setFontSize(8);
      doc.setTextColor(60, 60, 60);
      doc.text(`Stock OK: ${stockOK} | Stock Bajo: ${stockBajo} | Sin Stock: ${sinStock}`, pageWidth / 2, yPos, { align: 'center' });
      
      // ========== ÁRBOL JERÁRQUICO (si está activado) ==========
      if (incluirArbol && filtrosJerarquia && typeof filtrosJerarquia === 'object') {
        yPos = 48;
        
        // Título del árbol
        doc.setFontSize(9);
        doc.setTextColor(80, 80, 80);
        doc.setFont(undefined, 'bold');
        doc.text('ESTRUCTURA JERARQUICA', pageWidth / 2, yPos, { align: 'center' });
        doc.setFont(undefined, 'normal');
        
        yPos += 3;
        
        // Línea separadora
        doc.setDrawColor(150, 150, 150);
        doc.setLineWidth(0.2);
        doc.line(margin + 30, yPos, pageWidth - margin - 30, yPos);
        
        yPos += 8;
        
        // Construir árbol con contadores
        const construirArbol = () => {
          const arbol = {
            empresa: 'Aquachile Antarfood Chonchi',
            areasGenerales: {}
          };
          
          // Analizar todos los repuestos para construir estructura completa
          repuestosParaPDF.forEach(r => {
            const ag = r.areaGeneral || r.area || 'Sin Clasificar';
            if (!arbol.areasGenerales[ag]) {
              arbol.areasGenerales[ag] = { total: 0, subAreas: {} };
            }
            arbol.areasGenerales[ag].total++;
            
            const sa = r.subArea;
            if (sa) {
              if (!arbol.areasGenerales[ag].subAreas[sa]) {
                arbol.areasGenerales[ag].subAreas[sa] = { total: 0, sistemas: {} };
              }
              arbol.areasGenerales[ag].subAreas[sa].total++;
              
              const se = r.sistemaEquipo || r.equipo;
              if (se) {
                if (!arbol.areasGenerales[ag].subAreas[sa].sistemas[se]) {
                  arbol.areasGenerales[ag].subAreas[sa].sistemas[se] = { total: 0, subSistemas: {} };
                }
                arbol.areasGenerales[ag].subAreas[sa].sistemas[se].total++;
                
                const ss = r.subSistema;
                if (ss) {
                  if (!arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss]) {
                    arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss] = { total: 0, secciones: {} };
                  }
                  arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].total++;
                  
                  const sec = r.seccion;
                  if (sec) {
                    if (!arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec]) {
                      arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec] = { total: 0, detalles: {} };
                    }
                    arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec].total++;
                    
                    const det = r.detalle;
                    if (det) {
                      if (!arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec].detalles[det]) {
                        arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec].detalles[det] = 0;
                      }
                      arbol.areasGenerales[ag].subAreas[sa].sistemas[se].subSistemas[ss].secciones[sec].detalles[det]++;
                    }
                  }
                }
              }
            }
          });
          
          return arbol;
        };
        
        // Construir árbol completo
        const arbol = construirArbol();
        
        // Función recursiva para dibujar todo el árbol
        const xInicio = 10;
        let yActual = yPos;
        const espacioVertical = 3.5;  // Más compacto (antes 4)
        const espacioHorizontal = 20; // Más compacto (antes 22)
        
        doc.setFontSize(6.5);  // Letra más pequeña para que quepa más (antes 7)
        doc.setDrawColor(180, 180, 180);
        doc.setLineWidth(0.15);
        
        // Función para verificar si un elemento está seleccionado
        const esSeleccionado = (nivel, valor) => {
          if (nivel === 1) return false; // Nivel 1: Empresa (raíz, no seleccionable)
          if (nivel === 2) return filtrosJerarquia.areaGeneral === valor && !filtrosJerarquia.subArea;
          if (nivel === 3) return filtrosJerarquia.subArea === valor && !filtrosJerarquia.sistemaEquipo;
          if (nivel === 4) return filtrosJerarquia.sistemaEquipo === valor && !filtrosJerarquia.subSistema;
          if (nivel === 5) return filtrosJerarquia.subSistema === valor && !filtrosJerarquia.seccion;
          if (nivel === 6) return filtrosJerarquia.seccion === valor && !filtrosJerarquia.detalle;
          if (nivel === 7) return filtrosJerarquia.detalle === valor;
          return false;
        };
        
        // Dibujar raíz (Nivel 1: Empresa)
        doc.setFont(undefined, 'normal');
        doc.setTextColor(100, 100, 100);
        doc.text(limpiarTexto(`${arbol.empresa} (${repuestosParaPDF.length})`), xInicio + 2, yActual);
        const yRaiz = yActual;
        yActual += espacioVertical;
        
        // Dibujar todas las áreas generales (Nivel 2)
        const areasGenerales = Object.keys(arbol.areasGenerales).sort();
        areasGenerales.forEach((ag, idxAG) => {
          const dataAG = arbol.areasGenerales[ag];
          const xAG = xInicio + espacioHorizontal;
          const yAG = yActual;
          
          // Línea desde raíz
          doc.setDrawColor(180, 180, 180);
          if (idxAG === 0) {
            doc.line(xInicio, yRaiz, xInicio, yAG);
          }
          doc.line(xInicio, yAG, xAG, yAG);
          
          // Texto del área general (Nivel 2)
          const selAG = esSeleccionado(2, ag);
          if (selAG) {
            doc.setFont(undefined, 'bold');
            doc.setTextColor(220, 38, 38);
          } else {
            doc.setFont(undefined, 'normal');
            doc.setTextColor(100, 100, 100);
          }
          doc.text(limpiarTexto(`${ag} (${dataAG.total})`), xAG + 2, yAG);
          const yAGInicio = yActual;
          yActual += espacioVertical;
          
          // Dibujar sub-áreas de esta área general (Nivel 3)
          const subAreas = Object.keys(dataAG.subAreas).sort();
          subAreas.forEach((sa, idxSA) => {
            const dataSA = dataAG.subAreas[sa];
            const xSA = xAG + espacioHorizontal;
            const ySA = yActual;
            
            // Línea desde área general
            doc.setDrawColor(180, 180, 180);
            if (idxSA === 0) {
              doc.line(xAG, yAG, xAG, ySA);
            }
            doc.line(xAG, ySA, xSA, ySA);
            
            // Texto de sub-área (Nivel 3)
            const selSA = esSeleccionado(3, sa) && filtrosJerarquia.areaGeneral === ag;
            if (selSA) {
              doc.setFont(undefined, 'bold');
              doc.setTextColor(220, 38, 38);
            } else {
              doc.setFont(undefined, 'normal');
              doc.setTextColor(120, 120, 120);
            }
            doc.text(limpiarTexto(`${sa} (${dataSA.total})`), xSA + 2, ySA);
            const ySAInicio = yActual;
            yActual += espacioVertical;
            
            // Dibujar sistemas de esta sub-área (Nivel 4)
            const sistemas = Object.keys(dataSA.sistemas).sort();
            sistemas.forEach((se, idxSE) => {
              const dataSE = dataSA.sistemas[se];
              const xSE = xSA + espacioHorizontal;
              const ySE = yActual;
              
              // Línea desde sub-área
              doc.setDrawColor(180, 180, 180);
              if (idxSE === 0) {
                doc.line(xSA, ySA, xSA, ySE);
              }
              doc.line(xSA, ySE, xSE, ySE);
              
              // Texto de sistema (Nivel 4)
              const selSE = esSeleccionado(4, se) && filtrosJerarquia.areaGeneral === ag && filtrosJerarquia.subArea === sa;
              if (selSE) {
                doc.setFont(undefined, 'bold');
                doc.setTextColor(220, 38, 38);
              } else {
                doc.setFont(undefined, 'normal');
                doc.setTextColor(140, 140, 140);
              }
              doc.text(limpiarTexto(`${se} (${dataSE.total})`), xSE + 2, ySE);
              const ySEInicio = yActual;
              yActual += espacioVertical;
              
              // Sub-sistemas (Nivel 5 - TODOS, sin límite)
              const subSistemas = Object.keys(dataSE.subSistemas).sort();
              subSistemas.forEach((ss, idxSS) => {
                const dataSS = dataSE.subSistemas[ss];
                const xSS = xSE + espacioHorizontal;
                const ySS = yActual;
                
                doc.setDrawColor(200, 200, 200);
                if (idxSS === 0) {
                  doc.line(xSE, ySE, xSE, ySS);
                }
                doc.line(xSE, ySS, xSS, ySS);
                
                const selSS = esSeleccionado(5, ss) && filtrosJerarquia.areaGeneral === ag && filtrosJerarquia.subArea === sa && filtrosJerarquia.sistemaEquipo === se;
                if (selSS) {
                  doc.setFont(undefined, 'bold');
                  doc.setTextColor(220, 38, 38);
                } else {
                  doc.setFont(undefined, 'normal');
                  doc.setTextColor(160, 160, 160);
                }
                doc.text(limpiarTexto(`${ss} (${dataSS.total})`), xSS + 2, ySS);
                const ySSInicio = yActual;
                yActual += espacioVertical;
                
                // Secciones (Nivel 6 - TODOS)
                const secciones = Object.keys(dataSS.secciones).sort();
                secciones.forEach((sec, idxSec) => {
                  const dataSec = dataSS.secciones[sec];
                  const xSec = xSS + espacioHorizontal;
                  const ySec = yActual;
                  
                  doc.setDrawColor(220, 220, 220);
                  if (idxSec === 0) {
                    doc.line(xSS, ySS, xSS, ySec);
                  }
                  doc.line(xSS, ySec, xSec, ySec);
                  
                  const selSec = esSeleccionado(6, sec) && filtrosJerarquia.areaGeneral === ag && filtrosJerarquia.subArea === sa && filtrosJerarquia.sistemaEquipo === se && filtrosJerarquia.subSistema === ss;
                  if (selSec) {
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(220, 38, 38);
                  } else {
                    doc.setFont(undefined, 'normal');
                    doc.setTextColor(180, 180, 180);
                  }
                  doc.text(limpiarTexto(`${sec} (${dataSec.total})`), xSec + 2, ySec);
                  yActual += espacioVertical;
                  
                  // Detalles (Nivel 7 - TODOS)
                  const detalles = Object.keys(dataSec.detalles).sort();
                  detalles.forEach((det, idxDet) => {
                    const totalDet = dataSec.detalles[det];
                    const xDet = xSec + espacioHorizontal;
                    const yDet = yActual;
                    
                    doc.setDrawColor(230, 230, 230);
                    if (idxDet === 0) {
                      doc.line(xSec, ySec, xSec, yDet);
                    }
                    doc.line(xSec, yDet, xDet, yDet);
                    
                    const selDet = esSeleccionado(7, det) && filtrosJerarquia.areaGeneral === ag && filtrosJerarquia.subArea === sa && filtrosJerarquia.sistemaEquipo === se && filtrosJerarquia.subSistema === ss && filtrosJerarquia.seccion === sec;
                    if (selDet) {
                      doc.setFont(undefined, 'bold');
                      doc.setTextColor(220, 38, 38);
                    } else {
                      doc.setFont(undefined, 'normal');
                      doc.setTextColor(200, 200, 200);
                    }
                    doc.text(limpiarTexto(`${det} (${totalDet})`), xDet + 2, yDet);
                    yActual += espacioVertical;
                    
                    // Verificar si necesitamos una nueva página
                    if (yActual > pageHeight - 20) {
                      agregarPiePagina();
                      doc.addPage();
                      yActual = 10;
                      // Re-dibujar título del árbol en nueva página
                      doc.setFontSize(8);
                      doc.setTextColor(80, 80, 80);
                      doc.setFont(undefined, 'bold');
                      doc.text('ESTRUCTURA JERARQUICA (continuacion)', pageWidth / 2, yActual, { align: 'center' });
                      doc.setFont(undefined, 'normal');
                      yActual += 5;
                      doc.setFontSize(6.5);
                    }
                  });
                  
                  // Verificar paginación también después de secciones
                  if (yActual > pageHeight - 20) {
                    agregarPiePagina();
                    doc.addPage();
                    yActual = 10;
                    doc.setFontSize(8);
                    doc.setTextColor(80, 80, 80);
                    doc.setFont(undefined, 'bold');
                    doc.text('ESTRUCTURA JERARQUICA (continuacion)', pageWidth / 2, yActual, { align: 'center' });
                    doc.setFont(undefined, 'normal');
                    yActual += 5;
                    doc.setFontSize(6.5);
                  }
                });
              });
            });
          });
        });
        
        yPos = yActual + 2;
        
        // Línea separadora final
        doc.setDrawColor(150, 150, 150);
        doc.setLineWidth(0.2);
        doc.line(margin + 30, yPos, pageWidth - margin - 30, yPos);
        
        yPos += 3;
      }
      
      this.mostrarProgresoPDF(10, 'Organizando repuestos por categorías...');
      
      // Organizar repuestos por el nivel hijo del seleccionado
      const repuestosPorCategoria = {};
      
      // Determinar campo de agrupación según filtros
      let campoAgrupacion = 'area'; // Por defecto
      let nombreAgrupacion = 'Área';
      
      if (filtrosJerarquia && typeof filtrosJerarquia === 'object') {
        if (filtrosJerarquia.subSistema && !filtrosJerarquia.seccion) {
          // Seleccionado Sub-Sistema → agrupar por Sección
          campoAgrupacion = 'seccion';
          nombreAgrupacion = 'Sección';
        } else if (filtrosJerarquia.sistemaEquipo && !filtrosJerarquia.subSistema) {
          // Seleccionado Sistema/Equipo → agrupar por Sub-Sistema
          campoAgrupacion = 'subSistema';
          nombreAgrupacion = 'Sub-Sistema';
        } else if (filtrosJerarquia.subArea && !filtrosJerarquia.sistemaEquipo) {
          // Seleccionado Sub-Área → agrupar por Sistema/Equipo
          campoAgrupacion = 'sistemaEquipo';
          nombreAgrupacion = 'Sistema/Equipo';
        } else if (filtrosJerarquia.areaGeneral && !filtrosJerarquia.subArea) {
          // Seleccionado Área General → agrupar por Sub-Área
          campoAgrupacion = 'subArea';
          nombreAgrupacion = 'Sub-Área';
        }
      }
      
      repuestosParaPDF.forEach(r => {
        let categoria = r[campoAgrupacion] || r.area || 'Sin Clasificar';
        
        // Para sistemaEquipo también puede estar en r.equipo
        if (campoAgrupacion === 'sistemaEquipo' && !categoria) {
          categoria = r.equipo || 'Sin Clasificar';
        }
        
        if (!repuestosPorCategoria[categoria]) {
          repuestosPorCategoria[categoria] = [];
        }
        repuestosPorCategoria[categoria].push(r);
      });
      
      console.log(`📦 ${repuestosParaPDF.length} repuestos organizados en ${Object.keys(repuestosPorCategoria).length} categorías (${nombreAgrupacion})`);
      
      // CONTENIDO DETALLADO POR CATEGORÍA
      // Si no hay árbol, comenzar en yPos=46, si hay árbol ya está posicionado correctamente
      if (!incluirArbol || !filtrosJerarquia || typeof filtrosJerarquia !== 'object') {
        yPos = 46;
      }
      
      let totalProcesados = 0;
      const totalRepuestos = repuestosParaPDF.length;
      
      for (const [categoria, repuestos] of Object.entries(repuestosPorCategoria).sort()) {
        checkNewPage(12);
        
        console.log(`📋 Procesando ${nombreAgrupacion}: ${categoria} (${repuestos.length} repuestos)`);
        
        // Actualizar progreso
        const progresoArea = 10 + (totalProcesados / totalRepuestos) * 80;
        this.mostrarProgresoPDF(progresoArea, `Procesando: ${categoria} (${totalProcesados}/${totalRepuestos})`);
        
        // Título de la categoría
        doc.setFontSize(11);
        doc.setTextColor(255, 255, 255);
        doc.setFillColor(59, 130, 246);
        doc.rect(margin, yPos - 4, pageWidth - 2 * margin, 8, 'F');
        doc.text(limpiarTexto(`${categoria} (${repuestos.length})`), margin + 2, yPos + 1);
        yPos += 10;
        
        // Repuestos del área (diseño compacto en tabla)
        for (const repuesto of repuestos) {
          totalProcesados++;
          
          // Actualizar progreso cada 5 repuestos
          if (totalProcesados % 5 === 0) {
            const progreso = 10 + (totalProcesados / totalRepuestos) * 80;
            this.mostrarProgresoPDF(progreso, `Procesando repuesto ${totalProcesados} de ${totalRepuestos}...`);
            console.log(`⏳ Procesando ${totalProcesados}/${totalRepuestos} repuestos...`);
          }
          
          const rowHeight = 34; // Altura aumentada para imágenes más grandes (de 22 a 34)
          checkNewPage(rowHeight);
          
          // Fondo alternado sutil
          doc.setFillColor(248, 248, 248);
          doc.rect(margin, yPos, pageWidth - 2 * margin, rowHeight, 'F');
          
          let xPos = margin + 2;
          let imgWidth = 0; // Ancho real de la imagen
          
          // Imagen miniatura (siempre mostrar, real o placeholder)
          try {
            console.log(`\n🖼️ Procesando imagen para: ${repuesto.nombre}`);
            console.log(`   Multimedia array:`, repuesto.multimedia);
            
            const imgData = await getImageBase64(repuesto);
            
            console.log(`   ImgData recibido: ${imgData ? 'SÍ (' + (imgData.length/1024).toFixed(1) + 'KB)' : 'NO'}`);
            
            // getImageBase64 siempre devuelve algo (imagen real o placeholder)
            // Calcular dimensiones manteniendo proporciones originales
            const { width, height, aspectRatio, originalWidth, originalHeight } = await calcularDimensionesImagen(imgData);
            
            console.log(`   Dimensiones originales: ${originalWidth}x${originalHeight}`);
            console.log(`   Dimensiones PDF: ${width}x${height}mm (ratio: ${aspectRatio.toFixed(2)})`);
            
            // Centrar verticalmente la imagen en la fila
            const imgY = yPos + (rowHeight - height) / 2;
            
            // Agregar imagen manteniendo proporciones (sin rotación, sin deformación)
            doc.addImage(imgData, 'JPEG', xPos, imgY, width, height);
            imgWidth = width;
            
          } catch (e) {
            console.warn(`⚠️ Error con imagen de ${repuesto.nombre}:`, e.message);
            // Si falla completamente, usar ancho máximo por defecto
            imgWidth = imgMaxWidth;
          }
          
          // Ajustar xPos según el ancho real de la imagen (o usar el máximo si no hay imagen)
          xPos += (imgWidth || imgMaxWidth) + 3;
          
          // Información del repuesto (ajustada para nueva altura)
          doc.setFontSize(9);
          doc.setTextColor(0, 0, 0);
          doc.setFont(undefined, 'bold');
          const nombreCorto = limpiarTexto((repuesto.nombre || 'Sin nombre').substring(0, 40));
          doc.text(nombreCorto, xPos, yPos + 7);
          
          doc.setFont(undefined, 'normal');
          doc.setFontSize(7);
          doc.setTextColor(80, 80, 80);
          
          let infoY = yPos + 12;
          const infoLines = [];
          if (repuesto.codSAP) infoLines.push(limpiarTexto(`SAP: ${repuesto.codSAP}`));
          if (repuesto.codProv) infoLines.push(limpiarTexto(`Prov: ${repuesto.codProv}`));
          infoLines.push(limpiarTexto(`${repuesto.tipo || 'N/A'} | ${repuesto.equipo || 'N/A'}`));
          
          // Agregar datos técnicos si existen (NUEVO)
          if (repuesto.datosTecnicos) {
            const datosTecnicosLines = repuesto.datosTecnicos.split('\n').slice(0, 2); // Máximo 2 líneas
            datosTecnicosLines.forEach(linea => {
              if (linea.trim()) {
                infoLines.push(limpiarTexto(`${linea.trim().substring(0, 45)}`));
              }
            });
          }
          
          infoLines.forEach(line => {
            doc.text(line, xPos, infoY);
            infoY += 3.5;
          });
          
          // Stock (con color según estado) - lado derecho, centrado verticalmente
          const stockX = pageWidth - margin - 35;
          const stockColor = repuesto.cantidad === 0 ? [220, 38, 38] : 
                           repuesto.cantidad <= (repuesto.minimo || 5) ? [245, 158, 11] : 
                           [16, 185, 129];
          doc.setTextColor(...stockColor);
          doc.setFont(undefined, 'bold');
          doc.setFontSize(8);
          doc.text(`Stock: ${repuesto.cantidad}/${repuesto.minimo || 5}`, stockX, yPos + 14);
          
          // Fecha de último conteo (IMPRESCINDIBLE) - TAMAÑO AUMENTADO CON HORA
          doc.setFont(undefined, 'normal');
          doc.setFontSize(7);
          if (repuesto.ultimoConteo) {
            doc.setTextColor(100, 100, 100);
            const fechaCompleta = new Date(repuesto.ultimoConteo);
            const fecha = fechaCompleta.toLocaleDateString('es-ES');
            const hora = fechaCompleta.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            doc.text(`Conteo: ${fecha} ${hora}`, stockX, yPos + 20);
          } else {
            doc.setTextColor(220, 38, 38);
            doc.text(`Sin conteo`, stockX, yPos + 20);
          }
          
          // Precio (si existe)
          if (repuesto.precio) {
            doc.setTextColor(59, 130, 246);
            doc.setFontSize(7);
            doc.text(`$${repuesto.precio.toFixed(2)}`, stockX, yPos + 26);
          }
          
          yPos += rowHeight + 1;
        }
        
        yPos += 3; // Espacio entre áreas
      }
      
      console.log(`✅ Todos los repuestos procesados (${totalProcesados}/${totalRepuestos})`);
      console.log(`📄 Total de páginas generadas: ${doc.internal.getNumberOfPages()}`);
      
      this.mostrarProgresoPDF(95, 'Generando archivo PDF...');
      
      // Agregar pie de página a la última página
      agregarPiePagina();
      
      // Guardar PDF con fecha en el nombre
      const fechaHoy = new Date();
      const dia = String(fechaHoy.getDate()).padStart(2, '0');
      const mes = String(fechaHoy.getMonth() + 1).padStart(2, '0');
      const anio = fechaHoy.getFullYear();
      
      // Nombre del archivo con filtro si es una exportación específica
      const nombreFiltro = (tituloExport && tituloExport !== 'Inventario Completo') 
        ? `_${tituloExport.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30)}` 
        : '';
      const filename = `Inventario${nombreFiltro}_${dia}-${mes}-${anio}.pdf`;
      console.log(`💾 Guardando PDF: ${filename}`);
      
      // Pequeña pausa para mostrar el 95%
      await new Promise(resolve => setTimeout(resolve, 300));
      
      doc.save(filename);
      
      this.mostrarProgresoPDF(100, '¡PDF generado exitosamente!');
      
      // Cerrar el modal después de 1.5 segundos
      setTimeout(() => {
        this.cerrarModal();
        app.showToast(`✅ PDF descargado: ${filename} (${doc.internal.getNumberOfPages()} páginas)`, 'success', 5000);
      }, 1500);
      
      console.log('✅ PDF descargado exitosamente');
      
    } catch (error) {
      console.error('❌ Error generando PDF:', error);
      this.cerrarModal();
      app.showToast('❌ Error al generar PDF: ' + error.message, 'error');
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // 📦 SISTEMA DE RESPALDO/CARGA COMPLETA (Migración entre versiones)
  // ═══════════════════════════════════════════════════════════════════
  
  async exportarRespaldoCompleto() {
    if (!window.JSZip) {
      app.showToast('❌ Error: Librería JSZip no cargada', 'error');
      return;
    }

    if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta de trabajo', 'warning');
      return;
    }

    try {
      app.showToast('📦 Creando respaldo completo... Esto puede tardar', 'info', 5000);
      
      const zip = new JSZip();
      
      // 1. Agregar datos de repuestos (JSON)
      const datosRepuestos = {
        version: '5.3.2',
        fecha: new Date().toISOString(),
        totalRepuestos: app.repuestos.length,
        repuestos: app.repuestos
      };
      zip.file('repuestos.json', JSON.stringify(datosRepuestos, null, 2));
      
      // 2. Agregar mapas si existen
      if (mapStorage && mapStorage.initialized) {
        try {
          const mapas = await mapStorage.getMaps();
          const areas = await mapStorage.getAreas();
          
          const datosMapas = {
            version: '5.3.2',
            fecha: new Date().toISOString(),
            mapas: mapas,
            areas: areas
          };
          zip.file('mapas.json', JSON.stringify(datosMapas, null, 2));
        } catch (error) {
          console.warn('⚠️ No se pudieron cargar los mapas:', error);
        }
      }
      
      // 3. Contar imágenes antes del README
      let imagenCount = 0;
      if (fsManager.imagesFolder) {
        for await (const entry of fsManager.imagesFolder.values()) {
          if (entry.kind === 'file') {
            imagenCount++;
          }
        }
      }
      
      // 4. Agregar README con instrucciones
      const readme = `
RESPALDO COMPLETO DEL INVENTARIO (ZIP)
=======================================

📅 Fecha de creación: ${new Date().toLocaleString('es-ES')}
📦 Versión: 5.3.2
📊 Total de repuestos: ${app.repuestos.length}
🖼️  Total de imágenes: ${imagenCount}

CONTENIDO DEL ZIP:
------------------
1. repuestos.json - Datos completos de todos los repuestos
2. mapas.json - Configuración de mapas y áreas marcadas
3. imagenes/ - Carpeta con todas las fotos de repuestos
4. README.txt - Este archivo de instrucciones

UBICACIÓN DEL RESPALDO:
-----------------------
Este archivo ZIP se guarda automáticamente en:
📂 INVENTARIO_STORAGE/backups/zip/Respaldo_Completo_YYYY-MM-DD.zip

⚠️ IMPORTANTE: Los backups se organizan en carpetas separadas:
   • backups/automaticos/ - Backups JSON automáticos (cada vez que guardas)
   • backups/zip/ - Respaldos ZIP completos (con todas las imágenes)
   • backups/mapas/ - Backups específicos de mapas
   • backups/zonas/ - Backups específicos de zonas

INSTRUCCIONES PARA RESTAURAR:
------------------------------
1. En la aplicación v5.3.2 o superior, ve a:
   Configuración > Gestión de Backups > Cargar Respaldo Completo
2. El sistema buscará automáticamente en: INVENTARIO_STORAGE/backups/zip/
3. Selecciona el respaldo ZIP que deseas restaurar
4. ¡Listo! Todos tus datos estarán restaurados

MIGRACIÓN ENTRE VERSIONES:
---------------------------
Este respaldo es compatible con:
- v5.3.0 → v5.3.2
- v5.3.2 → Versiones futuras

Para migrar a otra versión:
1. Descarga el ZIP al navegador usando el botón "Descargar ZIP"
2. Instala la nueva versión del inventario
3. Selecciona la carpeta INVENTARIO_STORAGE
4. Ve a "Cargar Respaldo Completo" y selecciona este ZIP
5. O copia este archivo a: INVENTARIO_STORAGE/backups/zip/

DIFERENCIAS ENTRE TIPOS DE BACKUP:
-----------------------------------
📄 Backup Automático (JSON): ~150-200KB
   - Se crea automáticamente al guardar cambios
   - Incluye: repuestos, mapas, áreas, estadísticas
   - NO incluye imágenes (solo referencias)
   - Ubicación: backups/automaticos/
   - Rotación: Se mantienen los últimos 5

📦 Respaldo Completo (ZIP): Variable (depende de imágenes)
   - Se crea manualmente desde "Exportar Respaldo Completo"
   - Incluye: repuestos, mapas, áreas, TODAS LAS IMÁGENES
   - Ideal para migración o respaldo externo
   - Ubicación: backups/zip/
   - Rotación: Se mantienen los últimos 5

RECOMENDACIONES:
----------------
✓ Los backups automáticos JSON son suficientes para uso diario
✓ Crea respaldos ZIP completos semanalmente o antes de actualizar
✓ Descarga los ZIP importantes a tu PC para respaldo externo
✓ Los archivos ZIP pueden ser muy grandes si tienes muchas imágenes

SOPORTE TÉCNICO:
----------------
Para más información, consulta la documentación en:
DOCUMENTACION/GUIA_RAPIDA.md

© Inventario Visual PRO - Sistema de Gestión de Repuestos v5.3.2
      `.trim();
      
      zip.file('README.txt', readme);
      
      // 5. Agregar imágenes si hay FileSystem activo
      if (fsManager.imagesFolder) {
        const imagenesFolder = zip.folder('imagenes');
        
        for await (const entry of fsManager.imagesFolder.values()) {
          if (entry.kind === 'file') {
            try {
              const file = await entry.getFile();
              imagenesFolder.file(file.name, file);
            } catch (error) {
              console.error(`Error agregando imagen ${entry.name}:`, error);
            }
          }
        }
        
        console.log(`📸 ${imagenCount} imágenes agregadas al respaldo`);
      }
      
      // 6. Generar ZIP en memoria
      const blob = await zip.generateAsync({ 
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });
      
      const filename = `Respaldo_Completo_${new Date().toISOString().split('T')[0]}.zip`;
      const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
      
      // 7. Guardar en INVENTARIO_STORAGE/backups/zip/
      const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: true });
      const zipDir = await backupsDir.getDirectoryHandle('zip', { create: true });
      
      // Eliminar respaldos antiguos si hay más de 5
      const respaldos = [];
      for await (const entry of zipDir.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.zip')) {
          const file = await entry.getFile();
          respaldos.push({
            name: entry.name,
            timestamp: file.lastModified
          });
        }
      }
      
      respaldos.sort((a, b) => a.timestamp - b.timestamp);
      while (respaldos.length >= 5) {
        const antiguo = respaldos.shift();
        await zipDir.removeEntry(antiguo.name);
        console.log(`🗑️ Respaldo antiguo eliminado: ${antiguo.name}`);
      }
      
      // Guardar nuevo respaldo
      const fileHandle = await zipDir.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
      
      const rutaCompleta = `INVENTARIO_STORAGE/backups/zip/${filename}`;
      
      // Mostrar modal con información
      const html = `
        <div style="text-align: center; padding: 20px;">
          <div style="font-size: 3rem; margin-bottom: 16px;">✅</div>
          <h3 style="color: var(--success); margin-bottom: 16px;">Respaldo Completo Creado</h3>
          
          <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; margin: 20px 0; text-align: left;">
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">📦 Archivo:</strong>
              <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; margin-top: 6px; font-family: monospace; font-size: 0.9rem; color: var(--primary); word-break: break-all;">
                ${filename}
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">� Ruta:</strong>
              <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; margin-top: 6px; font-family: monospace; font-size: 0.85rem; color: var(--success); word-break: break-all;">
                ${rutaCompleta}
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">� Tamaño:</strong>
              <div style="color: var(--text-secondary); margin-top: 4px;">
                ${sizeMB} MB
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <strong style="color: var(--text-primary);">� Contenido:</strong>
              <div style="color: var(--text-secondary); margin-top: 4px;">
                • ${app.repuestos.length} repuestos<br>
                • ${imagenCount} imágenes<br>
                • Mapas y áreas
              </div>
            </div>
          </div>
          
          <div style="background: rgba(59, 130, 246, 0.1); padding: 12px; border-radius: 6px; margin: 16px 0; border-left: 4px solid var(--primary);">
            <div style="font-size: 0.85rem; color: var(--text-secondary);">
              💡 <strong>Para migrar a otra versión:</strong><br>
              1. Copia toda la carpeta <code>INVENTARIO_STORAGE/backups/</code><br>
              2. Pégala en la nueva versión<br>
              3. Usa "Cargar Respaldo Completo" para restaurar
            </div>
          </div>
          
          <div style="display: grid; gap: 10px;">
            <button onclick="configuracion.descargarUltimoZip('${filename}')" class="btn btn-success" style="width: 100%; padding: 12px;">
              💾 Descargar ZIP al Navegador (Downloads)
            </button>
            <button onclick="configuracion.cerrarModal()" class="btn btn-secondary" style="width: 100%; padding: 12px;">
              Cerrar
            </button>
          </div>
        </div>
      `;
      
      this.mostrarModal(html);
      
      console.log(`✅ Respaldo completo guardado en: ${rutaCompleta}`);
      
    } catch (error) {
      console.error('❌ Error creando respaldo completo:', error);
      app.showToast('❌ Error: ' + error.message, 'error');
    }
  },

  async cargarRespaldoCompleto() {
    if (!fsManager.isFileSystemMode || !fsManager.directoryHandle) {
      app.showToast('⚠️ Primero debes seleccionar una carpeta de trabajo', 'warning');
      return;
    }

    try {
      // Obtener la carpeta de respaldos completos
      const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: true });
      const zipDir = await backupsDir.getDirectoryHandle('zip', { create: true });
      
      // Listar archivos ZIP disponibles
      const respaldos = [];
      for await (const entry of zipDir.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.zip')) {
          const file = await entry.getFile();
          respaldos.push({
            name: entry.name,
            handle: entry,
            file: file,
            timestamp: file.lastModified,
            fecha: new Date(file.lastModified).toLocaleString('es-ES'),
            size: (file.size / (1024 * 1024)).toFixed(2) + ' MB'
          });
        }
      }
      
      if (respaldos.length === 0) {
        app.showToast('⚠️ No hay respaldos ZIP disponibles en backups/zip/', 'warning', 4000);
        return;
      }
      
      // Ordenar por fecha (más reciente primero)
      respaldos.sort((a, b) => b.timestamp - a.timestamp);
      
      // Mostrar modal con lista de respaldos
      let html = `
        <div style="max-height: 500px; overflow-y: auto;">
          <h3 style="margin: 0 0 16px 0; color: var(--primary);">
            📦 Seleccionar Respaldo ZIP (${respaldos.length})
          </h3>
          <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 20px;">
            Ubicación: <code>INVENTARIO_STORAGE/backups/zip/</code>
          </p>
      `;
      
      respaldos.forEach((respaldo, index) => {
        html += `
          <div style="background: var(--bg-primary); padding: 16px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid ${index === 0 ? 'var(--success)' : 'var(--primary)'}; cursor: pointer;" onclick="configuracion.restaurarRespaldoCompletoPorIndice(${index})">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
              <div style="flex: 1;">
                <strong style="color: var(--text-primary);">${respaldo.name}</strong>
                <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 4px;">
                  📅 ${respaldo.fecha}
                </div>
              </div>
              <span style="background: ${index === 0 ? 'var(--success)' : 'var(--primary)'}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; white-space: nowrap;">
                ${index === 0 ? '🌟 Más Reciente' : `#${index + 1}`}
              </span>
            </div>
            
            <div style="display: flex; gap: 20px; font-size: 0.85rem; color: var(--text-secondary);">
              <div>
                <strong>💾 Tamaño:</strong> ${respaldo.size}
              </div>
            </div>
            
            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
              <button onclick="event.stopPropagation(); configuracion.restaurarRespaldoCompletoPorIndice(${index})" 
                      class="btn ${index === 0 ? 'btn-success' : 'btn-primary'}" 
                      style="width: 100%; padding: 10px; font-size: 0.9rem;">
                🔄 Cargar Este Respaldo
              </button>
            </div>
          </div>
        `;
      });
      
      html += `
        </div>
        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--border-color);">
          <button onclick="configuracion.cerrarModal()" 
                  class="btn btn-secondary" 
                  style="width: 100%; padding: 12px;">
            Cancelar
          </button>
        </div>
      `;
      
      this.mostrarModal(html);
      
      // Guardar referencia a los respaldos
      this._respaldosCache = respaldos;
      
    } catch (error) {
      console.error('❌ Error listando respaldos completos:', error);
      app.showToast('❌ Error al buscar respaldos: ' + error.message, 'error');
    }
  },

  _respaldosCache: [],

  async restaurarRespaldoCompletoPorIndice(index) {
    const respaldo = this._respaldosCache[index];
    if (!respaldo) return;

    if (!window.JSZip) {
      app.showToast('❌ Error: Librería JSZip no cargada', 'error');
      return;
    }

    try {
      app.showToast('📦 Cargando respaldo completo...', 'info', 3000);
      
      const zip = await JSZip.loadAsync(respaldo.file);
      
      // 1. Cargar repuestos
      const repuestosFile = zip.file('repuestos.json');
      if (repuestosFile) {
        const data = JSON.parse(await repuestosFile.async('text'));
        
        const confirmacion = confirm(
          `🔄 CARGAR RESPALDO COMPLETO\n\n` +
          `📦 Archivo: ${respaldo.name}\n` +
          `📅 Fecha del respaldo: ${new Date(data.fecha).toLocaleString('es-ES')}\n` +
          `� Repuestos: ${data.totalRepuestos}\n` +
          `📊 Versión: ${data.version}\n\n` +
          `⚠️ Esto reemplazará todos los datos actuales.\n\n` +
          `¿Continuar?`
        );
        
        if (!confirmacion) return;
        
        app.repuestos = data.repuestos || [];
        await app.saveData();
      }
      
      // 2. Cargar mapas si existen
      const mapasFile = zip.file('mapas.json');
      if (mapasFile && mapStorage) {
        const datosMapas = JSON.parse(await mapasFile.async('text'));
        // Aquí se cargarían los mapas (requiere implementación en mapStorage)
        console.log('📍 Mapas encontrados:', datosMapas);
      }
      
      // 3. Restaurar imágenes si hay FileSystem activo
      if (fsManager.imagesFolder) {
        const imagenesFolder = zip.folder('imagenes');
        if (imagenesFolder) {
          let restauradas = 0;
          
          for (const [filename, fileData] of Object.entries(imagenesFolder.files)) {
            if (!fileData.dir) {
              try {
                const blob = await fileData.async('blob');
                const fileHandle = await fsManager.imagesFolder.getFileHandle(filename.split('/').pop(), { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                restauradas++;
              } catch (error) {
                console.error(`Error restaurando ${filename}:`, error);
              }
            }
          }
          
          console.log(`📸 ${restauradas} imágenes restauradas`);
        }
      }
      
      await app.render();
      app.renderFilters();
      app.updateAutocompleteData();
      
      this.cerrarModal();
      app.showToast(`✅ Respaldo completo cargado correctamente`, 'success', 4000);
      
    } catch (error) {
      console.error('❌ Error cargando respaldo:', error);
      app.showToast('❌ Error: ' + error.message, 'error');
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // � EXPORTAR APP PORTABLE COMPLETA (Todo en un ZIP)
  // ═══════════════════════════════════════════════════════════════════
  
  async exportarAppCompleta() {
    if (!window.JSZip) {
      app.showToast('❌ Error: Librería JSZip no cargada', 'error');
      return;
    }

    try {
      const toastId = app.showToast('📦 Creando paquete portable completo... Esto puede tardar', 'info', 10000);
      
      const zip = new JSZip();
      const version = '5.3.4'; // 🔧 FIX: Versión correcta
      const fecha = new Date();
      
      // Formato de fecha y hora más claro: YYYY-MM-DD_HH-MM-SS
      const anio = fecha.getFullYear();
      const mes = String(fecha.getMonth() + 1).padStart(2, '0');
      const dia = String(fecha.getDate()).padStart(2, '0');
      const hora = String(fecha.getHours()).padStart(2, '0');
      const minutos = String(fecha.getMinutes()).padStart(2, '0');
      const segundos = String(fecha.getSeconds()).padStart(2, '0');
      const timestamp = `${anio}-${mes}-${dia}_${hora}-${minutos}-${segundos}`;
      
      const filename = `InventarioPortable_v${version}_${timestamp}.zip`;
      console.log(`📦 Creando: ${filename}`);
      
      // 1. Agregar el archivo HTML principal (desde el documento actual)
      const htmlContent = document.documentElement.outerHTML;
      zip.file(`inventario_v${version}.html`, '<!DOCTYPE html>\n' + htmlContent);
      
      // 2. Agregar INVENTARIO_STORAGE completo si existe
      if (fsManager.isFileSystemMode && fsManager.directoryHandle) {
        const storageFolder = zip.folder('INVENTARIO_STORAGE');
        
        // Función recursiva para agregar carpetas y archivos
        const agregarCarpetaAlZip = async (dirHandle, zipFolder) => {
          for await (const entry of dirHandle.values()) {
            if (entry.kind === 'file') {
              try {
                const file = await entry.getFile();
                zipFolder.file(entry.name, file);
                console.log(`✅ Agregado: ${entry.name}`);
              } catch (error) {
                console.warn(`⚠️ No se pudo agregar: ${entry.name}`, error);
              }
            } else if (entry.kind === 'directory') {
              const subFolder = zipFolder.folder(entry.name);
              await agregarCarpetaAlZip(entry, subFolder);
            }
          }
        };
        
        // Agregar todo INVENTARIO_STORAGE
        await agregarCarpetaAlZip(fsManager.directoryHandle, storageFolder);
        console.log('📦 INVENTARIO_STORAGE agregado al ZIP');
      }
      
      // 3. Crear README de instalación
      const readme = `
╔════════════════════════════════════════════════════════════════╗
║                                                                ║
║         📦 INVENTARIO PORTABLE v${version}                         ║
║            Sistema de Gestión de Repuestos                    ║
║                                                                ║
╚════════════════════════════════════════════════════════════════╝

📅 Fecha de exportación: ${fecha.toLocaleString('es-ES')}
🎁 Paquete: Aplicación completa con todos los datos

═══════════════════════════════════════════════════════════════

📋 CONTENIDO DEL PAQUETE:
────────────────────────────────────────────────────────────────

1. inventario_v${version}.html
   • Aplicación principal (archivo único)
   • Abre con cualquier navegador moderno

2. INVENTARIO_STORAGE/
   • Todos tus datos y configuraciones
   • Backups automáticos
   • Imágenes de repuestos
   • Mapas y configuraciones

═══════════════════════════════════════════════════════════════

🚀 INSTRUCCIONES DE INSTALACIÓN EN OTRO PC:
────────────────────────────────────────────────────────────────

PASO 1: Extraer el ZIP
   • Descomprime este ZIP en cualquier carpeta de tu PC
   • Ejemplo: C:\\MisAplicaciones\\Inventario\\
   • MANTÉN JUNTOS el HTML y la carpeta INVENTARIO_STORAGE

PASO 2: Abrir la aplicación
   • Doble clic en: inventario_v${version}.html
   • Se abrirá en tu navegador predeterminado

PASO 3: Conectar la carpeta de datos (IMPORTANTE)
   • En la pantalla inicial, click en "📁 Seleccionar Carpeta"
   • Selecciona la carpeta: INVENTARIO_STORAGE
   • ¡TODAS las imágenes, mapas y datos se cargarán automáticamente!

⚠️ NOTA CRÍTICA: 
   Sin conectar la carpeta INVENTARIO_STORAGE no verás:
   • Imágenes de repuestos
   • Imágenes en marcadores del mapa
   • Backups guardados
   
   Siempre selecciona la carpeta primero antes de usar la app.

═══════════════════════════════════════════════════════════════

✅ VENTAJAS DE ESTE PAQUETE:
────────────────────────────────────────────────────────────────

✓ No requiere instalación
✓ Funciona sin internet
✓ Portátil entre PCs
✓ Incluye TODOS tus datos
✓ Backups incluidos
✓ Imágenes incluidas
✓ Compatible Windows/Mac/Linux

═══════════════════════════════════════════════════════════════

⚙️ REQUISITOS:
────────────────────────────────────────────────────────────────

• Navegador moderno (Chrome 86+, Edge 86+, Opera 72+)
• JavaScript habilitado
• File System Access API (automático en navegadores modernos)

═══════════════════════════════════════════════════════════════

📁 ESTRUCTURA DE ARCHIVOS:
────────────────────────────────────────────────────────────────

InventarioPortable_v${version}_${timestamp}.zip
├── README.txt (este archivo)
├── inventario_v${version}.html (aplicación)
└── INVENTARIO_STORAGE/
    ├── backups/
    │   ├── automaticos/  (backups JSON)
    │   ├── zip/          (respaldos completos)
    │   ├── mapas/        (backups de mapas)
    │   └── zonas/        (backups de áreas)
    └── imagenes/         (fotos de repuestos)

═══════════════════════════════════════════════════════════════

🔄 MIGRACIÓN ENTRE VERSIONES:
────────────────────────────────────────────────────────────────

Para actualizar a una versión futura:
1. Guarda tu carpeta INVENTARIO_STORAGE
2. Descarga la nueva versión HTML
3. Abre la nueva versión
4. Selecciona tu carpeta INVENTARIO_STORAGE existente
5. ¡Todos tus datos estarán disponibles!

═══════════════════════════════════════════════════════════════

🆘 SOPORTE Y DOCUMENTACIÓN:
────────────────────────────────────────────────────────────────

Dentro de la aplicación:
• Click en ⚙️ Configuración
• Sección "Ayuda y Documentación"
• Guías rápidas disponibles

═══════════════════════════════════════════════════════════════

© 2025 Inventario Visual PRO v${version}
Sistema de Gestión de Repuestos con Mapas Visuales

      `.trim();
      
      zip.file('README.txt', readme);
      
      // 4. Generar ZIP
      const blob = await zip.generateAsync({ 
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      }, (metadata) => {
        const porcentaje = metadata.percent.toFixed(0);
        console.log(`📦 Comprimiendo: ${porcentaje}%`);
      });
      
      const sizeMB = (blob.size / (1024 * 1024)).toFixed(2);
      
      // 5. Guardar en la carpeta de backups/app_portable/
      if (fsManager.isFileSystemMode && fsManager.directoryHandle) {
        try {
          // Obtener/crear carpeta backups
          const backupsDir = await fsManager.directoryHandle.getDirectoryHandle('backups', { create: true });
          
          // Obtener/crear carpeta app_portable dentro de backups
          const appPortableDir = await backupsDir.getDirectoryHandle('app_portable', { create: true });
          
          // Crear archivo en la carpeta app_portable
          const fileHandle = await appPortableDir.getFileHandle(filename, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          
          console.log(`✅ App portable guardada en: INVENTARIO_STORAGE/backups/app_portable/${filename}`);
          
          // 6. Mostrar modal de éxito
          const html = `
            <div class="modal-content" style="max-width: 500px;">
              <h3 style="margin: 0 0 20px 0; color: #2c3e50; display: flex; align-items: center; gap: 10px;">
                ✅ <span>App Portable Exportada</span>
              </h3>
              
              <div style="background: #d4edda; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                <p style="margin: 0 0 10px 0; font-weight: bold; color: #155724;">📦 Paquete Completo Guardado:</p>
                <div style="background: white; padding: 10px; border-radius: 6px; margin-top: 10px;">
                  <div style="font-size: 16px; font-weight: bold; color: #2196F3; margin-bottom: 5px;">
                    ${filename}
                  </div>
                  <div style="font-size: 13px; color: #666;">
                    Tamaño: ${sizeMB} MB
                  </div>
                  <div style="font-size: 12px; color: #888; margin-top: 5px;">
                    📂 INVENTARIO_STORAGE/backups/app_portable/
                  </div>
                </div>
              </div>
              
              <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <p style="margin: 0 0 10px 0; font-weight: bold; color: #495057;">📦 Contenido incluido:</p>
                <ul style="margin: 0; padding-left: 20px; color: #666; font-size: 14px;">
                  <li>✅ Aplicación HTML completa</li>
                  <li>✅ Todos tus datos y repuestos</li>
                  <li>✅ Todas las imágenes</li>
                  <li>✅ Backups automáticos</li>
                  <li>✅ Mapas y configuraciones</li>
                  <li>✅ README con instrucciones</li>
                </ul>
              </div>
              
              <div style="background: #e7f3ff; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #2196F3;">
                <p style="margin: 0; font-size: 13px; color: #0d47a1;">
                  💡 <strong>En otro PC:</strong> Simplemente extrae el ZIP y abre el archivo HTML. 
                  Luego selecciona la carpeta INVENTARIO_STORAGE y tendrás todo funcionando.
                </p>
              </div>
              
              <div style="display: grid; gap: 10px;">
                <button onclick="configuracion.cerrarModal()" class="btn btn-primary" style="width: 100%; padding: 12px;">
                  Entendido
                </button>
              </div>
            </div>
          `;
          
          this.mostrarModal(html);
          app.showToast(`✅ App portable guardada en backups/app_portable/`, 'success', 5000);
          console.log(`✅ App portable exportada: ${filename}`);
          
        } catch (error) {
          console.error('❌ Error guardando en backups:', error);
          app.showToast('❌ Error al guardar en backups: ' + error.message, 'error');
        }
      } else {
        // Si no hay FileSystem conectado, descargar al navegador
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        app.showToast(`✅ App portable descargada: ${filename}`, 'success', 5000);
        console.log(`✅ App portable descargada: ${filename}`);
      }
      
    } catch (error) {
      console.error('❌ Error exportando app completa:', error);
      app.showToast('❌ Error: ' + error.message, 'error');
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // �📊 MÉTODO DE EXPORTAR A EXCEL (Vinculado a app.exportExcel())
  // ═══════════════════════════════════════════════════════════════════
  
  exportarExcel() {
    try {
      // Llamar al método existente de app
      app.exportExcel();
    } catch (error) {
      console.error('❌ Error exportando a Excel:', error);
      app.showToast('❌ Error al exportar Excel: ' + error.message, 'error');
    }
  },

  // ═══════════════════════════════════════════════════════════════════
  // 📱 EXPORTAR HTML EMBEBIDO PARA MÓVIL (standalone sin FileSystem)
  // ═══════════════════════════════════════════════════════════════════
  
  exportarHTMLConDatosEmbebidos() {
    app.showToast('📱 Función no implementada aún. Esta función permitirá exportar un HTML standalone con todos los datos embebidos (sin necesidad de FileSystem) ideal para usar en móviles sin conexión.', 'info', 5000);
    
    // NOTA: Esta función exportaría un archivo HTML único que contiene:
    // 1. Todo el código HTML/CSS/JS de la aplicación
    // 2. Datos JSON embebidos en el <script>
    // 3. Imágenes convertidas a base64 embebidas
    // 4. Sin dependencia de FileSystem API (usa LocalStorage)
    // Ideal para: compartir inventario completo en un solo archivo portable
  }
};


// ========================================================================
// 🚀 INICIALIZACIÓN CENTRALIZADA DE LA APLICACIÓN
// ========================================================================
(async () => {
  console.log('\n🚀 Iniciando aplicación...\n');
  
  // 🔄 PASO 1: Auto-reconexión si existe sesión previa
  if (localStorage.getItem('fsDirectory') === 'enabled') {
    console.log('🔄 Detectada sesión FileSystem previa, intentando auto-reconexión...');
    await app.connectWorkspace(true, false); // isReconnect=true, promptUser=false
  } else {
    console.log('ℹ️ No hay sesión previa - Usuario deberá conectar carpeta manualmente');
  }
  
  // 🔄 PASO 2: Inicializar la app (sin cargar datos, ya los cargó connectWorkspace si fue exitoso)
  // Si NO hubo reconexión, init() cargará desde localStorage
  if (!fsManager.isConnected) {
    await app.init();
  } else {
    // Solo hacer render sin cargar datos (ya están cargados por connectWorkspace)
    app.showBrowserWarning();
    
    if (typeof configuracion !== 'undefined') {
      setTimeout(() => {
        configuracion.renderStorageUI();
        configuracion.loadICloudPathConfig();
      }, 100);
    }
    
    app.setupEvents();
    app.setupDelegatedEvents();
    app.setupPhotoInputs();
    app.applyViewModeStyles();
    app.updateViewModeInfo();
    // NO llamar loadData() porque connectWorkspace ya lo hizo
    // await app.render(); // Ya se hizo en connectWorkspace
    app.renderFilters();
    
    const savedAutocomplete = localStorage.getItem('autocompleteData');
    if (savedAutocomplete) {
      try {
        app.autocompleteData = JSON.parse(savedAutocomplete);
      } catch (e) {
        console.warn('Error cargando autocomplete guardado, regenerando...', e);
        app.updateAutocompleteData();
      }
    } else {
      app.updateAutocompleteData();
    }
    
    app.setupAutocomplete();
    
    const equipoInput = document.getElementById('equipo');
    if (equipoInput) {
      equipoInput.addEventListener('blur', () => {
        const equipo = equipoInput.value.trim();
        if (equipo) {
          app.cargarSistemasPorEquipo(equipo);
        }
      });
    }
  }
  
  // 🔄 PASO 3: Inicializar otros módulos
  okrModule.init();
  console.log('App inicializada:', app);
  console.log('Repuestos cargados:', app.repuestos.length);
  
  // � Inicializar sistema de backups por inactividad
  if (typeof backupManager !== 'undefined') {
    backupManager.init();
    // Agregar referencia en configuracion para acceso fácil
    if (typeof configuracion !== 'undefined') {
      configuracion.backupManager = backupManager;
    }
  }
  
  // �🗺️ PASO 2.5: Inicializar MapController si el canvas existe
  if (document.getElementById('mapCanvas')) {
    try {
      mapController.init();
      console.log('🗺️ MapController inicializado correctamente');
    } catch (error) {
      console.warn('⚠️ Error inicializando MapController:', error);
    }
  } else {
    console.log('ℹ️ Canvas de mapa no encontrado - MapController no inicializado');
  }
  
  // 🔄 PASO 3: Limpiar localStorage si estamos en modo FileSystem
  if (fsManager.isFileSystemMode) {
    await app.cleanBase64ImagesFromLocalStorage();
    configuracion.actualizarEstadoUI();
    
    // 📊 DIAGNÓSTICO COMPLETO DE RUTAS
    console.log('\n═════════════════════════════════════════════');
    console.log('📊 DIAGNÓSTICO DE RUTAS Y CARGA');
    console.log('═════════════════════════════════════════════');
    
    const carpetaNombre = localStorage.getItem('fsFolderName') || 'INVENTARIO_PORTABLE';
    console.log(`📁 Carpeta base: ${carpetaNombre}`);
    console.log(`📁 Storage: ${carpetaNombre}/INVENTARIO_STORAGE`);
    console.log(`📁 Imágenes: ${carpetaNombre}/INVENTARIO_STORAGE/imagenes/`);
    console.log(`📄 JSON: ${carpetaNombre}/INVENTARIO_STORAGE/inventario.json`);
    
    console.log('\n📦 Repuestos:');
    const conImagenes = app.repuestos.filter(r => r.multimedia && r.multimedia.length > 0);
    const sinImagenes = app.repuestos.filter(r => !r.multimedia || r.multimedia.length === 0);
    console.log(`  ✅ Con imágenes: ${conImagenes.length}`);
    console.log(`  ⚪ Sin imágenes: ${sinImagenes.length}`);
    console.log(`  📊 Total: ${app.repuestos.length}`);
    
    console.log('\n💾 localStorage:');
    const localData = localStorage.getItem('inventarioData');
    if (localData) {
      const localMB = (new Blob([localData]).size / (1024 * 1024)).toFixed(2);
      console.log(`  📊 Tamaño: ${localMB} MB`);
      
      const data = JSON.parse(localData);
      let base64Count = 0;
      data.forEach(item => {
        if (item.multimedia && item.multimedia.length > 0) {
          item.multimedia.forEach(media => {
            if (media.url && media.url.startsWith('data:image')) {
              base64Count++;
            }
          });
        }
      });
      console.log(`  ${base64Count === 0 ? '✅' : '⚠️'} Imágenes base64: ${base64Count}`);
    } else {
      console.log('  ⚪ Vacío');
    }
    
    console.log('\n✨ RESUMEN:');
    console.log(`  ✅ Todas las referencias desde: ${carpetaNombre}`);
    console.log('  ✅ Imágenes: FileSystem (sin límites)');
    console.log('  ✅ Datos: JSON + localStorage (backup)');
    console.log('  ✅ Sin referencias externas');
    console.log('═════════════════════════════════════════════\n');
    
    // Mostrar notificación de éxito
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      bottom: 100px;
      right: 30px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 15px 25px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      z-index: 9998;
      font-size: 14px;
      animation: slideIn 0.3s ease-out;
    `;
    notification.innerHTML = '✅ Modo Carpeta conectado<br><small style="opacity: 0.9;">∞ Capacidad ilimitada activa</small>';
    document.body.appendChild(notification);
    
    // Remover después de 3 segundos
    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }
})();

// Toggle dropdowns - Función global
function toggleDropdown(dropdownId) {
  const dropdown = document.getElementById(dropdownId);
  const isOpen = dropdown.style.display === 'block';
  
  // Cerrar todos los dropdowns
  document.querySelectorAll('[id$="Dropdown"]').forEach(d => {
    d.style.display = 'none';
  });
  
  // Toggle el seleccionado
  if (!isOpen) {
    dropdown.style.display = 'block';
  }
}

// Cerrar dropdowns al hacer click fuera
document.addEventListener('click', (e) => {
  if (!e.target.closest('[onclick*="toggleDropdown"]') && !e.target.closest('.dropdown-item')) {
    document.querySelectorAll('[id$="Dropdown"]').forEach(d => {
      d.style.display = 'none';
    });
  }
});

// Hacer la app accesible globalmente para debugging
window.app = app;
window.okrModule = okrModule;
window.mapStorage = mapStorage; // ️ AHORA DISPONIBLE - MapStorage integrado
window.mapController = mapController; // 🗺️ Controlador de mapas
console.log('App disponible en: window.app');
console.log('=== SISTEMA LISTO ===');
</script>

<!-- MODAL DE DETALLES (para backups, confirmaciones, etc.) -->
<div id="modalDetalles" onclick="if(event.target === this) configuracion.cerrarModal()" class="modal-detalles-overlay">
  <div class="modal-detalles-container">
    <div id="modalDetallesContenido" class="modal-detalles-content">
      <!-- Contenido dinámico -->
    </div>
  </div>
</div>

<style>
  #modalDetalles {
    display: none;
  }
  
  #modalDetalles[style*="display: block"] {
    display: flex !important;
  }
  
  #modalDetalles > div {
    animation: modalSlideIn 0.3s ease-out;
  }
  
  @keyframes modalSlideIn {
    from {
      transform: translateY(-50px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
</style>

</body>
</html>

